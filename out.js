(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/lz-string/libs/lz-string.js
  var require_lz_string = __commonJS({
    "node_modules/lz-string/libs/lz-string.js"(exports, module) {
      var LZString3 = (function() {
        var f = String.fromCharCode;
        var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
        var baseReverseDic = {};
        function getBaseValue(alphabet, character) {
          if (!baseReverseDic[alphabet]) {
            baseReverseDic[alphabet] = {};
            for (var i = 0; i < alphabet.length; i++) {
              baseReverseDic[alphabet][alphabet.charAt(i)] = i;
            }
          }
          return baseReverseDic[alphabet][character];
        }
        var LZString4 = {
          compressToBase64: function(input) {
            if (input == null) return "";
            var res = LZString4._compress(input, 6, function(a) {
              return keyStrBase64.charAt(a);
            });
            switch (res.length % 4) {
              // To produce valid Base64
              default:
              // When could this happen ?
              case 0:
                return res;
              case 1:
                return res + "===";
              case 2:
                return res + "==";
              case 3:
                return res + "=";
            }
          },
          decompressFromBase64: function(input) {
            if (input == null) return "";
            if (input == "") return null;
            return LZString4._decompress(input.length, 32, function(index) {
              return getBaseValue(keyStrBase64, input.charAt(index));
            });
          },
          compressToUTF16: function(input) {
            if (input == null) return "";
            return LZString4._compress(input, 15, function(a) {
              return f(a + 32);
            }) + " ";
          },
          decompressFromUTF16: function(compressed) {
            if (compressed == null) return "";
            if (compressed == "") return null;
            return LZString4._decompress(compressed.length, 16384, function(index) {
              return compressed.charCodeAt(index) - 32;
            });
          },
          //compress into uint8array (UCS-2 big endian format)
          compressToUint8Array: function(uncompressed) {
            var compressed = LZString4.compress(uncompressed);
            var buf = new Uint8Array(compressed.length * 2);
            for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
              var current_value = compressed.charCodeAt(i);
              buf[i * 2] = current_value >>> 8;
              buf[i * 2 + 1] = current_value % 256;
            }
            return buf;
          },
          //decompress from uint8array (UCS-2 big endian format)
          decompressFromUint8Array: function(compressed) {
            if (compressed === null || compressed === void 0) {
              return LZString4.decompress(compressed);
            } else {
              var buf = new Array(compressed.length / 2);
              for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
                buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
              }
              var result = [];
              buf.forEach(function(c) {
                result.push(f(c));
              });
              return LZString4.decompress(result.join(""));
            }
          },
          //compress into a string that is already URI encoded
          compressToEncodedURIComponent: function(input) {
            if (input == null) return "";
            return LZString4._compress(input, 6, function(a) {
              return keyStrUriSafe.charAt(a);
            });
          },
          //decompress from an output of compressToEncodedURIComponent
          decompressFromEncodedURIComponent: function(input) {
            if (input == null) return "";
            if (input == "") return null;
            input = input.replace(/ /g, "+");
            return LZString4._decompress(input.length, 32, function(index) {
              return getBaseValue(keyStrUriSafe, input.charAt(index));
            });
          },
          compress: function(uncompressed) {
            return LZString4._compress(uncompressed, 16, function(a) {
              return f(a);
            });
          },
          _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
            if (uncompressed == null) return "";
            var i, value2, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
            for (ii = 0; ii < uncompressed.length; ii += 1) {
              context_c = uncompressed.charAt(ii);
              if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
                context_dictionary[context_c] = context_dictSize++;
                context_dictionaryToCreate[context_c] = true;
              }
              context_wc = context_w + context_c;
              if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
                context_w = context_wc;
              } else {
                if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                  if (context_w.charCodeAt(0) < 256) {
                    for (i = 0; i < context_numBits; i++) {
                      context_data_val = context_data_val << 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                    }
                    value2 = context_w.charCodeAt(0);
                    for (i = 0; i < 8; i++) {
                      context_data_val = context_data_val << 1 | value2 & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value2 = value2 >> 1;
                    }
                  } else {
                    value2 = 1;
                    for (i = 0; i < context_numBits; i++) {
                      context_data_val = context_data_val << 1 | value2;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value2 = 0;
                    }
                    value2 = context_w.charCodeAt(0);
                    for (i = 0; i < 16; i++) {
                      context_data_val = context_data_val << 1 | value2 & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value2 = value2 >> 1;
                    }
                  }
                  context_enlargeIn--;
                  if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                  }
                  delete context_dictionaryToCreate[context_w];
                } else {
                  value2 = context_dictionary[context_w];
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value2 & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value2 = value2 >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                context_dictionary[context_wc] = context_dictSize++;
                context_w = String(context_c);
              }
            }
            if (context_w !== "") {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value2 = context_w.charCodeAt(0);
                  for (i = 0; i < 8; i++) {
                    context_data_val = context_data_val << 1 | value2 & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value2 = value2 >> 1;
                  }
                } else {
                  value2 = 1;
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value2;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value2 = 0;
                  }
                  value2 = context_w.charCodeAt(0);
                  for (i = 0; i < 16; i++) {
                    context_data_val = context_data_val << 1 | value2 & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value2 = value2 >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value2 = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value2 & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value2 = value2 >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
            }
            value2 = 2;
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1 | value2 & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value2 = value2 >> 1;
            }
            while (true) {
              context_data_val = context_data_val << 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data.push(getCharFromInt(context_data_val));
                break;
              } else context_data_position++;
            }
            return context_data.join("");
          },
          decompress: function(compressed) {
            if (compressed == null) return "";
            if (compressed == "") return null;
            return LZString4._decompress(compressed.length, 32768, function(index) {
              return compressed.charCodeAt(index);
            });
          },
          _decompress: function(length, resetValue, getNextValue) {
            var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
            for (i = 0; i < 3; i += 1) {
              dictionary[i] = i;
            }
            bits = 0;
            maxpower = Math.pow(2, 2);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (next = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                c = f(bits);
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                c = f(bits);
                break;
              case 2:
                return "";
            }
            dictionary[3] = c;
            w = c;
            result.push(c);
            while (true) {
              if (data.index > length) {
                return "";
              }
              bits = 0;
              maxpower = Math.pow(2, numBits);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              switch (c = bits) {
                case 0:
                  bits = 0;
                  maxpower = Math.pow(2, 8);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  dictionary[dictSize++] = f(bits);
                  c = dictSize - 1;
                  enlargeIn--;
                  break;
                case 1:
                  bits = 0;
                  maxpower = Math.pow(2, 16);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  dictionary[dictSize++] = f(bits);
                  c = dictSize - 1;
                  enlargeIn--;
                  break;
                case 2:
                  return result.join("");
              }
              if (enlargeIn == 0) {
                enlargeIn = Math.pow(2, numBits);
                numBits++;
              }
              if (dictionary[c]) {
                entry = dictionary[c];
              } else {
                if (c === dictSize) {
                  entry = w + w.charAt(0);
                } else {
                  return null;
                }
              }
              result.push(entry);
              dictionary[dictSize++] = w + entry.charAt(0);
              enlargeIn--;
              w = entry;
              if (enlargeIn == 0) {
                enlargeIn = Math.pow(2, numBits);
                numBits++;
              }
            }
          }
        };
        return LZString4;
      })();
      if (typeof define === "function" && define.amd) {
        define(function() {
          return LZString3;
        });
      } else if (typeof module !== "undefined" && module != null) {
        module.exports = LZString3;
      } else if (typeof angular !== "undefined" && angular != null) {
        angular.module("LZString", []).factory("LZString", function() {
          return LZString3;
        });
      }
    }
  });

  // src/model/monster/MonsterDescription.js
  var MonsterDescription = class {
    /**
     * @param {string} id 
     * @param {string} spriteName 
     * @param {string} brainId
     */
    constructor(id, spriteName, brainId) {
      this.id = id;
      this.spriteName = spriteName;
      this.brainId = brainId;
    }
  };

  // src/Settings.js
  var Settings = {};
  Settings.time = {
    /**
     * @constant
     * @type {number}
     */
    defaultFramesPerSecond: 60,
    /**
     * @constant
     * @type {number}
     */
    defaultMillisPerFrame: 1e3 / 60,
    // <-- millis per second / default frame per second
    /**
     * @constant
     * @type {number}
     */
    turnsPerSecond: 4,
    /**
     * @constant
     * @type {number}
     */
    secondsPerTurn: 0.25,
    // 1 seconds / 4 turns per second
    /**
     * @constant
     * @type {number}
     */
    millisPerTurn: 250,
    // 1000 / 4
    /**
     * @constant
     * @type {number}
     */
    turnFrames: 15
    // 60 FPS / 4 turns per second.
  };
  Settings.target = {
    minTargetRow: 5
  };
  Settings.damage = {
    baseDamagePerSecond: 30,
    baseDamagePerTurn: 30 * Settings.time.secondsPerTurn
  };
  Settings.tile = {
    /**
     * @constant
     * @type {number}
     */
    size: 16,
    /**
     * @constant
     * @type {number}
     */
    halfSize: 8,
    /**
     * @constant
     * @type {number}
     */
    halfSizeSquared: 8 * 8,
    /**
     * @constant
     * @type {number}
     */
    threeQuarterSize: 12,
    /**
     * @constant
     * @type {number}
     */
    quarterSize: 4,
    /**
     * @constant
     * @type {number}
     */
    eighthSize: 2,
    /**
     * @constant
     * @type {number}
     */
    doubleSize: 32
  };
  Settings.skillGraph = {
    cellWidth: 260,
    // 220 250
    cellHeight: 110,
    connectorOffsetX: 100,
    connectorOffsetY: 40,
    minZoom: 20,
    // <-- zooming out
    maxZoom: 100,
    // <-- zooming in
    zoomStep: 10,
    nodeViewWidth: 180
    // <-- set in the css 'skill-tree-button-outer'
  };
  Settings.physics = {
    /**
     * @constant
     * @type {number}
     */
    gravityRatePerFrame: 4,
    /**
     * @constant
     * @type {number}
     */
    walkRatePerFrame: 2,
    //3
    /**
     * @constant
     * @type {number}
     */
    jumpRatePerFrame: 2
  };
  Settings.character = {
    jumpPower: 2.5 * Settings.tile.size,
    maxJumpPixelsPerFrame: 2,
    halfWidth: 5
  };
  Settings.combat = {
    critialHitMultiplier: 1.5
  };
  Settings.input = {
    panning: {
      /**
       * The rate at which the motion decays when you drag the map and then let go.
       * @const
       * @type {number}
       */
      decayFactor: 0.95
    }
  };
  Settings.projection = {
    /**
     * @constant
     * @type {number}
     */
    zoomInScaleLimit: 8,
    // 10.0,
    /**
     * The smaller the zoom scale, the further out we are zoomed.
     * @constant
     * @type {number}
     */
    zoomOutScaleLimit: 1.5,
    // 0.5
    /**
     * @constant
     * @type {number}
     */
    zoomDefault: 2,
    /**
     * @constant
     * @type {number}
     */
    zoomStep: 0.25,
    // 0.5
    /**
     * @constant
     * @type {number}
     */
    startCenterX: 0,
    /**
     * @constant
     * @type {number}
     */
    startCenterY: 0
  };
  Settings.text = {
    /**
     * @constant
     * @type {number}
     */
    maxInfoTextCount: 7,
    /**
     * @constant
     * @type {number}
     */
    maxDamageTextCount: 4,
    /**
     * @constant
     * @type {number}
     */
    textFrameDuration: 45
  };
  Settings.grid = {
    /**
     * @constant
     * @type {number}
     */
    numZoneColsInGrid: 3,
    // 4
    /**
     * @constant
     * @type {number}
     */
    numZoneRowsInGrid: 3,
    // 4
    /**
     * @constant
     * @type {number}
     */
    numRegionColsInZone: 2,
    // 2
    /**
     * @constant
     * @type {number}
     */
    numRegionRowsInZone: 2,
    // 2
    /**
     * @constant
     * @type {number}
     */
    numTileColsInRegion: 5,
    // 5
    /**
     * @constant
     * @type {number}
     */
    numTileRowsInRegion: 5
    // 5
  };
  Settings.grid.regionTileWidth = Settings.grid.numTileColsInRegion;
  Settings.grid.regionTileHeight = Settings.grid.numTileRowsInRegion;
  Settings.grid.zoneTileWidth = Settings.grid.numRegionColsInZone * Settings.grid.regionTileWidth;
  Settings.grid.zoneTileHeight = Settings.grid.numRegionRowsInZone * Settings.grid.regionTileHeight;
  Settings.grid.gridTileWidth = Settings.grid.numZoneColsInGrid * Settings.grid.zoneTileWidth;
  Settings.grid.gridTileHeight = Settings.grid.numZoneRowsInGrid * Settings.grid.zoneTileHeight;
  Settings.grid.regionPixelWidth = Settings.grid.regionTileWidth * Settings.tile.size;
  Settings.grid.regionPixelHeight = Settings.grid.regionTileHeight * Settings.tile.size;
  Settings.grid.zonePixelWidth = Settings.grid.zoneTileWidth * Settings.tile.size;
  Settings.grid.zonePixelHeight = Settings.grid.zoneTileHeight * Settings.tile.size;
  Settings.grid.gridPixelWidth = Settings.grid.gridTileWidth * Settings.tile.size;
  Settings.grid.gridPixelHeight = Settings.grid.gridTileHeight * Settings.tile.size;
  Settings.start = {
    /**
     * Start x-coordinate of the character.
     * @constant
     * @type {number}
     */
    startX: 2e4,
    // Middle of the world.
    /**
     * Start y-coordinate of the character.
     * @constant
     * @type {number}
     */
    startY: -100 * Settings.tile.size
  };
  Settings.effect = {
    /**
     * How fast a travel effect moves per frame.
     * @constant
     * @type {number}
     */
    effectTravelPixlesPerFrame: 5.5,
    /**
     * How fast a FAST travel effect moves per frame.
     * @constant
     * @type {number}
     */
    fastEffectTravelPixelsPerFrame: 6.5,
    /**
     * How fast a SLOW travel effect moves per frame.
     * @constant
     * @type {number}
     */
    slowEffectTravelPixelsPerFrame: 3,
    /**
     * The length of time that the lightning effect is active.
     * @constant
     * @type {number}
     */
    lightningFrames: Settings.time.turnFrames * 2
  };
  Settings.lighting = {
    lightSourceRadius: 5
  };
  Settings.skill = {};
  Settings.bonus = {
    newBonusTurns: Settings.time.turnsPerSecond * (60 * 15),
    // 15 minutes?
    activationTurns: Settings.time.turnsPerSecond * (60 * 5),
    activationCost: 1e3
  };
  Settings.prestige = {
    multiplierPerPrestige: 0.2,
    incrementBonusPerUpgrade: 0.2,
    baseBonusPerUpgrade: 0.2
  };
  Settings.ruby = {
    multiplierPerRuby: 1,
    incrementBonusPerUpgrade: 0.2,
    baseBonusPerUpgrade: 0.2
  };
  Settings.blocks = {
    multiplierPerBlock: 0,
    incrementBonusPerUpgrade: 0.01,
    baseBonusPerUpgrade: 0.01
  };
  Settings.depth = {
    multiplierPerDepth: 0.025,
    incrementBonusPerUpgrade: 0.025,
    baseBonusPerUpgrade: 0.025
  };
  Settings.minedDamage = {
    incrementBonusPerUpgrade: 1,
    baseBonusPerUpgrade: 1
  };
  Settings.gold = {
    upgradeBaseCost: 25e3,
    damageMultiplierPerUpgrade: 10,
    oreBonusMultiplierPerUpgrade: 10
  };
  Settings.skill.costs = {
    addDrill1: 0,
    addOrbit1: 1,
    addMissile1: 2,
    addLaser1: 3,
    addMiner1: 5,
    addMiner2: 20,
    addMiner3: 40,
    addMiner4: 60,
    increment: 2
  };
  Settings.skill.fissure = {
    delayMillis: 2500,
    forkChance: 75,
    secondForkChance: 85,
    minBlocks: 3,
    blocksPerUpgrade: 2
  };
  Settings.skill.lightning = {
    minRange: 3,
    delayMillis: 2500,
    forkChance: 75,
    secondForkChance: 85,
    minBlocks: 3,
    blocksPerUpgrade: 1,
    tilesPerUpgrade: 1
  };
  Settings.skill.chain = {
    minRange: 3,
    minSize: 3,
    delayMillis: 2500,
    blocksPerUpgrade: 1,
    tilesPerUpgrade: 1
  };
  Settings.skill.laser = {
    minRange: 3,
    tilesPerUpgrade: 1
  };
  Settings.skill.drill = {
    minRange: 3,
    tilesPerUpgrade: 1
  };
  Settings.skill.missiles = {
    initialMissiles: 5,
    missilesPerUpgrade: 3
  };
  Settings.skill.orbit = {
    minRangePixels: 2 * Settings.tile.size,
    rangePixelsPerUpgrade: Settings.tile.halfSize
  };
  Settings.skill.bonus = {
    oreBonusMultiplierPerUpgrade: 10,
    additiveUpgradeBonusMultiplerPerUpgrade: 2,
    multiplicativeUpgradeBonusMultiplerPerUpgrade: 10,
    minedOreBaseTiles: 8,
    minedOreBonusPerUpgrade: 1,
    fallSpeedMuliplierPerUgrade: 0.15
  };
  Settings.skill.common = {
    damagePercentPerUpgrade: 25,
    damagePerUpgrade: 0.25,
    baseActivationTurns: Settings.time.turnsPerSecond * 10,
    baseCoolDownTurns: Settings.time.turnsPerSecond * 60,
    activationSecondsPerUpgrade: 3,
    coolDownSecondsPerUpgrade: 5,
    activationTurnsPerUpgrade: Settings.time.turnsPerSecond * 3,
    coolDownTurnsPerUpgrade: Settings.time.turnsPerSecond * 5
  };
  Settings.automation = {
    minDelayTurns: Settings.time.turnsPerSecond * 2,
    baseUpgradeDelayTurns: Settings.time.turnsPerSecond * 61,
    // 61 seconds
    turnsPerRateUpgrade: Settings.time.turnsPerSecond * 5,
    // 5 seconds per upgrade
    prestigeUpgradeDelayTurns: Settings.time.turnsPerSecond * (60 * 61),
    // 61 minutes
    prestigeTurnsPerRateUpgrade: Settings.time.turnsPerSecond * (60 * 5),
    // 5 minutes
    prestigeMinTurnsSinceLastChange: Settings.time.turnsPerSecond * (60 * 5),
    // 5 minutes
    secondsPerRateUpgrade: 5,
    minutesPerPrestigeRateUpgrade: 5
  };
  Settings.offline = {
    defaultOfflineMinutes: 30,
    defaultOfflineTurns: 30 * 60 * Settings.time.turnsPerSecond,
    minutesPerUpgrade: 30,
    turnsPerUpgrade: 30 * (60 * Settings.time.turnsPerSecond)
  };

  // src/model/sprite/Sprite.js
  var Sprite = class {
    /**
     * @param {number} spriteX 
     * @param {number} spriteY 
     */
    constructor(spriteX, spriteY) {
      this.spriteX = spriteX;
      this.spriteY = spriteY;
    }
    /**
     * @abstract
     * @returns {Image}
     */
    getImage() {
    }
    /**
     * @abstract
     * @returns {number}
     */
    getSize() {
      return Settings.tile.size;
    }
  };

  // src/model/cache/CachedInstance.js
  var CachedInstance = class {
    constructor() {
      this.finishedAndAvailable = true;
      this.listener = null;
    }
    /**
     * @returns {boolean}
     */
    isFinishedAndAvailable() {
      return this.finishedAndAvailable;
    }
    /**
     * @param {boolean} finishedAndAvailable 
     */
    reset(finishedAndAvailable) {
      if (this.finishedAndAvailable != finishedAndAvailable && this.listener) {
        this.listener.onAvailabilityChanged(finishedAndAvailable);
      }
      this.finishedAndAvailable = finishedAndAvailable;
    }
    /**
     * @param {CyclingCacheListener} listener 
     */
    setCycleCacheListener(listener) {
      this.listener = listener;
    }
  };

  // src/model/character/CharacterAction.js
  var CharacterAction = {
    /**
     * @constant
     * @type {string}
     */
    STAND: "STAND",
    /**
     * @constant
     * @type {string}
     */
    WALK: "WALK",
    /**
     * @constant
     * @type {string}
     */
    JUMP: "JUMP",
    /**
     * @constant
     * @type {string}
     */
    FALL: "FALL",
    /**
     * @constant
     * @type {string}
     */
    MINE: "MINE"
  };

  // src/model/math/Vector.js
  var Vector = class _Vector {
    /**
     * 
     * @param {number} x 
     * @param {number} y 
     */
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
    /**
     * @param {number} x
     * @param {number} y
     */
    set(x, y) {
      this.x = x;
      this.y = y;
    }
    /**
     * @param {Vector} vector
     */
    copy(vector) {
      this.x = vector.x;
      this.y = vector.y;
    }
    /**
     * @this {Vector}
     * @returns {Vector}
     */
    clone() {
      return new _Vector(this.x, this.y);
    }
    /**
     * @this {Vector}
     * @param {Vector} vector
     */
    add(vector) {
      this.x += vector.x;
      this.y += vector.y;
    }
    /**
     * @this {Vector}
     * @param {number} x
     * @param {number} y
     */
    addXY(x, y) {
      this.x += x;
      this.y += y;
    }
    /**
     * @this {Vector}
     * @param {Vector} vector
     */
    subtract(vector) {
      this.x -= vector.x;
      this.y -= vector.y;
    }
    /**
     * @param {number} x
     * @param {number} y
     */
    subtractXY(x, y) {
      this.x -= x;
      this.y -= y;
    }
    // /**
    //  * @param {Vector} vector
    //  */
    // multiply(vector) {
    //     this.x *= vector.x;
    //     this.y *= vector.y;
    // }
    // /**
    //  * @param {number} x
    //  * @param {number} y
    //  */
    // multiplyXY(x, y) {
    //     this.x *= x;
    //     this.y *= y;
    // };
    // /**
    //  * @param {Vector} vector
    //  */
    // divide(vector) {
    //     this.x /= vector.x;
    //     this.y /= vector.y;
    // }
    // /**
    //  * @param {number} x
    //  * @param {number} y
    //  */
    // divideXY(x, y) {
    //     this.x /= x;
    //     this.y /= y;
    // }
    /**
     * @param {number} scalar
     */
    scale(scalar) {
      this.x *= scalar;
      this.y *= scalar;
    }
    /**
     * @param {Vector} vector
     * @returns {number}
     */
    distance(vector) {
      const dx = vector.x - this.x;
      const dy = vector.y - this.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
    /**
     * @this {Vector}
     * @param {Vector} vector
     * @returns {number}
     */
    distanceSquared(vector) {
      const dx = vector.x - this.x;
      const dy = vector.y - this.y;
      return dx * dx + dy * dy;
    }
    /**
     * @returns {number}
     */
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    /**
     * @returns {number}
     */
    lengthSquared() {
      return this.x * this.x + this.y * this.y;
    }
    /**
     * @param {Vector} vector 
     * @returns {boolean}
     */
    equals(vector) {
      return vector && this.x === vector.x && this.y === vector.y;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "(" + this.x + ", " + this.y + ")";
    }
    /**
     * @returns {number}
     */
    hash() {
      let hash = 23;
      hash = hash * 31 + this.x;
      hash = hash * 31 + this.y;
      return hash;
    }
    // /**
    //  * @returns {number}
    //  */
    // hash() {
    //     // const temp = this.y + ((this.x + 1) / 2);
    //     // return (this.x + (temp * temp)) | 0;
    // }
    // public int hashCode()
    // {
    //       int tmp = ( y +  ((x+1)/2));
    //                return x +  ( tmp * tmp);
    // }    
  };

  // src/model/grid/GridBox.js
  var GridBox = class {
    /**
     * @param {Vector} origin 
     */
    constructor(origin) {
      this.origin = origin;
    }
    // The origin is the top left corner of the box.
    // The y-coordinate increases as we go downwards.
    /**
     * @returns {Vector}
     */
    getOrigin() {
      return this.origin;
    }
    /**
     * @returns {number}
     */
    getPixelWidth() {
      return 0;
    }
    /**
     * @returns {number}
     */
    getPixelHeight() {
      return 0;
    }
    /**
     * @returns {number}
     */
    getOriginTileCol() {
      const col = this.origin.x / Settings.tile.size;
      return col;
    }
    /**
     * @returns {number}
     */
    getOriginTileRow() {
      return this.origin.y / Settings.tile.size;
    }
    // getTileWidth() {
    //     return this.getPixelWidth() / Settings.tile.size;
    // }
    // getTileHeight() {
    //     return this.getPixelHeight() / Settings.tile.size;
    // }
    /**
     * @param {Vector} vector 
     * @returns {boolean}
     */
    contains(vector) {
      return vector.x >= this.origin.x && vector.x < this.origin.x + this.getPixelWidth() && (vector.y >= this.origin.y && vector.y < this.origin.y + this.getPixelHeight());
    }
    /**
     * @param {number} x 
     * @param {number} y 
     * @returns {boolean}
     */
    containsXY(x, y) {
      return x >= this.origin.x && x < this.origin.x + this.getPixelWidth() && (y >= this.origin.y && y < this.origin.y + this.getPixelHeight());
    }
    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} halfWidth in pixels
     * @returns {boolean}
     */
    intersects(x, y, halfWidth) {
      if (x + halfWidth < this.origin.x) {
        return false;
      }
      if (x - halfWidth > this.origin.x + this.getPixelWidth()) {
        return false;
      }
      if (y + halfWidth < this.origin.y) {
        return false;
      }
      if (y - halfWidth > this.origin.y + this.getPixelHeight()) {
        return false;
      }
      return true;
    }
  };

  // src/model/math/ManExp.js
  var ManExp = class {
    /**
     * @param {number} mantissa
     * @param {number} exponent
     */
    constructor(mantissa, exponent) {
      this.m = mantissa;
      this.e = exponent;
    }
    /**
     * @param {number} mantissa
     * @param {number} exponent
     * @returns {ManExp}
     */
    set(mantissa, exponent) {
      this.m = mantissa;
      this.e = exponent;
      return this;
    }
    /**
     * Sets the value to 0.
     * @returns {ManExp}
     */
    setZero() {
      this.m = 0;
      this.e = 0;
      return this;
    }
    /**
     * @param {ManExp} source 
     * @returns {ManExp}
     */
    copy(source) {
      if (typeof source === "number") {
        console.log("ManExp.copy() passed number instead of ManExp");
        console.trace();
      }
      this.m = source.m;
      this.e = source.e;
      return this;
    }
    /**
     * @param {ManExp} value 
     * @returns {boolean}
     */
    lessThan(value2) {
      if (typeof value2 === "number") {
        console.log("ManExp.lessThan() passed number instead of ManExp");
        console.trace();
      }
      if (this.m === 0) {
        return value2.m > 0;
      }
      if (value2.m === 0) {
        return this.m <= 0;
      }
      if (this.e === value2.e) {
        return this.m < value2.m;
      }
      if (this.m > 0) {
        return value2.m > 0 && this.e < value2.e;
      }
      return value2.m > 0 || this.e > value2.e;
    }
    /**
     * @param {ManExp} value 
     * @returns {boolean}
     */
    lessThanEquals(value2) {
      return !this.greaterThan(value2);
    }
    /**
     * @param {ManExp} value 
     * @returns {boolean}
     */
    greaterThan(value2) {
      if (typeof value2 === "number") {
        console.log("ManExp.greaterThan() passed number instead of ManExp");
        console.trace();
      }
      if (this.m === 0) {
        return value2.m < 0;
      }
      if (value2.m === 0) {
        return this.m > 0;
      }
      if (this.e === value2.e) {
        return this.m > value2.m;
      }
      if (this.m > 0) {
        return value2.m < 0 || this.e > value2.e;
      }
      return value2.m < 0 && this.e < value2.e;
    }
    /**
     * @param {ManExp} value 
     * @returns {boolean}
     */
    greaterThanEquals(value2) {
      return !this.lessThan(value2);
    }
    /**
     * @param {ManExp} value 
     * @returns {number} -1, 0, 1
     */
    compare(value2) {
      if (typeof value2 === "number") {
        console.log("ManExp.compare() passed number instead of ManExp");
        console.trace();
      }
      if (this.m === 0) {
        if (value2.m === 0) {
          return 0;
        }
        if (value2.m < 0) {
          return 1;
        }
        if (value2.m > 0) {
          return -1;
        }
      }
      if (value2.m === 0) {
        if (this.m < 0) {
          return -1;
        }
        if (this.m > 0) {
          return 1;
        }
      }
      if (this.m > 0) {
        if (value2.m < 0) {
          return 1;
        }
        if (this.e > value2.e) {
          return 1;
        }
        if (this.e < value2.e) {
          return -1;
        }
        if (this.m > value2.m) {
          return 1;
        }
        if (this.m < value2.m) {
          return -1;
        }
        return 0;
      }
      if (this.m < 0) {
        if (value2.m > 0) {
          return -1;
        }
        if (this.e > value2.e) {
          return -1;
        }
        if (this.e < value2.e) {
          return 1;
        }
        if (this.m > value2.m) {
          return 1;
        }
        if (this.m < value2.m) {
          return -1;
        }
        return 0;
      }
    }
    /**
     * @param {ManExp} value 
     * @returns {boolean}
     */
    equals(value2) {
      return this.e === value2.e && this.m === value2.m;
    }
    /**
     * @returns {boolean}
     */
    equalsZero() {
      return this.e === 0 && this.m === 0;
    }
  };

  // src/model/math/BigNumMath.js
  var MAX_SIGNIFICANT_DIGITS = 17;
  var EXP_LIMIT = 9e15;
  var NUMBER_EXP_MAX = 308;
  var NUMBER_EXP_MIN = -324;
  var ROUND_TOLERANCE = 1e-10;
  var POWERS_OF_10 = [];
  for (let i = NUMBER_EXP_MIN + 1; i <= NUMBER_EXP_MAX; i++) {
    POWERS_OF_10.push(Number("1e" + i));
  }
  var BigNumMath = class _BigNumMath {
    constructor() {
    }
    /**
     * @param {number} power 
     * @returns {number}
     */
    static powerOf10(power) {
      const indexOf0InPowersOf10 = 323;
      return POWERS_OF_10[power + indexOf0InPowersOf10];
    }
    /**
     * @param {ManExp} out
     * @param {number} value 
     */
    static fromNumber(out, value2) {
      if (isNaN(value2)) {
        out.m = Number.NaN;
        out.e = Number.NaN;
      } else if (value2 === Number.POSITIVE_INFINITY) {
        out.m = 1;
        out.e = EXP_LIMIT;
      } else if (value2 === Number.NEGATIVE_INFINITY) {
        out.m = -1;
        out.e = EXP_LIMIT;
      } else if (value2 === 0) {
        out.m = 0;
        out.e = 0;
      } else {
        out.e = Math.floor(Math.log10(Math.abs(value2)));
        out.m = out.e === NUMBER_EXP_MIN ? value2 * 10 / 1e-323 : value2 / _BigNumMath.powerOf10(out.e);
        _BigNumMath.normalize(out);
      }
      return out;
    }
    /**
     * @param {ManExp} out 
     * @returns {ManExp}
     */
    static negate(out) {
      if (typeof value === "number") {
        console.log("BigNumMath.negate() passed number instead of BigNum");
        console.trace();
      }
      out.m = -out.m;
      return out;
    }
    /**
     * @param {ManExp} out 
     * @param {ManExp} value
     * @returns {ManExp}
     */
    static copy(out, value2) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.copy() passed number instead of BigNum");
        console.trace();
      }
      out.m = value2.m;
      out.e = value2.e;
      return out;
    }
    /**
     * @param {ManExp} out
     * @returns {ManExp}
     */
    static normalize(out) {
      if (out.m >= 1 && out.m < 10) {
        return out;
      }
      if (out.m === 0) {
        out.m = 0;
        out.e = 0;
        return out;
      }
      const tempExponent = Math.floor(Math.log10(Math.abs(out.m)));
      out.m = tempExponent === NUMBER_EXP_MIN ? out.m * 10 / 1e-323 : out.m / _BigNumMath.powerOf10(tempExponent);
      out.e += tempExponent;
      return out;
    }
    ///////////////////////////////////////////
    // Arithmetic
    ///////////////////////////////////////////
    /**
     * @param {ManExp} out 
     * @param {ManExp} value 
     * @returns {ManExp}
     */
    static multiply(out, value2) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.multiply() passed number instead of BigNum");
        console.trace();
      }
      out.m *= value2.m;
      out.e += value2.e;
      return _BigNumMath.normalize(out);
    }
    /**
     * @param {ManExp} out 
     * @param {ManExp} value 
     * @returns {ManExp}
     */
    static add(out, value2) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.add() passed number instead of BigNum");
        console.trace();
      }
      if (out.m === 0) {
        out.m = value2.m;
        out.e = value2.e;
        return out;
      }
      if (value2.m === 0) {
        return out;
      }
      let biggerM;
      let biggerE;
      let smallerM;
      let smallerE;
      if (out.e >= value2.e) {
        biggerM = out.m;
        biggerE = out.e;
        smallerM = value2.m;
        smallerE = value2.e;
      } else {
        biggerM = value2.m;
        biggerE = value2.e;
        smallerM = out.m;
        smallerE = out.e;
      }
      if (biggerE - smallerE > MAX_SIGNIFICANT_DIGITS) {
        out.m = biggerM;
        out.e = biggerE;
        return out;
      }
      const mantissa = Math.round(1e14 * biggerM + 1e14 * smallerM * _BigNumMath.powerOf10(smallerE - biggerE));
      out.m = mantissa;
      out.e = biggerE - 14;
      return _BigNumMath.normalize(out);
    }
    ///////////////////////////////////////////
    // pow and log
    ///////////////////////////////////////////
    /**
     * @param {ManExp} value 
     * @returns {number}
     */
    static log10(value2) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.log10() passed number instead of BigNum");
        console.trace();
      }
      return value2.e + Math.log10(value2.m);
    }
    /**
     * @param {ManExp} value 
     * @returns {number}
     */
    static log2(value2) {
      return 3.321928094887362 * _BigNumMath.log10(value2);
    }
    /**
     * @param {ManExp} value 
     * @returns {number}
     */
    static ln(value2) {
      return 2.302585092994045 * _BigNumMath.log10(value2);
    }
    /**
     * @param {ManExp} value 
     * @param {number} base 
     * @returns {number}
     */
    static log(value2, base) {
      return Math.LN10 / Math.log(base) * _BigNumMath.log10(value2);
    }
    /**
     * @param {ManExp} out
     * @param {number} value 
     * @returns {ManExp}
     */
    static pow10(out, value2) {
      if (Number.isInteger(value2)) {
        out.set(1, value2);
        return out;
      }
      out.set(Math.pow(10, value2 % 1), Math.trunc(value2));
      return _BigNumMath.normalize(out);
    }
    /**
     * @param {ManExp} out
     * @param {number} value 
     * @returns {ManExp}
     */
    static pow(out, value2) {
      const numberValue = value2;
      const temp = out.e * numberValue;
      let newMantissa;
      if (Number.isSafeInteger(temp)) {
        newMantissa = Math.pow(out.m, numberValue);
        if (isFinite(newMantissa) && newMantissa !== 0) {
          out.m = newMantissa;
          out.e = temp;
          return _BigNumMath.normalize(out);
        }
      }
      const newExponent = Math.trunc(temp);
      const residue = temp - newExponent;
      newMantissa = Math.pow(10, numberValue * Math.log10(out.m) + residue);
      if (isFinite(newMantissa) && newMantissa !== 0) {
        out.m = newMantissa;
        out.e = newExponent;
        return _BigNumMath.normalize(out);
      }
      _BigNumMath.pow10(out, numberValue * _BigNumMath.absLog10(out));
      if (_BigNumMath.sign(out) === -1) {
        if (Math.abs(numberValue % 2) === 1) {
          return _BigNumMath.negate(out);
        } else if (Math.abs(numberValue % 2) === 0) {
          return out;
        }
        out.m = Number.NaN;
        out.e = Number.NaN;
        return out;
      }
      return out;
    }
    ///////////////////////////////////////////
    // Conversions
    ///////////////////////////////////////////
    /**
     * @param {ManExp} value
     * @returns {string}
     */
    static toString(value2) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.toString() passed number instead of BigNum");
        console.trace();
      }
      if (isNaN(value2.m) || isNaN(value2.e)) {
        return "NaN";
      }
      if (value2.e >= EXP_LIMIT) {
        return value2.m > 0 ? "Infinity" : "-Infinity";
      }
      if (value2.e <= -EXP_LIMIT || value2.m === 0) {
        return "0";
      }
      if (value2.e < 21 && value2.e > -7) {
        return _BigNumMath.toNumber(value2).toString();
      }
      return value2.m + "e" + (value2.e >= 0 ? "+" : "") + value2.e;
    }
    /**
     * @param {ManExp} value
     * @returns {number}
     */
    static toNumber(value2) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.toNumber() passed number instead of BigNum");
        console.trace();
      }
      if (!isFinite(value2.e)) {
        return Number.NaN;
      }
      if (value2.e > NUMBER_EXP_MAX) {
        return value2.m > 0 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      }
      if (value2.e < NUMBER_EXP_MIN) {
        return 0;
      }
      if (value2.e === NUMBER_EXP_MIN) {
        return value2.m > 0 ? 5e-324 : -5e-324;
      }
      const result = value2.m * _BigNumMath.powerOf10(value2.e);
      if (!isFinite(result) || value2.e < 0) {
        return result;
      }
      const resultRounded = Math.round(result);
      if (Math.abs(resultRounded - result) < ROUND_TOLERANCE) {
        return resultRounded;
      }
      return result;
    }
    /**
     * @param {ManExp} value
     * @param {number} places 
     * @returns {string}
     */
    static toExponential(value2, places) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.toExponential() passed number instead of BigNum");
        console.trace();
      }
      if (isNaN(value2.m) || isNaN(value2.e)) {
        return "NaN";
      }
      if (value2.e >= EXP_LIMIT) {
        return value2.m > 0 ? "Infinity" : "-Infinity";
      }
      if (value2.e <= -EXP_LIMIT || value2.m === 0) {
        return "0" + (places > 0 ? _BigNumMath.padEnd(".", places + 1, "0") : "") + "e+0";
      }
      if (value2.e > NUMBER_EXP_MIN && value2.e < NUMBER_EXP_MAX) {
        return _BigNumMath.toNumber(value2).toExponential(places);
      }
      if (!isFinite(places)) {
        places = MAX_SIGNIFICANT_DIGITS;
      }
      const len = places + 1;
      const numDigits = Math.max(1, Math.ceil(Math.log10(Math.abs(value2.m))));
      const rounded = Math.round(value2.m * Math.pow(10, len - numDigits)) * Math.pow(10, numDigits - len);
      return rounded.toFixed(Math.max(len - numDigits, 0)) + "e" + (value2.e >= 0 ? "+" : "") + value2.e;
    }
    /**
     * @param {ManExp} value
     * @param {number} places 
     * @returns {string}
     */
    static toFixed(value2, places) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.toFixed() passed number instead of BigNum");
        console.trace();
      }
      if (isNaN(value2.m) || isNaN(value2.e)) {
        return "NaN";
      }
      if (value2.e >= EXP_LIMIT) {
        return value2.m > 0 ? "Infinity" : "-Infinity";
      }
      if (value2.e <= -EXP_LIMIT || value2.m === 0) {
        return "0" + (places > 0 ? _BigNumMath.padEnd(".", places + 1, "0") : "");
      }
      if (value2.e >= MAX_SIGNIFICANT_DIGITS) {
        return value2.m.toString().replace(".", "").padEnd(value2.e + 1, "0") + (places > 0 ? _BigNumMath.padEnd(".", places + 1, "0") : "");
      }
      return _BigNumMath.toNumber(value2).toFixed(places);
    }
    /**
     * @param {ManExp} value
     * @param {number} places 
     * @returns {string}
     */
    static toPrecision(value2, places) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.toPrecision() passed number instead of BigNum");
        console.trace();
      }
      if (value2.e <= -7) {
        return _BigNumMath.toExponential(value2, places - 1);
      }
      if (places > value2.e) {
        return _BigNumMath.toFixed(value2, places - value2.e - 1);
      }
      return _BigNumMath.toExponential(value2, places - 1);
    }
    /**
     * @param {ManExp} value 
     * @returns {string}
     */
    static valueOf(value2) {
      return _BigNumMath.toString(value2);
    }
    /**
     * @param {ManExp} value 
     * @returns {string}
     */
    static toJSON(value2) {
      return _BigNumMath.toString(value2);
    }
    /**
     * @param {ManExp} value 
     * @returns {string}
     */
    static toStringWithDecimalPlaces(value2, places) {
      return _BigNumMath.toExponential(value2, places);
    }
    //   Decimal.prototype.abs = function () {
    //     return ME_NN(Math.abs(this.m), this.e);
    //   };
    /**
     * @param {BigNum} out 
     * @returns {BigNum}
     */
    static abs(out) {
      if (typeof value === "number") {
        console.log("BigNumMath.abs() passed number instead of BigNum");
        console.trace();
      }
      out.m = Math.abs(out.m);
      return out;
    }
    /**
     * @param {ManExp} value 
     * @returns {number}
     */
    static sign(value2) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.sign() passed number instead of BigNum");
        console.trace();
      }
      return Math.sign(value2.m);
    }
    ///////////////////////////////////////////
    // Round/Floor/Ceil/Trunc
    ///////////////////////////////////////////    
    /**
     * @param {ManExp} out 
     * @returns {ManExp}
     */
    static round(out) {
      if (out.e < -1) {
        return out.setZero();
      }
      if (out.e < MAX_SIGNIFICANT_DIGITS) {
        return _BigNumMath.fromNumber(out, Math.round(_BigNumMath.toNumber(out)));
      }
      return out;
    }
    /**
     * @param {ManExp} out 
     * @returns {ManExp}
     */
    static floor(out) {
      if (out.e < -1) {
        if (Math.sign(out.m) >= 0) {
          return out.setZero();
        } else {
          return _BigNumMath.fromNumber(out, -1);
        }
      }
      if (out.e < MAX_SIGNIFICANT_DIGITS) {
        return _BigNumMath.fromNumber(out, Math.floor(_BigNumMath.toNumber(out)));
      }
      return out;
    }
    /**
     * @param {ManExp} out 
     * @returns {ManExp}
     */
    static ceil(out) {
      if (out.e < -1) {
        if (Math.sign(out.m) > 0) {
          return _BigNumMath.fromNumber(out, 1);
        } else {
          return out.setZero();
        }
      }
      if (out.e < MAX_SIGNIFICANT_DIGITS) {
        return _BigNumMath.fromNumber(out, Math.ceil(_BigNumMath.toNumber(out)));
      }
      return out;
    }
    /**
     * @param {ManExp} out 
     * @returns {ManExp}
     */
    static trunc(out) {
      if (out.e < 0) {
        return out.setZero();
      }
      if (out.e < MAX_SIGNIFICANT_DIGITS) {
        return _BigNumMath.fromNumber(out, Math.trunc(_BigNumMath.toNumber(out)));
      }
      return out;
    }
    ///////////////////////////////////////////
    // Comparisons
    ///////////////////////////////////////////
    /**
     * @param {ManExp} out
     * @returns {ManExp}
     */
    static recip(out) {
      out.m = 1 / out.m;
      out.e = -out.e;
      return _BigNumMath.normalize(out);
    }
    /**
     * @param {ManExp} value
     * @returns {number}
     */
    static absLog10(value2) {
      return value2.e + Math.log10(Math.abs(value2.m));
    }
    /**
     * @private
     * @param {string} string 
     * @param {number} maxLength 
     * @param {string} fillString 
     * @returns {string}
     */
    static padEnd(string, maxLength, fillString) {
      if (string == null || maxLength == null) {
        return string;
      }
      const result = String(string);
      const targetLen = typeof maxLength === "number" ? maxLength : parseInt(maxLength, 10);
      if (isNaN(targetLen) || !isFinite(targetLen)) {
        return result;
      }
      const length = result.length;
      if (length >= targetLen) {
        return result;
      }
      let filled = fillString == null ? "" : String(fillString);
      if (filled === "") {
        filled = " ";
      }
      const fillLen = targetLen - length;
      while (filled.length < fillLen) {
        filled += filled;
      }
      const truncated = filled.length > fillLen ? filled.substr(0, fillLen) : filled;
      return result + truncated;
    }
  };

  // src/model/math/BigNum.js
  var WORKING = new ManExp(0, 0);
  var BigNum = class _BigNum extends ManExp {
    /**
     * @param {number} value 
     */
    constructor(value2) {
      super(0, 0);
      this.setValue(value2);
    }
    /**
     * @param {number} value 
     * @returns {BigNum}
     */
    setValue(value2) {
      BigNumMath.fromNumber(this, value2);
      return this;
    }
    ///////////////////////////////////////////
    // Multiplication
    ///////////////////////////////////////////
    /**
     * @param {number} value 
     * @returns {BigNum}
     */
    multiplyNumber(value2) {
      if (value2 instanceof _BigNum) {
        console.log("BigNum.multiplyNumber() passed BigNum instead of number");
        console.trace();
      }
      BigNumMath.fromNumber(WORKING, value2);
      return BigNumMath.multiply(this, WORKING);
    }
    /**
     * @param {number} value 
     * @returns {BigNum}
     */
    mulNumber(value2) {
      return this.multiplyNumber(value2);
    }
    /**
     * @param {BigNum} value 
     * @returns {BigNum}
     */
    multiply(value2) {
      return BigNumMath.multiply(this, value2);
    }
    /**
     * @param {BigNum} value 
     * @returns {BigNum}
     */
    mul(value2) {
      return this.multiply(value2);
    }
    ///////////////////////////////////////////
    // Addition
    ///////////////////////////////////////////
    /**
     * @param {number} value 
     * @returns {BigNum}
     */
    addNumber(value2) {
      if (value2 instanceof _BigNum) {
        console.log("BigNum.addNumber() passed BigNum instead of number");
        console.trace();
      }
      BigNumMath.fromNumber(WORKING, value2);
      return BigNumMath.add(this, WORKING);
    }
    /**
     * @param {BigNum} value 
     * @returns {BigNum}
     */
    add(value2) {
      return BigNumMath.add(this, value2);
    }
    ///////////////////////////////////////////
    // Subtraction
    ///////////////////////////////////////////
    /**
     * @param {number} value 
     * @returns {BigNum}
     */
    subNumber(value2) {
      if (value2 instanceof _BigNum) {
        console.log("BigNum.subNumber() passed BigNum instead of number");
        console.trace();
      }
      BigNumMath.fromNumber(WORKING, -value2);
      return BigNumMath.add(this, WORKING);
    }
    /**
     * @param {number} value 
     * @returns {BigNum}
     */
    subtractNumber(value2) {
      return this.subNumber(value2);
    }
    /**
     * @param {BigNum} value 
     * @returns {BigNum}
     */
    sub(value2) {
      BigNumMath.copy(WORKING, value2);
      BigNumMath.negate(WORKING);
      return BigNumMath.add(this, WORKING);
    }
    /**
     * @param {BigNum} value 
     * @returns {BigNum}
     */
    subtract(value2) {
      return this.sub(value2);
    }
    ///////////////////////////////////////////
    // Division
    ///////////////////////////////////////////
    /**
     * Updates the number to its reciprocal.
     */
    recip() {
      return BigNumMath.recip(this);
    }
    /**
     * @param {number} value 
     * @returns {BigNum}
     */
    divideNumber(value2) {
      if (value2 instanceof _BigNum) {
        console.log("BigNum.divideNumber() passed BigNum instead of number");
        console.trace();
      }
      BigNumMath.fromNumber(WORKING, value2);
      BigNumMath.recip(WORKING);
      return BigNumMath.multiply(this, WORKING);
    }
    /**
     * @param {number} value 
     * @returns {BigNum}
     */
    divNumber(value2) {
      return this.divideNumber(value2);
    }
    /**
     * @param {BigNum} value 
     * @returns {BigNum}
     */
    divide(value2) {
      BigNumMath.copy(WORKING, value2);
      BigNumMath.recip(WORKING);
      return BigNumMath.multiply(this, WORKING);
    }
    /**
     * @param {BigNum} value 
     * @returns {BigNum}
     */
    div(value2) {
      return this.divide(value2);
    }
    ///////////////////////////////////////////
    // Round/Floor/Ceil/Trunc
    ///////////////////////////////////////////    
    /**
     * @returns {BigNum}
     */
    round() {
      return BigNumMath.round(this);
    }
    /**
     * @returns {BigNum}
     */
    floor() {
      return BigNumMath.floor(this);
    }
    /**
     * @returns {BigNum}
     */
    ceil() {
      return BigNumMath.ceil(this);
    }
    /**
     * @returns {BigNum}
     */
    trunc() {
      return BigNumMath.trunc(this);
    }
    /**
     * @returns {BigNum}
     */
    abs() {
      return BigNumMath.abs(this);
    }
    ///////////////////////////////////////////
    // pow and log
    ///////////////////////////////////////////
    /**
     * @returns {number}
     */
    log10() {
      return BigNumMath.log10(this);
    }
    /**
     * @returns {number}
     */
    log2() {
      return BigNumMath.log2(this);
    }
    /**
     * @returns {number}
     */
    ln() {
      return BigNumMath.ln(this);
    }
    /**
     * @param {number} base 
     * @returns {number}
     */
    log(base) {
      return BigNumMath.log(this, base);
    }
    /**
     * @param {number} value 
     * @returns {BigNum}
     */
    pow(value2) {
      return BigNumMath.pow(this, value2);
    }
    ///////////////////////////////////////////
    // Conversions
    ///////////////////////////////////////////
    /**
     * @returns {string}
     */
    toString() {
      return BigNumMath.toString(this);
    }
    /**
     * @returns {string}
     */
    toDebugString() {
      return this.toString() + ", (m=" + this.m + ", e=" + this.e + ")";
    }
    /**
     * @returns {number}
     */
    toNumber() {
      return BigNumMath.toNumber(this);
    }
    /**
     * @param {number} places
     * @returns {string}
     */
    toExponential(places) {
      return BigNumMath.toExponential(this, places);
    }
    /**
     * @param {number} places
     * @returns {string}
     */
    toFixed(places) {
      return BigNumMath.toFixed(this, places);
    }
    /**
     * @param {number} places
     * @returns {string}
     */
    toPrecision(places) {
      return BigNumMath.toPrecision(this, places);
    }
    /**
     * @returns {string}
     */
    valueOf() {
      return BigNumMath.valueOf(this);
    }
    /**
     * @returns {string}
     */
    toJSON() {
      return BigNumMath.toJSON(this);
    }
    /**
     * @param {number} places
     * @returns {string}
     */
    toStringWithDecimalPlaces(places) {
      return BigNumMath.toStringWithDecimalPlaces(this, places);
    }
    /**
     * @returns {number}
     */
    sign() {
      return BigNumMath.sign(this);
    }
    ///////////////////////////////////////////
    // Comparisons
    ///////////////////////////////////////////
    /**
     * @param {number} value 
     * @returns {boolean}
     */
    equalsNumber(value2) {
      if (value2 instanceof _BigNum) {
        console.log("BigNum.equalsNumber() passed BigNum instead of number");
        console.trace();
      }
      BigNumMath.fromNumber(WORKING, value2);
      return this.equals(WORKING);
    }
    /**
     * @param {number} value 
     * @returns {boolean}
     */
    lessThanNumber(value2) {
      if (value2 instanceof _BigNum) {
        console.log("BigNum.lessThanNumber() passed BigNum instead of number");
        console.trace();
      }
      BigNumMath.fromNumber(WORKING, value2);
      return this.lessThan(WORKING);
    }
    /**
     * @returns {boolean}
     */
    lessThanZero() {
      WORKING.setZero();
      return this.lessThan(WORKING);
    }
    /**
     * @returns {boolean}
     */
    lessThanEqualsZero() {
      WORKING.setZero();
      return !this.greaterThan(WORKING);
    }
    /**
     * @param {number} value 
     * @returns {boolean}
     */
    lessThanEqualsNumber(value2) {
      if (value2 instanceof _BigNum) {
        console.log("BigNum.lessThanEqualsNumber() passed BigNum instead of number");
        console.trace();
      }
      BigNumMath.fromNumber(WORKING, value2);
      return this.lessThanEquals(WORKING);
    }
    /**
     * @param {number} value 
     * @returns {boolean}
     */
    greaterThanNumber(value2) {
      if (value2 instanceof _BigNum) {
        console.log("BigNum.greaterThanNumber() passed BigNum instead of number");
        console.trace();
      }
      BigNumMath.fromNumber(WORKING, value2);
      return this.greaterThan(WORKING);
    }
    /**
     * @param {number} value 
     * @returns {boolean}
     */
    greaterThanEqualsNumber(value2) {
      if (value2 instanceof _BigNum) {
        console.log("BigNum.greaterThanEqualsNumber() passed BigNum instead of number");
        console.trace();
      }
      BigNumMath.fromNumber(WORKING, value2);
      return !this.lessThan(WORKING);
    }
    /**
     * @returns {boolean}
     */
    equalsZero() {
      WORKING.setZero();
      return this.equals(WORKING);
    }
    /**
     * @returns {boolean}
     */
    greaterThanZero() {
      WORKING.setZero();
      return this.greaterThan(WORKING);
    }
    /**
     * @returns {boolean}
     */
    greaterThanEqualsZero() {
      WORKING.setZero();
      return !this.lessThan(WORKING);
    }
  };

  // src/util/GameNumberFormat.js
  var GameNumberFormat = class {
    constructor() {
      this.working = new BigNum(0);
      this.hundredThousand = new BigNum(1e5);
      this.noDecimalPlacesOptions = { maximumFractionDigits: 0 };
    }
    /**
     * @param {number} number 
     */
    formatNumber(number) {
      if (number < 1e5) {
        return this.formatSmallNumber(number);
      }
      BigNumMath.fromNumber(this.working, number);
      return this.bigNumToGameString(this.working);
    }
    /**
     * @param {BigNum} bigNum
     * @returns {string}
     */
    formatBigNum(bigNum) {
      if (bigNum.lessThan(this.hundredThousand)) {
        return this.formatSmallNumber(bigNum.toNumber());
      }
      return this.bigNumToGameString(bigNum);
    }
    /**
     * @private
     * @param {number} number Must be less than 100,000.
     * @returns {string}
     */
    formatSmallNumber(number) {
      if (number < 100) {
        if (Number.isInteger(number)) {
          return number.toFixed(0);
        } else {
          return number.toFixed(2);
        }
      } else if (number < 1e3) {
        if (Number.isInteger(number)) {
          return number.toFixed(0);
        } else {
          return number.toFixed(1);
        }
      }
      return number.toLocaleString(void 0, this.noDecimalPlacesOptions);
    }
    /**
     * @private
     * @param {ManExp} value
     * @returns {string}
     */
    bigNumToGameString(value2) {
      if (typeof value2 === "number") {
        console.log("BigNumMath.toGameString() passed number instead of BigNum");
        console.trace();
      }
      if (isNaN(value2.m) || isNaN(value2.e)) {
        return "NaN";
      }
      if (value2.e < 10) {
        return value2.m.toFixed(3) + "E" + value2.e;
      } else if (value2.e < 100) {
        return value2.m.toFixed(2) + "E" + value2.e;
      } else {
        return value2.m.toFixed(1) + "E" + value2.e;
      }
    }
  };

  // src/util/NumberFormatter.js
  var gameNumberFormat = new GameNumberFormat();
  var NumberFormatter = class {
    constructor() {
    }
    /**
     * @param {BigNum} bigNum 
     * @returns {string}
     */
    static formatBigNum(bigNum) {
      if (typeof bigNum === "number") {
        console.log("NumberFormatter.formatBigNum() passed number instead of BigNum");
        console.trace();
      }
      if (!bigNum) {
        return "0";
      }
      return gameNumberFormat.formatBigNum(bigNum);
    }
    /**
     * @param {number} i 
     * @returns {string}
     */
    static formatNumber(i) {
      if (i instanceof BigNum) {
        console.log("NumberFormatter.formatNumber() passed BigNum instead of number");
        console.trace();
      }
      return gameNumberFormat.formatNumber(i);
    }
    // /**
    //  * @param {number} i 
    //  * @returns {string}
    //  */
    // static formatNumberFractionAsPercent(i) {
    //   if (i instanceof BigNum) {
    //       console.log('NumberFormatter.formatNumber() passed BigNum instead of number');
    //       console.trace();
    //   }
    //   // 1.2 = 20%
    //   // 1.9 = 90%
    //   // 2.1 = 110%
    //   const val = (i - 1) * 100;
    //   return gameNumberFormat.formatNumber(val) + '%';
    // }
  };

  // src/model/grid/TileTypeRarity.js
  var TileTypeRarity = {
    /**
     * @constant
     * @type {number}
     */
    UNSET: 0,
    /**
     * @constant
     * @type {number}
     */
    COMMON: 1,
    /**
     * @constant
     * @type {number}
     */
    ORE: 2,
    /**
     * @constant
     * @type {number}
     */
    GOLD: 3,
    /**
     * @constant
     * @type {number}
     */
    UPGRADE: 4,
    /**
     * @constant
     * @type {number}
     */
    RUBY: 5
  };

  // src/model/grid/LayerDescription.js
  var workingRowDepth = new BigNum(0);
  var LayerDescription = class {
    /**
     * @param {TileType} primaryTileType 
     * @param {number} nominalIndex The layer index presented to the player. Air and grass should be -1.
     */
    constructor(primaryTileType, nominalIndex) {
      this.primaryTileType = primaryTileType;
      this.id = primaryTileType.id;
      this.name = primaryTileType.name;
      this.nominalIndex = nominalIndex;
      this.iconFileName = primaryTileType.iconFileName;
      this.minDepth = 0;
      this.maxDepth = 0;
      this.oreStep = new BigNum(0);
      this.baseOre = new BigNum(0);
      this.healthStep = new BigNum(0);
      this.baseHealth = new BigNum(0);
      this.baseGold = null;
      this.additiveBonusFactor = 0;
      this.multiplicativeBonusFactor = 0;
      this.maxHealth = new BigNum(0);
      this.oreTileType = getOre(primaryTileType);
      this.goldTileType = getGold(primaryTileType);
      this.upgradeTileType = getUpgrade(primaryTileType);
      this.rubyTileType = getRuby(primaryTileType);
      this.prevLayer = null;
      this.nextLayer = null;
      this.monsterDescriptions = [];
      if (primaryTileType.layerDescription) {
        console.log("LayerDescription ERROR: primary tile type already has a layer desc. Tile Reuse? layer: " + this.id + " tileType=" + primaryTileType.id);
      }
      primaryTileType.layerDescription = this;
      if (this.oreTileType) {
        if (this.oreTileType.layerDescription) {
          console.log("LayerDescription ERROR: ore tile type already has a layer desc. Tile Reuse? layer: " + this.id + " tileType=" + this.oreTileType.id);
        }
        if (this.oreTileType.rarityModifier !== TileTypeRarity.ORE) {
          console.log("LayerDescription ERROR layer=" + this.name + ": ORE tile type with rarity: " + this.oreTileType.rarityModifier);
        }
        this.oreTileType.layerDescription = this;
      }
      if (this.goldTileType) {
        if (this.goldTileType.layerDescription) {
          console.log("LayerDescription ERROR: GOLD tile type already has a layer desc. Tile Reuse? layer: " + this.id + " tileType=" + this.goldTileType.id);
        }
        if (this.goldTileType.rarityModifier !== TileTypeRarity.GOLD) {
          console.log("LayerDescription ERROR layer=" + this.name + ": GOLD tile type with rarity: " + this.goldTileType.rarityModifier);
        }
        this.goldTileType.layerDescription = this;
      }
      if (this.upgradeTileType) {
        if (this.upgradeTileType.layerDescription) {
          console.log("LayerDescription ERROR: upgrade tile type already has a layer desc. Tile Reuse? " + this.id + " tileType=" + this.upgradeTileType.id);
        }
        if (this.upgradeTileType.rarityModifier !== TileTypeRarity.UPGRADE) {
          console.log("LayerDescription ERROR layer=" + this.name + ": UPGRADE tile type with rarity: " + this.upgradeTileType.rarityModifier);
        }
        this.upgradeTileType.layerDescription = this;
      }
      if (this.rubyTileType) {
        if (this.rubyTileType.layerDescription) {
          console.log("LayerDescription ERROR: RUBY tile type already has a layer desc. Tile Reuse? " + this.id + " tileType=" + this.rubyTileType.id);
        }
        if (this.rubyTileType.rarityModifier !== TileTypeRarity.RUBY) {
          console.log("LayerDescription ERROR layer=" + this.name + ": RUBY tile type with rarity: " + this.rubyTileType.rarityModifier);
        }
        this.rubyTileType.layerDescription = this;
      }
    }
    /**
     * Returns true if this layer is deeper than the specified layer.
     * @param {LayerDescription} layerDescription 
     * @returns {boolean}
     */
    isDeeperThan(layerDescription) {
      return this.minDepth > layerDescription.minDepth;
    }
    /**
     * @param {number} depth 
     * @returns {number}
     */
    getDepthPercent(depth) {
      if (depth <= this.minDepth) {
        return 0;
      }
      if (depth >= this.maxDepth) {
        return 100;
      }
      const num = depth - this.minDepth;
      const denom = this.maxDepth - this.minDepth;
      return num / denom * 100;
    }
    /**
     * @param {number} baseGold
     * @param {number} additiveBonusFactor
     * @param {number} multiplicativeBonusFactor
     * @param {BigNum} oreStep
     * @param {BigNum} healthStep How much the tile health increases per tile row
     */
    initializeLayerValues(baseGold, additiveBonusFactor, multiplicativeBonusFactor, oreStep, healthStep) {
      this.oreStep.copy(oreStep);
      this.healthStep.copy(healthStep);
      this.baseGold = new BigNum(baseGold);
      this.additiveBonusFactor = additiveBonusFactor;
      this.multiplicativeBonusFactor = multiplicativeBonusFactor;
    }
    /**
     * Invoked once to let us figure out the min/max depths.
     * @param {LayerDescription} prevLayer 
     * @param {number} layerThickness -1 means no limit to thickness
     * @param {boolean} firstRealLayer  True if this is the dirt layer
     */
    initializeLayer(prevLayer, layerThickness, firstRealLayer) {
      this.prevLayer = prevLayer;
      if (this.prevLayer) {
        this.prevLayer.nextLayer = this;
      }
      this.minDepth = prevLayer.maxDepth;
      if (layerThickness === -1) {
        this.maxDepth = this.minDepth + 1e7;
      } else {
        this.maxDepth = this.minDepth + layerThickness;
      }
      if (firstRealLayer) {
        this.baseHealth.copy(this.healthStep);
        this.baseOre.copy(this.oreStep);
      } else if (prevLayer) {
        const layers = prevLayer.maxDepth - prevLayer.minDepth;
        this.baseHealth.setValue(layers);
        this.baseHealth.mul(prevLayer.healthStep);
        this.baseHealth.add(prevLayer.baseHealth);
        this.baseHealth.add(this.healthStep);
        this.baseOre.setValue(layers);
        this.baseOre.mul(prevLayer.oreStep);
        this.baseOre.add(prevLayer.baseOre);
        this.baseOre.add(this.oreStep);
      } else {
        console.log("LayerDescription.initializeLayer() REACHED UNEXPECTED BLOCK. name=" + this.name);
        this.baseHealth.setValue(1);
        this.baseOre.setValue(1);
      }
      this.calculateTileHealth(this.maxDepth, this.maxHealth);
      console.log("Layer: " + this.name + " minDepth=" + this.minDepth + " maxDepth=" + this.maxDepth + " baseHealth=" + NumberFormatter.formatBigNum(this.baseHealth) + " maxHealth=" + NumberFormatter.formatBigNum(this.maxHealth) + " baseOre=" + NumberFormatter.formatBigNum(this.baseOre));
    }
    /**
     * @param {number} rowDepth The row depth (the tile depth, not the pixel depth)
     * @param {BigNum} oreOutput
     */
    calculateTileOre(rowDepth, oreOutput) {
      const rows = Math.max(1, rowDepth) - this.minDepth;
      if (rows <= 0) {
        oreOutput.copy(this.baseOre);
      } else {
        oreOutput.copy(this.oreStep);
        oreOutput.mulNumber(rows);
        oreOutput.add(this.baseOre);
      }
    }
    ///////////////////////////////////////////////////////////
    // const tempHealth = new BigNum(0);
    // this.tileType.layerDescription.calculateTileHealth(this.getTileRow(), tempHealth);
    // console.log('row=' + tileRow + ' ore=' + NumberFormatter.formatBigNum(oreOutput) + ' health=' + NumberFormatter.formatBigNum(tempHealth));
    /**
     * @param {number} rowDepth The row depth (the tile depth, not the pixel depth)
     * @param {BigNum} healthOutput The output param.
     */
    calculateTileHealth(rowDepth, healthOutput) {
      const rows = Math.max(1, rowDepth) - this.minDepth;
      if (rows <= 0) {
        healthOutput.copy(this.baseHealth);
      } else {
        healthOutput.copy(this.healthStep);
        healthOutput.mulNumber(rows);
        healthOutput.add(this.baseHealth);
      }
    }
    /**
     * @param {BigNum} health 
     * @returns {number}
     */
    calculateTileDepth(health) {
      if (health.lessThanEquals(this.baseHealth)) {
        return this.minDepth;
      } else if (health.greaterThanEquals(this.maxHealth)) {
        return this.maxDepth;
      }
      workingRowDepth.copy(health);
      workingRowDepth.sub(this.baseHealth);
      workingRowDepth.div(this.healthStep);
      workingRowDepth.addNumber(this.minDepth);
      return Math.max(0, workingRowDepth.toNumber() | 0);
    }
    /**
     * 
     * @param {number} rowNumber 
     * @returns {boolean}
     */
    containsRow(rowNumber) {
      return this.maxDepth <= rowNumber && this.maxDepth > rowNumber;
    }
  };

  // src/model/sprite/Spritesheet.js
  var Spritesheet = class {
    /**
     * @param {string} fileName 
     * @param {number} spriteSize 
     */
    constructor(fileName, spriteSize) {
      this.fileName = fileName;
      this.loaded = false;
      this.spriteSize = spriteSize;
      const thisRef = this;
      this.image = new Image();
      this.image.onload = function() {
        thisRef.populateSpriteMap();
      };
    }
    /**
     * Subclasses must call this.
     */
    loadImage() {
      this.image.src = this.fileName;
    }
    /**
     * This is invoked on image load.
     * Subclasses must implement this
     * @abstract
     */
    populateSpriteMap() {
    }
  };

  // src/model/sprite/SpriteAnimationManager.js
  var SpriteAnimationManager = class {
    constructor() {
      this.defaultFrameIncrement = 0;
      this.defaultElapsedFrameCount = 0;
      this.defaultAnimationFramesPerFrame = 30;
      this.defaultMillisPerFrame = 150;
      this.slowMillisPerFrame = 250;
      this.fastMillisPerFrame = 80;
      this.superFastMillisPerFrame = 30;
    }
    /**
     * 
     * @param {number} frameTimeRatio 
     */
    updateForFrame(frameTimeRatio) {
      this.defaultElapsedFrameCount += frameTimeRatio;
      if (this.defaultElapsedFrameCount >= this.defaultAnimationFramesPerFrame) {
        this.defaultFrameIncrement++;
        this.defaultElapsedFrameCount = 0;
        if (this.defaultFrameIncrement >= 5e4) {
          this.defaultFrameIncrement = 0;
        }
      }
    }
    /**
     * @param {number} animationFrameCount The number of frames in the animated sprite.
     * @returns {number} The current frame index.
     */
    getDefaultFrameIndex(animationFrameCount) {
      return this.defaultFrameIncrement % animationFrameCount | 0;
    }
    /**
     * @param {number} currentTime 
     * @param {number} startTime The start time of the animation.
     * @param {number} animationFrameCount The number of frames in the animated sprite.
     * @param {boolean} looping
     * @returns {number} The current frame index, or -1 if not looping and we have completed the animation.
     */
    getFrameIndex(currentTime, startTime, animationFrameCount, looping) {
      return this.getFrameIndexInternal(currentTime, startTime, animationFrameCount, looping, this.defaultMillisPerFrame);
    }
    /**
     * @param {number} currentTime 
     * @param {number} startTime The start time of the animation.
     * @param {number} animationFrameCount The number of frames in the animated sprite.
     * @param {boolean} looping
     * @returns {number} The current frame index, or -1 if not looping and we have completed the animation.
     */
    getFastFrameIndex(currentTime, startTime, animationFrameCount, looping) {
      return this.getFrameIndexInternal(currentTime, startTime, animationFrameCount, looping, this.fastMillisPerFrame);
    }
    /**
     * @param {number} currentTime 
     * @param {number} startTime The start time of the animation.
     * @param {number} animationFrameCount The number of frames in the animated sprite.
     * @param {boolean} looping
     * @returns {number} The current frame index, or -1 if not looping and we have completed the animation.
     */
    getSlowFrameIndex(currentTime, startTime, animationFrameCount, looping) {
      return this.getFrameIndexInternal(currentTime, startTime, animationFrameCount, looping, this.slowMillisPerFrame);
    }
    /**
     * @param {number} currentTime 
     * @param {number} startTime The start time of the animation.
     * @param {number} animationFrameCount The number of frames in the animated sprite.
     * @param {boolean} looping
     * @returns {number} The current frame index, or -1 if not looping and we have completed the animation.
     */
    getSuperFastFrameIndex(currentTime, startTime, animationFrameCount, looping) {
      return this.getFrameIndexInternal(currentTime, startTime, animationFrameCount, looping, this.superFastMillisPerFrame);
    }
    /**
     * @private
     * @param {number} currentTime 
     * @param {number} startTime The start time of the animation.
     * @param {number} animationFrameCount The number of frames in the animated sprite.
     * @param {boolean} looping
     * @param {number} millisPerFrame 
     * @returns {number} The current frame index, or -1 if not looping and we have completed the animation.
     */
    getFrameIndexInternal(currentTime, startTime, animationFrameCount, looping, millisPerFrame) {
      const frameCount = this.calculateElapsedFrameCount(currentTime, startTime, millisPerFrame);
      if (looping) {
        return frameCount % animationFrameCount | 0;
      } else if (frameCount < animationFrameCount) {
        return frameCount;
      } else {
        return -1;
      }
    }
    /**
     * @private
     * @param {number} currentTime 
     * @param {number} startTime 
     * @param {number} millisPerFrame 
     * @returns {number} The number of frames that have elapsed since the animation started.
     */
    calculateElapsedFrameCount(currentTime, startTime, millisPerFrame) {
      const elapsedMillis = Math.max(0, currentTime - startTime);
      return elapsedMillis / millisPerFrame | 0;
    }
    /**
     * @param {number} currentTime 
     * @param {number} startTime 
     * @param {number} animationFrameCount 
     * @returns {boolean}
     */
    isDefaultAnimationLoopCompleted(currentTime, startTime, animationFrameCount) {
      return this.calculateElapsedFrameCount(currentTime, startTime, this.defaultMillisPerFrame) >= animationFrameCount;
    }
    /**
     * @param {number} currentTime 
     * @param {number} startTime 
     * @param {number} animationFrameCount 
     * @returns {boolean}
     */
    isFastAnimationLoopCompleted(currentTime, startTime, animationFrameCount) {
      return this.calculateElapsedFrameCount(currentTime, startTime, this.fastMillisPerFrame) >= animationFrameCount;
    }
    /**
     * @param {number} currentTime 
     * @param {number} startTime 
     * @param {number} animationFrameCount 
     * @returns {boolean}
     */
    isSuperFastAnimationLoopCompleted(currentTime, startTime, animationFrameCount) {
      return this.calculateElapsedFrameCount(currentTime, startTime, this.superFastMillisPerFrame) >= animationFrameCount;
    }
  };

  // src/model/sprite/SpriteAnimation.js
  var SpriteAnimation = class {
    /**
     * @param {Array.<Sprite>} sprites
     * @param {SpriteAnimationManager} spriteAnimationManager
     * @param {boolean} fastAnimation
     * @param {boolean} loopingAnimation
     */
    constructor(sprites, spriteAnimationManager, fastAnimation, loopingAnimation) {
      this.sprites = sprites;
      this.spriteAnimationManager = spriteAnimationManager;
      this.fastAnimation = fastAnimation;
      this.loopingAnimation = loopingAnimation;
    }
    // /**
    //  * @returns {Sprite}
    //  */
    // getSprite() {
    //     return this.getCurrentSpriteDefault();
    // }
    /**
     * @param {number} currentTime 
     * @param {number} startTime 
     * @returns {Sprite}
     */
    getSpriteAsOf(currentTime, startTime) {
      if (this.sprites.length === 1) {
        return this.sprites[0];
      }
      if (this.fastAnimation) {
        return this.getFastCurrentSpriteAsOf(currentTime, startTime);
      } else {
        return this.getCurrentSpriteAsOf(currentTime, startTime);
      }
    }
    /**
     * @param {number} frameIndex 
     * @returns {Sprite}
     */
    getSpriteAtIndex(frameIndex) {
      if (frameIndex < 0 || frameIndex >= this.sprites.length) {
        return null;
      }
      return this.sprites[frameIndex];
    }
    /**
     * @returns {Sprite}
     */
    getCurrentSpriteDefault() {
      const frameIndex = this.spriteAnimationManager.getDefaultFrameIndex(this.sprites.length);
      return this.sprites[frameIndex];
    }
    /**
     * @param {number} currentTime
     * @param {number} startTime
     * @returns {Sprite}
     */
    getCurrentSpriteAsOf(currentTime, startTime) {
      const frameIndex = this.spriteAnimationManager.getFrameIndex(currentTime, startTime, this.sprites.length, this.loopingAnimation);
      if (frameIndex < 0) {
        return null;
      }
      return this.sprites[frameIndex];
    }
    /**
     * @param {number} currentTime
     * @param {number} startTime
     * @returns {Sprite}
     */
    getCurrentSpriteAsOfNoLooping(currentTime, startTime) {
      const frameIndex = this.spriteAnimationManager.getFrameIndex(currentTime, startTime, this.sprites.length, false);
      if (frameIndex < 0) {
        return null;
      }
      return this.sprites[frameIndex];
    }
    /**
     * @param {number} currentTime
     * @param {number} startTime
     * @returns {Sprite}
     */
    getSlowCurrentSpriteAsOfNoLooping(currentTime, startTime) {
      const frameIndex = this.spriteAnimationManager.getSlowFrameIndex(currentTime, startTime, this.sprites.length, false);
      if (frameIndex < 0) {
        return null;
      }
      return this.sprites[frameIndex];
    }
    /**
     * @param {number} currentTime
     * @param {number} startTime
     * @returns {Sprite}
     */
    getFastCurrentSpriteAsOf(currentTime, startTime) {
      const frameIndex = this.spriteAnimationManager.getFastFrameIndex(currentTime, startTime, this.sprites.length, this.loopingAnimation);
      if (frameIndex < 0) {
        return null;
      }
      return this.sprites[frameIndex];
    }
    /**
     * @param {number} currentTime
     * @param {number} startTime
     * @returns {Sprite}
     */
    getSuperFastCurrentSpriteAsOf(currentTime, startTime) {
      const frameIndex = this.spriteAnimationManager.getSuperFastFrameIndex(currentTime, startTime, this.sprites.length, this.loopingAnimation);
      if (frameIndex < 0) {
        return null;
      }
      return this.sprites[frameIndex];
    }
    /**
     * @param {number} startTime 
     * @returns {boolean}
     */
    isAnimationLoopCompleted(startTime) {
      if (this.fastAnimation) {
        return this.spriteAnimationManager.isFastAnimationLoopCompleted(Date.now(), startTime, this.sprites.length);
      } else {
        return this.spriteAnimationManager.isDefaultAnimationLoopCompleted(Date.now(), startTime, this.sprites.length);
      }
    }
    /**
     * @param {number} spriteDirection  See: SpriteDirection.js
     * @returns {Sprite}
     */
    getDirectionSprite(spriteDirection) {
      return this.sprites[spriteDirection];
    }
    /**
     * @returns {boolean}
     */
    isDirectionalSprite() {
      return false;
    }
  };

  // src/model/sprite/BasicSprite.js
  var BasicSprite = class extends Sprite {
    /**
     * @param {Spritesheet} spritesheet 
     * @param {number} spriteX 
     * @param {number} spriteY 
     */
    constructor(spritesheet, spriteX, spriteY) {
      super(spriteX, spriteY);
      this.spritesheet = spritesheet;
    }
    /**
     * @override
     * @returns {Image}
     */
    getImage() {
      return this.spritesheet.image;
    }
    /**
     * @override
     * @returns {number}
     */
    getSize() {
      return this.spritesheet.spriteSize;
    }
  };

  // src/model/sprite/AnimationRowSpritesheet.js
  var AnimationRowSpritesheet = class extends Spritesheet {
    /**
     * @param {string} fileName 
     * @param {number} spriteSize 
     */
    constructor(fileName, spriteSize) {
      super(fileName, spriteSize);
      this.step = this.calculateSpriteStep(spriteSize);
    }
    /**
     * @abstract
     * @param {number} spriteSize
     * @returns {number}
     */
    calculateSpriteStep(spriteSize) {
    }
    /**
     * @param {number} row 
     * @param {number} numSprites 
     * @returns {Array.<Sprite>}
     */
    parseRow(row, numSprites) {
      const sprites = [];
      let y = row * this.step;
      let x = 0;
      for (let col = 0; col < numSprites; col++) {
        sprites.push(new BasicSprite(this, x, y));
        x += this.step;
      }
      return sprites;
    }
  };

  // src/model/sprite/CharacterSpritesheet.js
  var CharacterSpritesheet = class extends AnimationRowSpritesheet {
    /**
     * @param {string} fileName 
     * @param {number} spriteSize 
     * @param {SpriteAnimationManager} spriteAnimationManager
     */
    constructor(fileName, spriteSize, spriteAnimationManager) {
      super(fileName, spriteSize);
      this.spriteAnimationManager = spriteAnimationManager;
      this.defaultAnimation = null;
      this.spriteAnimationMap = {};
      this.loadImage();
    }
    /**
     * @param {string} characterAction See CharacterAction.
     * @returns {SpriteAnimation}
     */
    getSpriteAnimation(characterAction) {
      const spriteAnimation = this.spriteAnimationMap[characterAction];
      return spriteAnimation ? spriteAnimation : this.defaultAnimation;
    }
    /**
     * @override
     * @param {number} spriteSize
     * @returns {number}
     */
    calculateSpriteStep(spriteSize) {
      return spriteSize + 1;
    }
    /**
     * @inheritdoc
     * @override
     */
    populateSpriteMap() {
      let row = 0;
      this.defaultAnimation = this.populateSpriteAnimation(row++, 1, false, true);
      this.spriteAnimationManager[CharacterAction.STAND] = this.defaultAnimation;
      this.spriteAnimationManager[CharacterAction.FALL] = this.defaultAnimation;
      this.spriteAnimationManager[CharacterAction.MINE] = this.defaultAnimation;
      this.spriteAnimationManager[CharacterAction.JUMP] = this.populateSpriteAnimation(row++, 1, false, true);
      this.spriteAnimationManager[CharacterAction.WALK] = this.populateSpriteAnimation(row++, 2, false, true);
      this.loaded = true;
    }
    /**
     * @private
     * @param {number} row 
     * @param {number} numSprites 
     * @param {boolean} fastAnimation
     * @param {boolean} loopingAnimation
     * @returns {SpriteAnimation}
     */
    populateSpriteAnimation(row, numSprites, fastAnimation, loopingAnimation) {
      const sprites = this.parseRow(row, numSprites);
      return new SpriteAnimation(sprites, this.spriteAnimationManager, fastAnimation, loopingAnimation);
    }
  };

  // src/model/sprite/TileSpritesheet.js
  var TileSpritesheet = class extends Spritesheet {
    /**
     * @param {string} fileName 
     * @param {number} spriteSize 
     */
    constructor(fileName, spriteSize) {
      super(fileName, spriteSize);
      this.goldRow = 0;
      this.oreRow = 1;
      this.rubyRow = 2;
      this.upgradeRow = 3;
      this.loadImage();
    }
    /**
     * @inheritdoc
     * @override
     */
    populateSpriteMap() {
      let row = 4;
      this.loadTileType(SpecialTileTypes.SKY, row);
      row++;
      this.loadTileTypePlusSpecial(SpecialTileTypes.GRASS, row);
      row++;
      this.loadTileTypePlusSpecial(SpecialTileTypes.DIRT, row);
      row++;
      for (let i = 0; i < TileTypeArray.length; i++) {
        this.loadTileTypePlusSpecial(TileTypeArray[i], row);
        row++;
      }
      this.loaded = true;
    }
    /**
     * @private
     * @param {TileType} tileType 
     * @param {number} row 
     */
    loadTileTypePlusSpecial(tileType, row) {
      this.loadTileType(tileType, row);
      this.loadTileType(getGold(tileType), this.goldRow);
      this.loadTileType(getOre(tileType), this.oreRow);
      this.loadTileType(getUpgrade(tileType), this.upgradeRow);
      this.loadTileType(getRuby(tileType), this.rubyRow);
    }
    /**
     * @private
     * @param {TileType} tileType 
     * @param {number} row 
     */
    loadTileType(tileType, row) {
      const templateWidth = (this.spriteSize + 1) * 16;
      const firstX = 0;
      const secondX = templateWidth;
      const thirdX = 2 * templateWidth;
      tileType.tileTemplate = this.parseTileTemplate(firstX, row);
      tileType.tileTemplate2 = this.parseTileTemplate(secondX, row);
      tileType.tileTemplate3 = this.parseTileTemplate(thirdX, row);
    }
    /**
     * @private
     * @param {TileType} tileType 
     * @param {number} x
     * @param {number} row 
     * @returns {TileTemplate}
     */
    parseTileTemplate(x, row) {
      const step = this.spriteSize + 1;
      const y = row * step;
      const tileTemplate = new TileTemplate();
      tileTemplate.northBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.eastBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.southBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.westBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.northEastBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.northSouthBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.northWestBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.southEastBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.eastWestBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.southWestBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.northEastSouthBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.northSouthWestBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.northEastWestBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.eastWestSouthBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.northEastSouthWestBorder = new BasicSprite(this, x, y);
      x += step;
      tileTemplate.noBorder = new BasicSprite(this, x, y);
      return tileTemplate;
    }
  };

  // src/model/grid/TileTypeBackground.js
  var TileTypeBackground = class {
    constructor() {
      this.sprites = [];
    }
  };

  // src/model/sprite/TileTypeBackgroundSpritesheet.js
  var TileTypeBackgroundSpritesheet = class extends Spritesheet {
    /**
     * @param {string} fileName 
     * @param {number} spriteSize 
     */
    constructor(fileName, spriteSize) {
      super(fileName, spriteSize);
      this.loadImage();
    }
    /**
     * @inheritdoc
     * @override
     */
    populateSpriteMap() {
      let row = 4;
      this.loadTileType(SpecialTileTypes.SKY, row);
      row++;
      this.loadTileType(SpecialTileTypes.GRASS, row);
      row++;
      this.loadTileType(SpecialTileTypes.DIRT, row);
      row++;
      for (let i = 0; i < TileTypeArray.length; i++) {
        this.loadTileType(TileTypeArray[i], row);
        row++;
      }
      this.loaded = true;
    }
    /**
     * @private
     * @param {TileType} tileType 
     * @param {number} row 
     */
    loadTileType(tileType, row) {
      tileType.tileTypeBackground = this.parseRow(row);
    }
    /**
     * @private
     * @param {TileType} tileType 
     * @param {number} x
     * @param {number} row 
     * @returns {TileTemplate}
     */
    parseRow(row) {
      const step = this.spriteSize + 1;
      const numSpritesPerRow = 48;
      const y = row * step;
      let x = 0;
      const tileTypeBackground = new TileTypeBackground();
      for (let i = 0; i < numSpritesPerRow; i++) {
        tileTypeBackground.sprites.push(new BasicSprite(this, x, y));
        x += step;
      }
      return tileTypeBackground;
    }
  };

  // src/model/item/ItemSpriteIds.js
  var ItemSpriteIds = {
    thruster: {
      icon: "",
      staticOverlay: "",
      activeOverlay: "thruster"
    },
    pick: {
      icon: "",
      staticOverlay: "pick_s",
      activeOverlay: "pick_a"
    },
    club: {
      icon: "",
      staticOverlay: "club_s",
      activeOverlay: "club_a"
    },
    axe: {
      icon: "",
      staticOverlay: "axe_s",
      activeOverlay: "axe_a"
    },
    broadSword: {
      icon: "",
      staticOverlay: "broad_sword_s",
      activeOverlay: "broad_sword_a"
    },
    mace: {
      icon: "",
      staticOverlay: "mace_s",
      activeOverlay: "mace_a"
    },
    twoHandedAxe: {
      icon: "",
      staticOverlay: "two_handed_axe_s",
      activeOverlay: "two_handed_axe_a"
    },
    twoHandedClub: {
      icon: "",
      staticOverlay: "two_handed_club_s",
      activeOverlay: "two_handed_club_a"
    },
    darkSword: {
      icon: "",
      staticOverlay: "dark_sword_s",
      activeOverlay: "dark_sword_a"
    },
    redSword: {
      icon: "",
      staticOverlay: "red_sword_s",
      activeOverlay: "red_sword_a"
    }
  };

  // src/model/sprite/ItemOverlaySpritesheet.js
  var ItemOverlaySpritesheet = class extends AnimationRowSpritesheet {
    /**
     * @param {string} fileName 
     * @param {number} spriteSize 
     * @param {SpriteAnimationManager} spriteAnimationManager
     */
    constructor(fileName, spriteSize, spriteAnimationManager) {
      super(fileName, spriteSize);
      this.spriteAnimationManager = spriteAnimationManager;
      this.spriteAnimationMap = {};
      this.loadImage();
    }
    /**
     * @param {string} id
     * @returns {SpriteAnimation}
     */
    getSpriteAnimation(id) {
      return this.spriteAnimationMap[id];
    }
    /**
     * @override
     * @param {number} spriteSize
     * @returns {number}
     */
    calculateSpriteStep(spriteSize) {
      return spriteSize;
    }
    /**
     * @inheritdoc
     * @override
     */
    populateSpriteMap() {
      let row = 0;
      this.populateSpriteAnimation(ItemSpriteIds.thruster.activeOverlay, row, 5, true, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.pick.staticOverlay, row, 1, false, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.pick.activeOverlay, row, 4, true, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.club.staticOverlay, row, 1, false, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.club.activeOverlay, row, 5, true, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.axe.staticOverlay, row, 1, false, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.axe.activeOverlay, row, 5, true, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.broadSword.staticOverlay, row, 1, false, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.broadSword.activeOverlay, row, 5, true, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.mace.staticOverlay, row, 1, false, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.mace.activeOverlay, row, 5, true, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.twoHandedAxe.staticOverlay, row, 1, false, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.twoHandedAxe.activeOverlay, row, 5, true, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.twoHandedClub.staticOverlay, row, 1, false, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.twoHandedClub.activeOverlay, row, 5, true, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.darkSword.staticOverlay, row, 1, false, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.darkSword.activeOverlay, row, 5, true, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.redSword.staticOverlay, row, 1, false, true);
      row++;
      this.populateSpriteAnimation(ItemSpriteIds.redSword.activeOverlay, row, 5, true, true);
      this.loaded = true;
    }
    /**
     * @private
     * @param {string} id 
     * @param {number} row 
     * @param {number} numSprites 
     * @param {boolean} fastAnimation
     * @param {boolean} loopingAnimation
     */
    populateSpriteAnimation(id, row, numSprites, fastAnimation, loopingAnimation) {
      const animation = new SpriteAnimation(this.parseRow(row, numSprites), this.spriteAnimationManager, fastAnimation, loopingAnimation);
      this.spriteAnimationMap[id] = animation;
    }
  };

  // src/model/fixture/FixtureSpriteColors.js
  var FixtureSpriteColors = {
    GREEN_DARK_GREEN1_DARK_GREEN2: "A0",
    DARK_BROWN1_GREY_ORANGE_BROWN: "A1",
    LIGHT_BROWN2_BROWN3_YELLOW_BROWN: "A2",
    LIGHT_YELLOW_YELLOW_ORANGE_YELLOW: "A3",
    LIGHT_PINK_DARK_PURPLE_YELLOW: "A4",
    GRAY_DARK_GRAY_LIGHTER_GRAY: "A5",
    BLUE_DARK_BLUE_LIGHT_GRAY: "A6",
    LIGHT_GRAY_BLUE_DARK_BLUE: "A7",
    ORANGE_ORANGE_YELLOW_DARK_ORANGE: "A8",
    BLUE_DARK_BLUE_PURPLE: "A9",
    BLUE_ORANGE_YELLOW_PURPLE: "B0",
    TEAL_LIGHT_BLUE1_PALE_AQUA: "B1",
    DARK_BROWN_RED_DARK_RED_RED: "B2",
    DARK_GRAY_ORANGE_RED_BLUE: "B3",
    DARK_GRAY_LIGHT_PURPLE1_TAN_GREEN: "B4",
    TAN_GREEN_DARK_GRAY_LIGHT_PURPLE1: "B5",
    SKY_BLUE_PALE_BLUE_LIGHT_BLUE2: "B6",
    LIGHT_BROWN2_REDDISH_BROWN_ORANGE_BROWN: "B7",
    ORANGE_BROWN_REDDISH_BROWN_LIGHT_BROWN2: "B8",
    DARKER_PURPLE_LIGHT_PURPLE2_LIGHT_YELLOW: "B9",
    ORANGE_YELLOW_ORANGE_BROWN_LIGHT_BROWN2: "C0",
    DARK_GRAY_LIGHT_PURPLE1_GREEN_BLUE: "C1",
    BLUE_ORANGE_YELLOW_DARK_GRAY: "C2",
    SKY_BLUE_BLUE_LIGHT_GREEN: "C3",
    VERY_DARK_GREEN_TAN_WHITE_YELLOW: "C4",
    BROWNISH_GREEN_DARK_RED_SUPER_DARK_GREEN: "C5",
    YELLOW_ORANGE_DARK_GREEN2: "C6",
    LIGHT_PURPLE2_DARKER_PURPLE_LIGHT_YELLOW: "C7",
    DARK_GRAY_DARK_ORANGE_LIGHTER_GRAY: "C8",
    DARK_ORANGE_DARK_GRAY_LIGHTER_GRAY: "C9",
    LIGHTER_GRAY_DARK_ORANGE_DARK_GRAY: "D0",
    LIME_GREEN1_DARK_BLUE_DARK_GRAY: "D1",
    VERY_DARK_RED_SUPER_DARK_RED_ORANGE_RED: "D2",
    ORANGE_RED_VERY_DARK_RED_SUPER_DARK_RED: "D3",
    PURPLE_VERY_DARK_RED_SUPER_DARK_RED: "D4",
    DARK_GRAY_LIGHT_GRAY_DARK_RED_PINK: "D5",
    BLACK_LIGHT_BLUE1_LIGHT_BLUE2: "D6",
    GREEN_BLUE_LIME_GREEN1_BLUE: "D7",
    GREY_BLUE_GREEN_LIME_GREEN2_YELLOW_BROWN: "D8",
    ORANGE_YELLOW_YELLOW_BROWN_TAN_GREEN: "D9",
    LIGHT_BLUE_GREEN_BROWNISH_GREEN_LIME_GREEN2: "E0",
    LIME_GREEN2_BROWNISH_GREEN_DARK_RED_ORANGE: "E1",
    GRAY_DARK_BROWN3_DARKER_BROWN: "E2",
    BLACK_DARKER_BROWN_DARK_BROWN3: "E3",
    DARK_PURPLE_PURPLE_LIGHT_PURPLE1: "E4",
    LIGHT_PURPLE1_ORANGE_RED_PURPLE: "E5",
    GREEN_BROWN_DARK_BROWN2_DARK_GRAY: "E6",
    SKY_BLUE_BROWNISH_GREEN_LIME_GREEN2: "E7",
    RED_SKY_BLUE_BROWNISH_GREEN: "E8"
  };
  function buildColorArray() {
    const colors = [];
    for (let color of Object.values(FixtureSpriteColors)) {
      colors.push(color);
    }
    return colors;
  }
  var FixtureSpriteColorArray = buildColorArray();

  // src/model/fixture/FixtureTypeNames.js
  var FixtureTypeNames = {
    VINE_TOP0: "V0",
    VINE_TOP1: "V1",
    VINE_TOP2: "V2",
    VINE_TOP3: "V3",
    VINE_TOP4: "V4",
    VINE_TOP5: "V5",
    VINE_TOP6: "V6",
    VINE_TOP7: "V7",
    VINE_PARTIAL0: "v0",
    VINE_PARTIAL1: "v1",
    VINE_PARTIAL2: "v2",
    VINE_PARTIAL3: "v3",
    VINE_PARTIAL4: "v4",
    VINE_PARTIAL5: "v5",
    VINE_PARTIAL6: "v6",
    VINE_PARTIAL7: "v7",
    FLOOR_PLANT0: "P0",
    FLOOR_PLANT1: "P1",
    FLOOR_PLANT2: "P2",
    FLOOR_PLANT3: "P3",
    FLOOR_PLANT4: "P4",
    FLOOR_PLANT5: "P5",
    FLOOR_PLANT6: "P6",
    FLOOR_PLANT7: "P7",
    FLOOR_GRASS0: "G0",
    FLOOR_GRASS1: "G1",
    FLOOR_GRASS2: "G2",
    FLOOR_GRASS3: "G3",
    FLOOR_GRASS4: "G4",
    FLOOR_GRASS5: "G5",
    FLOOR_GRASS6: "G6",
    FLOOR_GRASS7: "G7",
    FLOOR_MUSHROOM0: "M0",
    FLOOR_MUSHROOM1: "M1",
    FLOOR_MUSHROOM2: "M2",
    FLOOR_MUSHROOM3: "M3",
    FLOOR_MUSHROOM4: "M4",
    FLOOR_MUSHROOM5: "M5",
    FLOOR_MUSHROOM6: "M6",
    FLOOR_MUSHROOM7: "M7",
    WALL_FLOWER0: "W0",
    WALL_FLOWER1: "W1",
    WALL_FLOWER2: "W2",
    WALL_FLOWER3: "W3",
    WALL_FLOWER4: "W4",
    WALL_FLOWER5: "W5",
    WALL_FLOWER6: "W6",
    WALL_FLOWER7: "W7",
    STALACTITE0: "S0",
    STALACTITE1: "S1",
    STALACTITE2: "S2",
    STALACTITE3: "S3",
    STALACTITE4: "S4",
    STALACTITE5: "S5",
    STALACTITE6: "S6",
    STALACTITE7: "S7",
    STALAGMITE0: "s0",
    STALAGMITE1: "s1",
    STALAGMITE2: "s2",
    STALAGMITE3: "s3",
    STALAGMITE4: "s4",
    STALAGMITE5: "s5",
    STALAGMITE6: "s6",
    STALAGMITE7: "s7",
    FLOOR_POKIES0: "f0",
    FLOOR_POKIES1: "f1",
    FLOOR_POKIES2: "f2",
    FLOOR_POKIES3: "f3",
    FLOOR_POKIES4: "f4",
    FLOOR_POKIES5: "f5",
    FLOOR_POKIES6: "f6",
    FLOOR_POKIES7: "f7",
    CEILING_POKIES0: "p0",
    CEILING_POKIES1: "p1",
    CEILING_POKIES2: "p2",
    CEILING_POKIES3: "p3",
    CEILING_POKIES4: "p4",
    CEILING_POKIES5: "p5",
    CEILING_POKIES6: "p6",
    CEILING_POKIES7: "p7",
    WALL_CRACKS0: "C0",
    WALL_CRACKS1: "C1",
    WALL_CRACKS2: "C2",
    WALL_CRACKS3: "C3",
    WALL_CRACKS4: "C4",
    WALL_CRACKS5: "C5",
    WALL_CRACKS6: "C6",
    WALL_CRACKS7: "C7",
    TALL_GRASS0: "g0",
    TALL_GRASS1: "g1",
    TALL_GRASS2: "g2",
    TALL_GRASS3: "g3",
    TALL_GRASS4: "g4",
    TALL_GRASS5: "g5",
    TALL_GRASS6: "g6",
    TALL_GRASS7: "g7",
    CEILING_GRASS0: "c0",
    CEILING_GRASS1: "c1",
    CEILING_GRASS2: "c2",
    CEILING_GRASS3: "c3",
    CEILING_GRASS4: "c4",
    CEILING_GRASS5: "c5",
    CEILING_GRASS6: "c6",
    CEILING_GRASS7: "c7",
    CURVED_PLANTS0: "a0",
    CURVED_PLANTS1: "a1",
    CURVED_PLANTS2: "a2",
    CURVED_PLANTS3: "a3",
    CURVED_PLANTS4: "a4",
    CURVED_PLANTS5: "a5",
    CURVED_PLANTS6: "a6",
    CURVED_PLANTS7: "a7",
    FLOWERS0: "b0",
    FLOWERS1: "b1",
    FLOWERS2: "b2",
    FLOWERS3: "b3",
    FLOWERS4: "b4",
    FLOWERS5: "b5",
    FLOWERS6: "b6",
    FLOWERS7: "b7",
    FLOOR_SPIKES0: "d0",
    FLOOR_SPIKES1: "d1",
    FLOOR_SPIKES2: "d2",
    FLOOR_SPIKES3: "d3",
    FLOOR_SPIKES4: "d4",
    FLOOR_SPIKES5: "d5",
    FLOOR_SPIKES6: "d6",
    FLOOR_SPIKES7: "d7",
    CEILING_SPIKES0: "e0",
    CEILING_SPIKES1: "e1",
    CEILING_SPIKES2: "e2",
    CEILING_SPIKES3: "e3",
    CEILING_SPIKES4: "e4",
    CEILING_SPIKES5: "e5",
    CEILING_SPIKES6: "e6",
    CEILING_SPIKES7: "e7",
    WALL_HOLES0: "h0",
    WALL_HOLES1: "h1",
    WALL_HOLES2: "h2",
    WALL_HOLES3: "h3",
    WALL_HOLES4: "h4",
    WALL_HOLES5: "h5",
    WALL_HOLES6: "h6",
    WALL_HOLES7: "h7"
  };
  var VINES_TOP = [
    FixtureTypeNames.VINE_TOP0,
    FixtureTypeNames.VINE_TOP1,
    FixtureTypeNames.VINE_TOP2,
    FixtureTypeNames.VINE_TOP3,
    FixtureTypeNames.VINE_TOP4,
    FixtureTypeNames.VINE_TOP5,
    FixtureTypeNames.VINE_TOP6,
    FixtureTypeNames.VINE_TOP7
  ];
  var VINES_PARTIAL = [
    FixtureTypeNames.VINE_PARTIAL0,
    FixtureTypeNames.VINE_PARTIAL1,
    FixtureTypeNames.VINE_PARTIAL2,
    FixtureTypeNames.VINE_PARTIAL3,
    FixtureTypeNames.VINE_PARTIAL4,
    FixtureTypeNames.VINE_PARTIAL5,
    FixtureTypeNames.VINE_PARTIAL6,
    FixtureTypeNames.VINE_PARTIAL7
  ];
  var FLOOR_PLANTS = [
    FixtureTypeNames.FLOOR_PLANT0,
    FixtureTypeNames.FLOOR_PLANT1,
    FixtureTypeNames.FLOOR_PLANT2,
    FixtureTypeNames.FLOOR_PLANT3,
    FixtureTypeNames.FLOOR_PLANT4,
    FixtureTypeNames.FLOOR_PLANT5,
    FixtureTypeNames.FLOOR_PLANT6,
    FixtureTypeNames.FLOOR_PLANT7
  ];
  var FLOOR_GRASS = [
    FixtureTypeNames.FLOOR_GRASS0,
    FixtureTypeNames.FLOOR_GRASS1,
    FixtureTypeNames.FLOOR_GRASS2,
    FixtureTypeNames.FLOOR_GRASS3,
    FixtureTypeNames.FLOOR_GRASS4,
    FixtureTypeNames.FLOOR_GRASS5,
    FixtureTypeNames.FLOOR_GRASS6,
    FixtureTypeNames.FLOOR_GRASS7
  ];
  var FLOOR_MUSHROOM = [
    FixtureTypeNames.FLOOR_MUSHROOM0,
    FixtureTypeNames.FLOOR_MUSHROOM1,
    FixtureTypeNames.FLOOR_MUSHROOM2,
    FixtureTypeNames.FLOOR_MUSHROOM3,
    FixtureTypeNames.FLOOR_MUSHROOM4,
    FixtureTypeNames.FLOOR_MUSHROOM5,
    FixtureTypeNames.FLOOR_MUSHROOM6,
    FixtureTypeNames.FLOOR_MUSHROOM7
  ];
  var WALL_FLOWERS = [
    FixtureTypeNames.WALL_FLOWER0,
    FixtureTypeNames.WALL_FLOWER1,
    FixtureTypeNames.WALL_FLOWER2,
    FixtureTypeNames.WALL_FLOWER3,
    FixtureTypeNames.WALL_FLOWER4,
    FixtureTypeNames.WALL_FLOWER5,
    FixtureTypeNames.WALL_FLOWER6,
    FixtureTypeNames.WALL_FLOWER7
  ];
  var STALACTITES = [
    FixtureTypeNames.STALACTITE0,
    FixtureTypeNames.STALACTITE1,
    FixtureTypeNames.STALACTITE2,
    FixtureTypeNames.STALACTITE3,
    FixtureTypeNames.STALACTITE4,
    FixtureTypeNames.STALACTITE5,
    FixtureTypeNames.STALACTITE6,
    FixtureTypeNames.STALACTITE7
  ];
  var STALAGMITES = [
    FixtureTypeNames.STALAGMITE0,
    FixtureTypeNames.STALAGMITE1,
    FixtureTypeNames.STALAGMITE2,
    FixtureTypeNames.STALAGMITE3,
    FixtureTypeNames.STALAGMITE4,
    FixtureTypeNames.STALAGMITE5,
    FixtureTypeNames.STALAGMITE6,
    FixtureTypeNames.STALAGMITE7
  ];
  var FLOOR_POKIES = [
    FixtureTypeNames.FLOOR_POKIES0,
    FixtureTypeNames.FLOOR_POKIES1,
    FixtureTypeNames.FLOOR_POKIES2,
    FixtureTypeNames.FLOOR_POKIES3,
    FixtureTypeNames.FLOOR_POKIES4,
    FixtureTypeNames.FLOOR_POKIES5,
    FixtureTypeNames.FLOOR_POKIES6,
    FixtureTypeNames.FLOOR_POKIES7
  ];
  var CEILING_POKIES = [
    FixtureTypeNames.CEILING_POKIES0,
    FixtureTypeNames.CEILING_POKIES1,
    FixtureTypeNames.CEILING_POKIES2,
    FixtureTypeNames.CEILING_POKIES3,
    FixtureTypeNames.CEILING_POKIES4,
    FixtureTypeNames.CEILING_POKIES5,
    FixtureTypeNames.CEILING_POKIES6,
    FixtureTypeNames.CEILING_POKIES7
  ];
  var TALL_GRASS = [
    FixtureTypeNames.TALL_GRASS0,
    FixtureTypeNames.TALL_GRASS1,
    FixtureTypeNames.TALL_GRASS2,
    FixtureTypeNames.TALL_GRASS3,
    FixtureTypeNames.TALL_GRASS4,
    FixtureTypeNames.TALL_GRASS5,
    FixtureTypeNames.TALL_GRASS6,
    FixtureTypeNames.TALL_GRASS7
  ];
  var CEILING_GRASS = [
    FixtureTypeNames.CEILING_GRASS0,
    FixtureTypeNames.CEILING_GRASS1,
    FixtureTypeNames.CEILING_GRASS2,
    FixtureTypeNames.CEILING_GRASS3,
    FixtureTypeNames.CEILING_GRASS4,
    FixtureTypeNames.CEILING_GRASS5,
    FixtureTypeNames.CEILING_GRASS6,
    FixtureTypeNames.CEILING_GRASS7
  ];
  var CURVED_PLANTS = [
    FixtureTypeNames.CURVED_PLANTS0,
    FixtureTypeNames.CURVED_PLANTS1,
    FixtureTypeNames.CURVED_PLANTS2,
    FixtureTypeNames.CURVED_PLANTS3,
    FixtureTypeNames.CURVED_PLANTS4,
    FixtureTypeNames.CURVED_PLANTS5,
    FixtureTypeNames.CURVED_PLANTS6,
    FixtureTypeNames.CURVED_PLANTS7
  ];
  var FLOWERS = [
    FixtureTypeNames.FLOWERS0,
    FixtureTypeNames.FLOWERS1,
    FixtureTypeNames.FLOWERS2,
    FixtureTypeNames.FLOWERS3,
    FixtureTypeNames.FLOWERS4,
    FixtureTypeNames.FLOWERS5,
    FixtureTypeNames.FLOWERS6,
    FixtureTypeNames.FLOWERS7
  ];
  var FLOOR_SPIKES = [
    FixtureTypeNames.FLOOR_SPIKES0,
    FixtureTypeNames.FLOOR_SPIKES1,
    FixtureTypeNames.FLOOR_SPIKES2,
    FixtureTypeNames.FLOOR_SPIKES3,
    FixtureTypeNames.FLOOR_SPIKES4,
    FixtureTypeNames.FLOOR_SPIKES5,
    FixtureTypeNames.FLOOR_SPIKES6,
    FixtureTypeNames.FLOOR_SPIKES7
  ];
  var CEILING_SPIKES = [
    FixtureTypeNames.CEILING_SPIKES0,
    FixtureTypeNames.CEILING_SPIKES1,
    FixtureTypeNames.CEILING_SPIKES2,
    FixtureTypeNames.CEILING_SPIKES3,
    FixtureTypeNames.CEILING_SPIKES4,
    FixtureTypeNames.CEILING_SPIKES5,
    FixtureTypeNames.CEILING_SPIKES6,
    FixtureTypeNames.CEILING_SPIKES7
  ];
  var WALL_HOLES = [
    FixtureTypeNames.WALL_HOLES0,
    FixtureTypeNames.WALL_HOLES1,
    FixtureTypeNames.WALL_HOLES2,
    FixtureTypeNames.WALL_HOLES3,
    FixtureTypeNames.WALL_HOLES4,
    FixtureTypeNames.WALL_HOLES5,
    FixtureTypeNames.WALL_HOLES6,
    FixtureTypeNames.WALL_HOLES7
  ];
  var CEILING = [
    VINES_TOP,
    STALACTITES,
    CEILING_POKIES,
    CEILING_GRASS,
    CEILING_SPIKES
  ];
  var MID = [
    VINES_PARTIAL,
    WALL_FLOWERS,
    WALL_HOLES
  ];
  var FLOOR = [
    FLOOR_PLANTS,
    FLOOR_GRASS,
    FLOOR_MUSHROOM,
    STALAGMITES,
    FLOOR_POKIES,
    TALL_GRASS,
    CURVED_PLANTS,
    FLOWERS,
    FLOOR_SPIKES
  ];

  // src/model/sprite/NamedSpriteSpritesheet.js
  var NamedSpriteSpritesheet = class extends Spritesheet {
    /**
     * @param {string} fileName 
     * @param {number} spriteSize 
     */
    constructor(fileName, spriteSize) {
      super(fileName, spriteSize);
      this.spriteMap = {};
    }
    /**
     * @param {string} name
     * @returns {Sprite}
     */
    getSprite(name) {
      return this.spriteMap[name];
    }
  };

  // src/model/sprite/StaticFixtureSpritesheet.js
  var StaticFixtureSpritesheet = class _StaticFixtureSpritesheet extends NamedSpriteSpritesheet {
    /**
     * @param {string} fileName 
     * @param {number} spriteSize 
     */
    constructor(fileName, spriteSize) {
      super(fileName, spriteSize);
      this.loadImage();
    }
    /**
     * @param {string} fixtureTypeName 
     * @param {string} colorName 
     * @returns {string}
     */
    static getSpriteName(fixtureTypeName, colorName) {
      return fixtureTypeName + "_" + colorName;
    }
    /**
     * @inheritdoc
     * @override
     */
    populateSpriteMap() {
      let row = 0;
      for (let typeName of Object.values(FixtureTypeNames)) {
        this.parseRow(row, typeName);
        row++;
      }
      this.loaded = true;
    }
    /**
     * @private
     * @param {number} row 
     * @param {string} fixtureTypeName
     */
    parseRow(row, fixtureTypeName) {
      const step = this.spriteSize + 1;
      const y = row * step;
      let x = 0;
      for (let colorName of Object.values(FixtureSpriteColors)) {
        const name = _StaticFixtureSpritesheet.getSpriteName(fixtureTypeName, colorName);
        this.spriteMap[name] = new BasicSprite(this, x, y);
        x += step;
      }
    }
    /**
     * @param {string} fixtureTypeName 
     * @param {string} colorName 
     * @returns {Sprite}
     */
    getFixtureSprite(fixtureTypeName, colorName) {
      return this.getSprite(_StaticFixtureSpritesheet.getSpriteName(fixtureTypeName, colorName));
    }
  };

  // src/model/monster/MonsterSpriteNames.js
  var MonsterSpriteNames = {
    /////////////////////////////////////////
    // ROW 0
    /////////////////////////////////////////
    AQUATIC_SNAKE_TAN_1: "AQUATIC_SNAKE_TAN1",
    AQUATIC_SNAKE_TAN_2: "AQUATIC_SNAKE_TAN2",
    AQUATIC_SNAKE_BLACK_1: "AQUATIC_SNAKE_BLACK1",
    AQUATIC_SNAKE_BLACK_2: "AQUATIC_SNAKE_BLACK2",
    AQUATIC_MONSTER: "AQUATIC_MONSTER",
    AVIAN_BAT_BROWN_SMALL: "AVIAN_BAT_BROWN_SMALL",
    AVIAN_BAT_BROWN_LARGE: "AVIAN_BAT_BROWN_LARGE",
    AVIAN_BAT_BLACK_LARGE: "AVIAN_BAT_BLACK_LARGE",
    /////////////////////////////////////////
    // ROW 1
    /////////////////////////////////////////
    AVIAN_BAT_BROWN_SMALL2: "AVIAN_BAT_BROWN_SMALL2",
    AVIAN_BAT_BROWN_LARGE2: "AVIAN_BAT_BROWN_LARGE2",
    DEMON_REPTILIAN_GREEN: "DEMON_REPTILIAN_GREEN",
    DEMON_REPTILIAN_WINGED: "DEMON_REPTILIAN_WINGED",
    DEMON_BROWN: "DEMON_BROWN",
    DEMON_BLOB: "DEMON_BLOB",
    DEMON_BLUE: "DEMON_BLUE",
    DEMON_BLUE_WINGED: "DEMON_BLUE_WINGED",
    /////////////////////////////////////////
    // ROW 2
    /////////////////////////////////////////
    DEMON_RED_GLOWING: "DEMON_RED_GLOWING",
    DEMON_RED_WINGED_1: "DEMON_RED_WINGED1",
    DEMON_RED_WINGED_2: "DEMON_RED_WINGED2",
    DEMON_RED_DARK_LARGE: "DEMON_RED_DARK_LARGE",
    DEMON_RED_LARGE: "DEMON_RED_LARGE",
    DEMON_RED_PALE_LARGE: "DEMON_RED_PALE_LARGE",
    DEMON_BLUE_LARGE: "DEMON_BLUE_LARGE",
    DEMON_BLUE_RED_LARGE: "DEMON_BLUE_RED_LARGE",
    /////////////////////////////////////////
    // ROW 3
    /////////////////////////////////////////
    DEMON_GREEN_EYE_STOCKS: "DEMON_GREEN_EYE_STOCKS",
    DEMON_GREEN_EVIL_WINGED: "DEMON_GREEN_EVIL_WINGED",
    DEMON_RED_DARK_WHIP: "DEMON_RED_DARK_WHIP",
    DEMON_RED_TINY_JUMPING: "DEMON_RED_TINY_JUMPING",
    DEMON_RED_SMALL_JUMPING: "DEMON_RED_SMALL_JUMPING",
    DEMON_ARMORED: "DEMON_ARMORED",
    DEMON_HELMET_HORNED: "DEMON_HELMET_HORNED",
    DEMON_RED_FANGED: "DEMON_RED_FANGED",
    /////////////////////////////////////////
    // ROW 4
    /////////////////////////////////////////
    DEMON_GREEN_FROG_LIKE: "DEMON_GREEN_FROG_LIKE",
    ELEMENTAL_WARRIOR: "ELEMENTAL_WARRIOR",
    ELEMENTAL_SQUID: "ELEMENTAL_SQUID",
    ELEMENTAL_GOLEM: "ELEMENTAL_GOLEM",
    ELEMENTAL_GOLEM_DARK: "ELEMENTAL_GOLEM_DARK",
    ELEMENTAL_GOLEM_RUSTY: "ELEMENTAL_GOLEM_RUSTY",
    ELEMENTAL_BLOODY: "ELEMENTAL_BLOODY",
    ELEMENTAL_STONE: "ELEMENTAL_STONE",
    /////////////////////////////////////////
    // ROW 5
    /////////////////////////////////////////
    ELEMENTAL_SWIRL_ORANGE: "ELEMENTAL_SWIRL_ORANGE",
    ELEMENTAL_SWIRL_YELLOW: "ELEMENTAL_SWIRL_YELLOW",
    ELEMENTAL_SWIRL_BLUE_DARK: "ELEMENTAL_SWIRL_BLUE_DARK",
    ELEMENTAL_SWIRL_BLUE_LIGHT: "ELEMENTAL_SWIRL_BLUE_LIGHT",
    ELEMENTAL_SWIRL_RED: "ELEMENTAL_SWIRL_RED",
    ELEMENTAL_CREEPY_RED: "ELEMENTAL_CREEPY_RED",
    ELEMENTAL_CREEPY_BROWN: "ELEMENTAL_CREEPY_BROWN",
    ELEMENTAL_CREEPY_LIGHT_BLUE: "ELEMENTAL_CREEPY_LIGHT_BLUE",
    /////////////////////////////////////////
    // ROW 6
    /////////////////////////////////////////
    ELEMENTAL_BALL_GREEN: "ELEMENTAL_BALL_GREEN",
    ELEMENTAL_BALL_BLUE: "ELEMENTAL_BALL_BLUE",
    ELEMENTAL_BALL_RED: "ELEMENTAL_BALL_RED",
    ELEMENTAL_BALL_BLACK: "ELEMENTAL_BALL_BLACK",
    ELEMENTAL_EYE_WHITE: "ELEMENTAL_EYE_WHITE",
    ELEMENTAL_EYE_RED: "ELEMENTAL_EYE_RED",
    ELEMENTAL_EYE_BEHOLDER: "ELEMENTAL_EYE_BEHOLDER",
    HUMANOID_210_SASQUATCH: "HUMANOID_210_SASQUATCH",
    /////////////////////////////////////////
    // ROW 7
    /////////////////////////////////////////
    HUMANOID_000: "HUMANOID_000",
    HUMANOID_001: "HUMANOID_001",
    HUMANOID_002: "HUMANOID_002",
    HUMANOID_003: "HUMANOID_003",
    HUMANOID_004: "HUMANOID_004",
    HUMANOID_005: "HUMANOID_005",
    HUMANOID_006: "HUMANOID_006",
    HUMANOID_007: "HUMANOID_007",
    /////////////////////////////////////////
    // ROW 8
    /////////////////////////////////////////
    HUMANOID_010_MINOTAUR: "HUMANOID_010_MINOTAUR",
    HUMANOID_011_CYCLOPS: "HUMANOID_011_CYCLOPS",
    HUMANOID_040_WALRUS_MAN: "HUMANOID_040_WALRUS_MAN",
    HUMANOID_041_WALRUS_MAN: "HUMANOID_041_WALRUS_MAN",
    HUMANOID_042_WALRUS_MAN: "HUMANOID_042_WALRUS_MAN",
    HUMANOID_043_WALRUS_MAN: "HUMANOID_043_WALRUS_MAN",
    HUMANOID_044_WALRUS_MAN: "HUMANOID_044_WALRUS_MAN",
    HUMANOID_045_WALRUS_MAN: "HUMANOID_045_WALRUS_MAN",
    /////////////////////////////////////////
    // ROW 9
    /////////////////////////////////////////
    HUMANOID_046_WALRUS_MAN: "HUMANOID_046_WALRUS_MAN",
    HUMANOID_070: "HUMANOID_070",
    HUMANOID_071: "HUMANOID_071",
    HUMANOID_072: "HUMANOID_072",
    HUMANOID_073: "HUMANOID_073",
    HUMANOID_170_STONE_SERPENT: "HUMANOID_170_STONE_SERPENT",
    HUMANOID_171_STONE_SERPENT: "HUMANOID_171_STONE_SERPENT",
    MISC_ANIMAL_70: "MISC_ANIMAL_70",
    /////////////////////////////////////////
    // ROW 10
    /////////////////////////////////////////
    HUMANOID_190_DEMON_BASHER: "HUMANOID_190_DEMON_BASHER",
    HUMANOID_191_DEMON_BASHER: "HUMANOID_191_DEMON_BASHER",
    HUMANOID_200_SQUID_DEMON: "HUMANOID_200_SQUID_DEMON",
    HUMANOID_201_SQUID_DEMON: "HUMANOID_201_SQUID_DEMON",
    MISC_ANIMAL_03_OWL: "MISC_ANIMAL_03_OWL",
    MISC_ANIMAL_04: "MISC_ANIMAL_04",
    MISC_ANIMAL_05: "MISC_ANIMAL_05",
    MISC_ANIMAL_06: "MISC_ANIMAL_06",
    /////////////////////////////////////////
    // ROW 11
    /////////////////////////////////////////
    MISC_ANIMAL_11: "MISC_ANIMAL_11",
    MISC_ANIMAL_12: "MISC_ANIMAL_12",
    MISC_ANIMAL_50: "MISC_ANIMAL_50",
    MISC_ANIMAL_51: "MISC_ANIMAL_51",
    MISC_ANIMAL_52: "MISC_ANIMAL_52",
    MISC_ANIMAL_53: "MISC_ANIMAL_53",
    PEST_LADYBUG_100: "PEST_LADYBUG_100",
    PEST_LADYBUG_101: "PEST_LADYBUG_101",
    /////////////////////////////////////////
    // ROW 12
    /////////////////////////////////////////
    PEST_TINY_00: "PEST_TINY_00",
    PEST_TINY_01: "PEST_TINY_01",
    PEST_TINY_02: "PEST_TINY_02",
    PEST_TINY_03: "PEST_TINY_03",
    PEST_TINY_04: "PEST_TINY_04",
    PEST_TINY_05: "PEST_TINY_05",
    PEST_TINY_WORM_1: "PEST_TINY_WORM1",
    PEST_TINY_WORM_2: "PEST_TINY_WORM2",
    /////////////////////////////////////////
    // ROW 13
    /////////////////////////////////////////
    PEST_ANT_10: "PEST_INSECT_10",
    PEST_INSECT_11: "PEST_INSECT_11",
    PEST_INSECT_12: "PEST_INSECT_12",
    PEST_INSECT_13: "PEST_INSECT_13",
    PEST_INSECT_14: "PEST_INSECT_14",
    PEST_SPIDER_20: "PEST_SPIDER_20",
    PEST_SPIDER_21: "PEST_SPIDER_21",
    PEST_SPIDER_22: "PEST_SPIDER_22",
    /////////////////////////////////////////
    // ROW 14
    /////////////////////////////////////////
    PEST_SCORPION_23: "PEST_SCORPION_23",
    PEST_SCORPION_24: "PEST_SCORPION_24",
    PEST_SCORPION_25: "PEST_SCORPION_25",
    PEST_WORM_30: "PEST_WORM_30",
    PEST_WORM_31: "PEST_WORM_31",
    PEST_BALL: "PEST_BALL",
    PEST_WORM_33: "PEST_WORM_33",
    PEST_WORM_34: "PEST_WORM_34",
    /////////////////////////////////////////
    // ROW 15
    /////////////////////////////////////////
    PEST_GIANT_ANT_40: "PEST_GIANT_ANT_40",
    PEST_GIANT_ANT_41: "PEST_GIANT_ANT_41",
    PEST_GIANT_ANT_42: "PEST_GIANT_ANT_42",
    PEST_GIANT_ANT_43: "PEST_GIANT_ANT_43",
    PEST_SLUG_70: "PEST_SLUG_70",
    PEST_SLUG_71: "PEST_SLUG_71",
    PEST_SNAIL_72: "PEST_SNAIL_72",
    PEST_SNAIL_73: "PEST_SNAIL_73",
    /////////////////////////////////////////
    // ROW 16
    /////////////////////////////////////////
    PEST_INSECT_60: "PEST_INSECT_60",
    PEST_INSECT_61: "PEST_INSECT_61",
    PEST_INSECT_80: "PEST_INSECT_80",
    PEST_INSECT_81: "PEST_INSECT_81",
    MINOR_DEVIL: "PLAYER_130_MINOR_DEVIL",
    MINOR_DEVIL_WARRIOR: "PLAYER_131_MINOR_DEVIL_WARRIOR",
    // BLANK
    // BLANK
    /////////////////////////////////////////
    // ROW 17
    /////////////////////////////////////////
    ORC1: "PLAYER_120_ORC",
    ORC_WARRIOR: "PLAYER_121_ORC_WARRIOR",
    ORC_FIGHTER: "PLAYER_122_ORC_FIGHTER",
    ORC_KARATE: "PLAYER_123_ORC_KARATE",
    ORC_PIRATE: "PLAYER_124_ORC_PIRATE",
    ORC2: "PLAYER_125_ORC",
    ORC3: "PLAYER_126_ORC",
    ORC4: "PLAYER_127_ORC",
    /////////////////////////////////////////
    // ROW 18
    /////////////////////////////////////////
    DRAGON_MAN_BASIC: "PLAYER_140_DRAGON_MAN_BASIC",
    DRAGON_MAN_EXPLORER: "PLAYER_141_DRAGON_MAN_EXPLORER",
    DRAGON_MAN_FIGHTER: "PLAYER_142_DRAGON_MAN_FIGHTER",
    DRAGON_MAN_RUFFIAN: "PLAYER_143_DRAGON_MAN_RUFFIAN",
    DRAGON_MAN_RANGER: "PLAYER_144_DRAGON_MAN_RANGER",
    DRAGON_MAN_TERRIBLE: "PLAYER_145_DRAGON_MAN_TERRIBLE",
    DRAGON_MAN_MERCILESS: "PLAYER_146_DRAGON_MAN_MERCILESS",
    DRAGON_MAN_FIERY: "PLAYER_147_DRAGON_MAN_FIERY",
    /////////////////////////////////////////
    // ROW 19
    /////////////////////////////////////////
    QUADRUPED_000: "QUADRUPED_000",
    QUADRUPED_001: "QUADRUPED_001",
    QUADRUPED_002: "QUADRUPED_002",
    QUADRUPED_003: "QUADRUPED_003",
    QUADRUPED_004: "QUADRUPED_004",
    QUADRUPED_005: "QUADRUPED_005",
    QUADRUPED_006: "QUADRUPED_006",
    QUADRUPED_007: "QUADRUPED_007",
    /////////////////////////////////////////
    // ROW 20
    /////////////////////////////////////////
    RODENT_10_RAT_SMALL: "RODENT_10_RAT_SMALL",
    RODENT_11_RAT: "RODENT_11_RAT",
    RODENT_12_RAT_LARGE_BROWN: "RODENT_12_RAT_LARGE_BROWN",
    RODENT_13_RAT_LARGE_GREY: "RODENT_13_RAT_LARGE_GREY",
    RODENT_20_RAT_POISONOUS: "RODENT_20_RAT_POISONOUS",
    RODENT_21_RAT_ZOMBIE: "RODENT_21_RAT_ZOMBIE",
    RODENT_22_MOLE: "RODENT_22_MOLE",
    // BLANK
    /////////////////////////////////////////
    // ROW 21
    /////////////////////////////////////////
    SLIME_BLUE_00: "SLIME_BLUE_00",
    SLIME_BROWN_01: "SLIME_BROWN_01",
    SLIME_WHITE_02: "SLIME_WHITE_02",
    SLIME_GREEN_03: "SLIME_GREEN_03",
    SLIME_PINK_04: "SLIME_PINK_04",
    SLIME_PURPLE_05: "SLIME_PURPLE_05",
    SLIME_MUCUS_GREEN_40: "SLIME_MUCUS_GREEN_40",
    SLIME_MUCUS_BLUE_41: "SLIME_MUCUS_BLUE_41",
    /////////////////////////////////////////
    // ROW 22
    /////////////////////////////////////////
    SLIME_CORRODED_20: "SLIME_CORRODED_20",
    SLIME_SEEING_21: "SLIME_SEEING_21",
    SLIME_ORANGE_22: "SLIME_ORANGE_22",
    SLIME_MINI_BLUE_30: "SLIME_MINI_BLUE_30",
    SLIME_MINI_31: "SLIME_MINI_31",
    SLIME_MINI_ORANGE_32: "SLIME_MINI_ORANGE_32",
    UNDEAD_WRAITH_0600: "UNDEAD_WRAITH_0600",
    UNDEAD_WRAITH_0601: "UNDEAD_WRAITH_0601",
    /////////////////////////////////////////
    // ROW 23
    /////////////////////////////////////////
    UNDEAD_GOBLIN0: "UNDEAD_GOBLIN0",
    // small undead goblin
    UNDEAD_GOBLIN1: "UNDEAD_GOBLIN1",
    UNDEAD_GOBLIN2: "UNDEAD_GOBLIN2",
    UNDEAD_GOBLIN3: "UNDEAD_GOBLIN3",
    UNDEAD_GOBLIN4: "UNDEAD_GOBLIN4",
    // undead goblin
    UNDEAD_GOBLIN5: "UNDEAD_GOBLIN5",
    UNDEAD_GOBLIN6: "UNDEAD_GOBLIN6",
    UNDEAD_GOBLIN7: "UNDEAD_GOBLIN7",
    // large undead goblin
    /////////////////////////////////////////
    // ROW 24
    /////////////////////////////////////////
    UNDEAD_KOBOLD_SKELETON_0200: "UNDEAD_KOBOLD_SKELETON_0200",
    UNDEAD_KOBOLD_SKELETON_0201: "UNDEAD_KOBOLD_SKELETON_0201",
    UNDEAD_KOBOLD_SKELETON_0202: "UNDEAD_KOBOLD_SKELETON_0202",
    UNDEAD_KOBOLD_SKELETON_0203: "UNDEAD_KOBOLD_SKELETON_0203",
    UNDEAD_KOBOLD4: "UNDEAD_KOBOLD4",
    UNDEAD_KOBOLD5: "UNDEAD_KOBOLD5",
    UNDEAD_KOBOLD_KING_0206: "UNDEAD_KOBOLD_KING_0206",
    UNDEAD_KOBOLD_ANCIENT_EVIL7: "UNDEAD_KOBOLD_ANCIENT_EVIL7",
    /////////////////////////////////////////
    // ROW 25
    /////////////////////////////////////////
    UNDEAD_GHOST_0400: "UNDEAD_GHOST_0400",
    UNDEAD_GHOST_0401: "UNDEAD_GHOST_0401",
    UNDEAD_GHOST_0402: "UNDEAD_GHOST_0402",
    UNDEAD_GHOST_0403: "UNDEAD_GHOST_0403",
    UNDEAD_REAPER_0500: "UNDEAD_REAPER_0500",
    UNDEAD_REAPER_0501: "UNDEAD_REAPER_0501",
    UNDEAD_REAPER_0502: "UNDEAD_REAPER_0502",
    UNDEAD_DARKNESS_0801: "UNDEAD_DARKNESS_0801",
    /////////////////////////////////////////
    // ROW 26
    /////////////////////////////////////////
    REPTILE_FLYING_SERPENT_SMALL_002: "REPTILE_FLYING_SERPENT_SMALL_002",
    REPTILE_FLYING_SERPENT_003: "REPTILE_FLYING_SERPENT_003",
    /////////////////////////////////////////
    // ROW 27
    /////////////////////////////////////////
    REPTILE_BROWN_SERPENT_SMALL_040: "REPTILE_BROWN_SERPENT_SMALL_040",
    REPTILE_BROWN_SERPENT_041: "REPTILE_BROWN_SERPENT_041",
    REPTILE_BROWN_SERPENT_LARGE_042: "REPTILE_BROWN_SERPENT_LARGE_042",
    REPTILE_BLACK_SERPENT_043: "REPTILE_BLACK_SERPENT_043",
    REPTILE_BLACK_SERPENT_LARGE_044: "REPTILE_BLACK_SERPENT_LARGE_044",
    REPTILE_BLACK_SERPENT_POISONOUS_045: "REPTILE_BLACK_SERPENT_POISONOUS_045",
    REPTILE_GREEN_SNAKE_SMALL_046: "REPTILE_GREEN_SNAKE_SMALL_046",
    REPTILE_GREEN_SNAKE_047: "REPTILE_GREEN_SNAKE_047"
  };

  // src/model/sprite/DawnLikeSprite.js
  var DawnLikeSprite = class extends Sprite {
    /**
     * @param {SpriteAnimationManager} spriteAnimationManager
     * @param {Spritesheet} spritesheet0
     * @param {Spritesheet} spritesheet1
     * @param {number} spriteX
     * @param {number} spriteY
     */
    constructor(spriteAnimationManager, spritesheet0, spritesheet1, spriteX, spriteY) {
      super(spriteX, spriteY);
      this.spriteAnimationManager = spriteAnimationManager;
      this.spritesheet0 = spritesheet0;
      this.spritesheet1 = spritesheet1;
    }
    /**
     * @override
     * @returns {Image}
     */
    getImage() {
      const frameIndex = this.spriteAnimationManager.getDefaultFrameIndex(2);
      if (frameIndex == 0) {
        return this.spritesheet0.image;
      } else {
        return this.spritesheet1.image;
      }
    }
    /**
     * @override
     * @returns {number}
     */
    getSize() {
      return this.spritesheet0.spriteSize;
    }
  };

  // src/model/sprite/MonsterAnimationFrameSpritesheet.js
  var MonsterAnimationFrameSpritesheet = class extends NamedSpriteSpritesheet {
    /**
     * 
     * @param {string} fileName 
     * @param {number} spriteSize 
     * @param {MonsterSpritesheet} monsterSpritesheet 
     */
    constructor(fileName, spriteSize, monsterSpritesheet) {
      super(fileName, spriteSize);
      this.monsterSpritesheet = monsterSpritesheet;
      this.loadImage();
    }
    /**
     * @inheritdoc
     * @override
     */
    populateSpriteMap() {
      this.loaded = true;
      this.monsterSpritesheet.onSpritesheetLoaded();
    }
  };

  // src/model/sprite/MonsterSpritesheet.js
  var MonsterSpritesheet = class {
    /**
     * @param {string} fileName0 
     * @param {string} fileName1 
     * @param {number} spriteSize 
     * @param {SpriteAnimationManager} spriteAnimationManager
     */
    constructor(fileName0, fileName1, spriteSize, spriteAnimationManager) {
      this.spriteAnimationManager = spriteAnimationManager;
      this.spriteSize = spriteSize;
      this.spriteMap = {};
      this.animationFrameSpritesheet0 = new MonsterAnimationFrameSpritesheet(fileName0, spriteSize, this);
      this.animationFrameSpritesheet1 = new MonsterAnimationFrameSpritesheet(fileName1, spriteSize, this);
    }
    onSpritesheetLoaded() {
      if (this.animationFrameSpritesheet0.loaded && this.animationFrameSpritesheet1.loaded) {
        this.populateSpriteMap();
      }
    }
    /**
     * @returns {boolean}
     */
    isLoaded() {
      return this.animationFrameSpritesheet0.loaded && this.animationFrameSpritesheet1.loaded;
    }
    /**
     * @param {string} name
     * @returns {Sprite}
     */
    getSprite(name) {
      return this.spriteMap[name];
    }
    /**
     * @inheritdoc
     * @override
     */
    populateSpriteMap() {
      let row = 0;
      this.parseRow(row, [
        MonsterSpriteNames.AQUATIC_SNAKE_TAN_1,
        MonsterSpriteNames.AQUATIC_SNAKE_TAN_2,
        MonsterSpriteNames.AQUATIC_SNAKE_BLACK_1,
        MonsterSpriteNames.AQUATIC_SNAKE_BLACK_2,
        MonsterSpriteNames.AQUATIC_MONSTER,
        MonsterSpriteNames.AVIAN_BAT_BROWN_SMALL,
        MonsterSpriteNames.AVIAN_BAT_BROWN_LARGE,
        MonsterSpriteNames.AVIAN_BAT_BLACK_LARGE
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.AVIAN_BAT_BROWN_SMALL2,
        MonsterSpriteNames.AVIAN_BAT_BROWN_LARGE2,
        MonsterSpriteNames.DEMON_REPTILIAN_GREEN,
        MonsterSpriteNames.DEMON_REPTILIAN_WINGED,
        MonsterSpriteNames.DEMON_BROWN,
        MonsterSpriteNames.DEMON_BLOB,
        MonsterSpriteNames.DEMON_BLUE,
        MonsterSpriteNames.DEMON_BLUE_WINGED
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.DEMON_RED_GLOWING,
        MonsterSpriteNames.DEMON_RED_WINGED_1,
        MonsterSpriteNames.DEMON_RED_WINGED_2,
        MonsterSpriteNames.DEMON_RED_DARK_LARGE,
        MonsterSpriteNames.DEMON_RED_LARGE,
        MonsterSpriteNames.DEMON_RED_PALE_LARGE,
        MonsterSpriteNames.DEMON_BLUE_LARGE,
        MonsterSpriteNames.DEMON_BLUE_RED_LARGE
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.DEMON_GREEN_EYE_STOCKS,
        MonsterSpriteNames.DEMON_GREEN_EVIL_WINGED,
        MonsterSpriteNames.DEMON_RED_DARK_WHIP,
        MonsterSpriteNames.DEMON_RED_TINY_JUMPING,
        MonsterSpriteNames.DEMON_RED_SMALL_JUMPING,
        MonsterSpriteNames.DEMON_ARMORED,
        MonsterSpriteNames.DEMON_HELMET_HORNED,
        MonsterSpriteNames.DEMON_RED_FANGED
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.DEMON_GREEN_FROG_LIKE,
        MonsterSpriteNames.ELEMENTAL_WARRIOR,
        MonsterSpriteNames.ELEMENTAL_SQUID,
        MonsterSpriteNames.ELEMENTAL_GOLEM,
        MonsterSpriteNames.ELEMENTAL_GOLEM_DARK,
        MonsterSpriteNames.ELEMENTAL_GOLEM_RUSTY,
        MonsterSpriteNames.ELEMENTAL_BLOODY,
        MonsterSpriteNames.ELEMENTAL_STONE
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.ELEMENTAL_SWIRL_ORANGE,
        MonsterSpriteNames.ELEMENTAL_SWIRL_YELLOW,
        MonsterSpriteNames.ELEMENTAL_SWIRL_BLUE_DARK,
        MonsterSpriteNames.ELEMENTAL_SWIRL_BLUE_LIGHT,
        MonsterSpriteNames.ELEMENTAL_SWIRL_RED,
        MonsterSpriteNames.ELEMENTAL_CREEPY_RED,
        MonsterSpriteNames.ELEMENTAL_CREEPY_BROWN,
        MonsterSpriteNames.ELEMENTAL_CREEPY_LIGHT_BLUE
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.ELEMENTAL_BALL_GREEN,
        MonsterSpriteNames.ELEMENTAL_BALL_BLUE,
        MonsterSpriteNames.ELEMENTAL_BALL_RED,
        MonsterSpriteNames.ELEMENTAL_BALL_BLACK,
        MonsterSpriteNames.ELEMENTAL_EYE_WHITE,
        MonsterSpriteNames.ELEMENTAL_EYE_RED,
        MonsterSpriteNames.ELEMENTAL_EYE_BEHOLDER,
        MonsterSpriteNames.HUMANOID_210_SASQUATCH
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.HUMANOID_000,
        MonsterSpriteNames.HUMANOID_001,
        MonsterSpriteNames.HUMANOID_002,
        MonsterSpriteNames.HUMANOID_003,
        MonsterSpriteNames.HUMANOID_004,
        MonsterSpriteNames.HUMANOID_005,
        MonsterSpriteNames.HUMANOID_006,
        MonsterSpriteNames.HUMANOID_007
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.HUMANOID_010_MINOTAUR,
        MonsterSpriteNames.HUMANOID_011_CYCLOPS,
        MonsterSpriteNames.HUMANOID_040_WALRUS_MAN,
        MonsterSpriteNames.HUMANOID_041_WALRUS_MAN,
        MonsterSpriteNames.HUMANOID_042_WALRUS_MAN,
        MonsterSpriteNames.HUMANOID_043_WALRUS_MAN,
        MonsterSpriteNames.HUMANOID_044_WALRUS_MAN,
        MonsterSpriteNames.HUMANOID_045_WALRUS_MAN
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.HUMANOID_046_WALRUS_MAN,
        MonsterSpriteNames.HUMANOID_070,
        MonsterSpriteNames.HUMANOID_071,
        MonsterSpriteNames.HUMANOID_072,
        MonsterSpriteNames.HUMANOID_073,
        MonsterSpriteNames.HUMANOID_170_STONE_SERPENT,
        MonsterSpriteNames.HUMANOID_171_STONE_SERPENT,
        MonsterSpriteNames.MISC_ANIMAL_70
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.HUMANOID_190_DEMON_BASHER,
        MonsterSpriteNames.HUMANOID_191_DEMON_BASHER,
        MonsterSpriteNames.HUMANOID_200_SQUID_DEMON,
        MonsterSpriteNames.HUMANOID_201_SQUID_DEMON,
        MonsterSpriteNames.MISC_ANIMAL_03_OWL,
        MonsterSpriteNames.MISC_ANIMAL_04,
        MonsterSpriteNames.MISC_ANIMAL_05,
        MonsterSpriteNames.MISC_ANIMAL_06
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.MISC_ANIMAL_11,
        MonsterSpriteNames.MISC_ANIMAL_12,
        MonsterSpriteNames.MISC_ANIMAL_50,
        MonsterSpriteNames.MISC_ANIMAL_51,
        MonsterSpriteNames.MISC_ANIMAL_52,
        MonsterSpriteNames.MISC_ANIMAL_53,
        MonsterSpriteNames.PEST_LADYBUG_100,
        MonsterSpriteNames.PEST_LADYBUG_101
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.PEST_TINY_00,
        MonsterSpriteNames.PEST_TINY_01,
        MonsterSpriteNames.PEST_TINY_02,
        MonsterSpriteNames.PEST_TINY_03,
        MonsterSpriteNames.PEST_TINY_04,
        MonsterSpriteNames.PEST_TINY_05,
        MonsterSpriteNames.PEST_TINY_WORM_1,
        MonsterSpriteNames.PEST_TINY_WORM_2
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.PEST_ANT_10,
        MonsterSpriteNames.PEST_INSECT_11,
        MonsterSpriteNames.PEST_INSECT_12,
        MonsterSpriteNames.PEST_INSECT_13,
        MonsterSpriteNames.PEST_INSECT_14,
        MonsterSpriteNames.PEST_SPIDER_20,
        MonsterSpriteNames.PEST_SPIDER_21,
        MonsterSpriteNames.PEST_SPIDER_22
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.PEST_SCORPION_23,
        MonsterSpriteNames.PEST_SCORPION_24,
        MonsterSpriteNames.PEST_SCORPION_25,
        MonsterSpriteNames.PEST_WORM_30,
        MonsterSpriteNames.PEST_WORM_31,
        MonsterSpriteNames.PEST_BALL,
        MonsterSpriteNames.PEST_WORM_33,
        MonsterSpriteNames.PEST_WORM_34
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.PEST_GIANT_ANT_40,
        MonsterSpriteNames.PEST_GIANT_ANT_41,
        MonsterSpriteNames.PEST_GIANT_ANT_42,
        MonsterSpriteNames.PEST_GIANT_ANT_43,
        MonsterSpriteNames.PEST_SLUG_70,
        MonsterSpriteNames.PEST_SLUG_71,
        MonsterSpriteNames.PEST_SNAIL_72,
        MonsterSpriteNames.PEST_SNAIL_73
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.PEST_INSECT_60,
        MonsterSpriteNames.PEST_INSECT_61,
        MonsterSpriteNames.PEST_INSECT_80,
        MonsterSpriteNames.PEST_INSECT_81,
        MonsterSpriteNames.MINOR_DEVIL,
        MonsterSpriteNames.MINOR_DEVIL_WARRIOR
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.ORC1,
        MonsterSpriteNames.ORC_WARRIOR,
        MonsterSpriteNames.ORC_FIGHTER,
        MonsterSpriteNames.ORC_KARATE,
        MonsterSpriteNames.ORC_PIRATE,
        MonsterSpriteNames.ORC2,
        MonsterSpriteNames.ORC3,
        MonsterSpriteNames.ORC4
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.DRAGON_MAN_BASIC,
        MonsterSpriteNames.DRAGON_MAN_EXPLORER,
        MonsterSpriteNames.DRAGON_MAN_FIGHTER,
        MonsterSpriteNames.DRAGON_MAN_RUFFIAN,
        MonsterSpriteNames.DRAGON_MAN_RANGER,
        MonsterSpriteNames.DRAGON_MAN_TERRIBLE,
        MonsterSpriteNames.DRAGON_MAN_MERCILESS,
        MonsterSpriteNames.DRAGON_MAN_FIERY
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.QUADRUPED_000,
        MonsterSpriteNames.QUADRUPED_001,
        MonsterSpriteNames.QUADRUPED_002,
        MonsterSpriteNames.QUADRUPED_003,
        MonsterSpriteNames.QUADRUPED_004,
        MonsterSpriteNames.QUADRUPED_005,
        MonsterSpriteNames.QUADRUPED_006,
        MonsterSpriteNames.QUADRUPED_007
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.RODENT_10_RAT_SMALL,
        MonsterSpriteNames.RODENT_11_RAT,
        MonsterSpriteNames.RODENT_12_RAT_LARGE_BROWN,
        MonsterSpriteNames.RODENT_13_RAT_LARGE_GREY,
        MonsterSpriteNames.RODENT_20_RAT_POISONOUS,
        MonsterSpriteNames.RODENT_21_RAT_ZOMBIE,
        MonsterSpriteNames.RODENT_22_MOLE
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.SLIME_BLUE_00,
        MonsterSpriteNames.SLIME_BROWN_01,
        MonsterSpriteNames.SLIME_WHITE_02,
        MonsterSpriteNames.SLIME_GREEN_03,
        MonsterSpriteNames.SLIME_PINK_04,
        MonsterSpriteNames.SLIME_PURPLE_05,
        MonsterSpriteNames.SLIME_MUCUS_GREEN_40,
        MonsterSpriteNames.SLIME_MUCUS_BLUE_41
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.SLIME_CORRODED_20,
        MonsterSpriteNames.SLIME_SEEING_21,
        MonsterSpriteNames.SLIME_ORANGE_22,
        MonsterSpriteNames.SLIME_MINI_BLUE_30,
        MonsterSpriteNames.SLIME_MINI_31,
        MonsterSpriteNames.SLIME_MINI_ORANGE_32,
        MonsterSpriteNames.UNDEAD_WRAITH_0600,
        MonsterSpriteNames.UNDEAD_WRAITH_0601
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.UNDEAD_GOBLIN0,
        MonsterSpriteNames.UNDEAD_GOBLIN1,
        MonsterSpriteNames.UNDEAD_GOBLIN2,
        MonsterSpriteNames.UNDEAD_GOBLIN3,
        MonsterSpriteNames.UNDEAD_GOBLIN4,
        MonsterSpriteNames.UNDEAD_GOBLIN5,
        MonsterSpriteNames.UNDEAD_GOBLIN6,
        MonsterSpriteNames.UNDEAD_GOBLIN7
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.UNDEAD_KOBOLD_SKELETON_0200,
        MonsterSpriteNames.UNDEAD_KOBOLD_SKELETON_0201,
        MonsterSpriteNames.UNDEAD_KOBOLD_SKELETON_0202,
        MonsterSpriteNames.UNDEAD_KOBOLD_SKELETON_0203,
        MonsterSpriteNames.UNDEAD_KOBOLD4,
        MonsterSpriteNames.UNDEAD_KOBOLD5,
        MonsterSpriteNames.UNDEAD_KOBOLD_KING_0206,
        MonsterSpriteNames.UNDEAD_KOBOLD_ANCIENT_EVIL7
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.UNDEAD_GHOST_0400,
        MonsterSpriteNames.UNDEAD_GHOST_0401,
        MonsterSpriteNames.UNDEAD_GHOST_0402,
        MonsterSpriteNames.UNDEAD_GHOST_0403,
        MonsterSpriteNames.UNDEAD_REAPER_0500,
        MonsterSpriteNames.UNDEAD_REAPER_0501,
        MonsterSpriteNames.UNDEAD_REAPER_0502,
        MonsterSpriteNames.UNDEAD_DARKNESS_0801
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.REPTILE_FLYING_SERPENT_SMALL_002,
        MonsterSpriteNames.REPTILE_FLYING_SERPENT_003
      ]);
      row++;
      this.parseRow(row, [
        MonsterSpriteNames.REPTILE_BROWN_SERPENT_SMALL_040,
        MonsterSpriteNames.REPTILE_BROWN_SERPENT_041,
        MonsterSpriteNames.REPTILE_BROWN_SERPENT_LARGE_042,
        MonsterSpriteNames.REPTILE_BLACK_SERPENT_043,
        MonsterSpriteNames.REPTILE_BLACK_SERPENT_LARGE_044,
        MonsterSpriteNames.REPTILE_BLACK_SERPENT_POISONOUS_045,
        MonsterSpriteNames.REPTILE_GREEN_SNAKE_SMALL_046,
        MonsterSpriteNames.REPTILE_GREEN_SNAKE_047
      ]);
      row++;
      this.loaded = true;
    }
    /**
     * @private
     * @param {number} row 
     * @param {Array.<string>} names
     */
    parseRow(row, names) {
      const step = this.spriteSize + 1;
      const y = row * step;
      let x = 0;
      for (let i = 0; i < +names.length; i++) {
        this.spriteMap[names[i]] = new DawnLikeSprite(this.spriteAnimationManager, this.animationFrameSpritesheet0, this.animationFrameSpritesheet1, x, y);
        x += step;
      }
    }
  };

  // src/model/sprite/OreSpriteOverlay.js
  var OreSpriteOverlay = class {
    constructor() {
      this.oreSpriteLists = [];
    }
    /**
     * 
     * @param {Sprite[]} oreSprites 
     */
    addSeries(oreSprites) {
      this.oreSpriteLists.push(oreSprites);
    }
    /**
     * 
     * @param {GridTile} tile 
     * @returns {Sprite}
     */
    getOreSprite(tile) {
      if (!tile || tile.open) {
        return null;
      }
      if (tile.tileType.rarityModifier !== TileTypeRarity.ORE) {
        return null;
      }
      const row = tile.getTileRow();
      const worldRows = 1e4;
      const ratio = Math.min(0.999, row / worldRows);
      const listIndex = this.oreSpriteLists.length * ratio | 0;
      const spriteList = this.oreSpriteLists[listIndex];
      return spriteList[tile.hash() % spriteList.length];
    }
  };

  // src/model/sprite/TileDamageSpriteSeries.js
  var TileDamageSpriteSeries = class {
    /**
     * 
     * @param {Sprite[]} sprites 
     */
    constructor(sprites) {
      this.sprites = sprites;
      this.step = 100 / sprites.length;
    }
    /**
     * @param {number} healthPercent
     * @returns {Sprite}
     */
    getDamageSprite(healthPercent) {
      if (healthPercent >= 100) {
        return null;
      }
      const idx = this.sprites.length - 1 - healthPercent / this.step | 0;
      if (idx >= this.sprites.length || idx < 0) {
        console.log("getDamageSprite() bad index calculated. healthPercent=" + healthPercent + " idx=" + idx);
        return null;
      }
      return this.sprites[idx];
    }
  };

  // src/model/sprite/TileDamageSpriteOverlay.js
  var TileDamageSpriteOverlay = class {
    constructor() {
      this.spriteSeries = [];
    }
    /**
     * @param {TileDamageSpriteSeries} spriteSeries 
     */
    add(spriteSeries) {
      this.spriteSeries.push(spriteSeries);
    }
    /**
     * 
     * @param {GridTile} tile 
     * @returns {Sprite}
     */
    getDamageSprite(tile) {
      if (!tile || tile.open) {
        return null;
      }
      const healthPercent = tile.healthPercent;
      if (healthPercent === 100) {
        return null;
      }
      const index = Math.abs(tile.hash() % this.spriteSeries.length);
      return this.spriteSeries[index].getDamageSprite(healthPercent);
    }
  };

  // src/model/sprite/TileOverlaySpritesheet.js
  var TileOverlaySpritesheet = class extends AnimationRowSpritesheet {
    /**
     * @param {string} fileName 
     * @param {number} spriteSize 
     * @param {SpriteAnimationManager} spriteAnimationManager
     * @param {TileDamageSpriteOverlay} tileDamageSpriteOverlay
     * @param {OreSpriteOverlay} oreSpriteOverlay
     */
    constructor(fileName, spriteSize, spriteAnimationManager, tileDamageSpriteOverlay, oreSpriteOverlay) {
      super(fileName, spriteSize);
      this.upgradeSpriteOverlay = null;
      this.spriteAnimationManager = spriteAnimationManager;
      this.tileDamageSpriteOverlay = tileDamageSpriteOverlay;
      this.oreSpriteOverlay = oreSpriteOverlay;
      this.loadImage();
    }
    /**
     * @override
     * @param {number} spriteSize
     * @returns {number}
     */
    calculateSpriteStep(spriteSize) {
      return spriteSize + 1;
    }
    /**
     * @inheritdoc
     * @override
     */
    populateSpriteMap() {
      const upgradeSprites = this.parseRow(0, 2);
      this.upgradeSpriteOverlay = new SpriteAnimation(upgradeSprites, this.spriteAnimationManager, false, true);
      const crackSprites0 = this.parseRow(1, 8);
      const damageSpriteSeries0 = new TileDamageSpriteSeries(crackSprites0);
      this.tileDamageSpriteOverlay.add(damageSpriteSeries0);
      const crackSprites1 = this.parseRow(2, 8);
      const damageSpriteSeries1 = new TileDamageSpriteSeries(crackSprites1);
      this.tileDamageSpriteOverlay.add(damageSpriteSeries1);
      const crackSprites2 = this.parseRow(3, 8);
      const damageSpriteSeries2 = new TileDamageSpriteSeries(crackSprites2);
      this.tileDamageSpriteOverlay.add(damageSpriteSeries2);
      this.oreSpriteOverlay.addSeries(this.parseRow(5, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(6, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(7, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(8, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(9, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(10, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(11, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(12, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(13, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(14, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(15, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(16, 8));
      this.oreSpriteOverlay.addSeries(this.parseRow(17, 8));
      this.loaded = true;
    }
  };

  // src/model/sprite/GervaisSpriteAnimation.js
  var GervaisSpriteAnimation = class extends SpriteAnimation {
    /**
     * @param {Array.<Sprite>} sprites
     * @param {SpriteAnimationManager} spriteAnimationManager
     * @param {boolean} fastAnimation
     * @param {boolean} loopingAnimation
     */
    constructor(sprites, spriteAnimationManager, fastAnimation, superFastAnimation, directional) {
      super(sprites, spriteAnimationManager, fastAnimation, true);
      this.directionalSprite = directional;
      this.superFastAnimation = superFastAnimation;
    }
    // /**
    //  * @override
    //  * @returns {Sprite}
    //  */
    // getSprite() {
    //     const frameIndex = this.fastAnimation
    //             ? this.spriteAnimationManager.getFastFrameIndex(0, this.sprites.length) // <-- this takes 4 parameters!
    //             : this.spriteAnimationManager.getFrameIndex(0, this.sprites.length);  // <-- this takes 4 parameters!
    //     return this.sprites.get(frameIndex);
    // }
    /**
     * @override
     * @param {number} currentTime 
     * @param {number} startTime 
     * @returns {Sprite}
     */
    getSpriteAsOf(currentTime, startTime) {
      if (this.fastAnimation) {
        return this.getFastCurrentSpriteAsOf(currentTime, startTime);
      } else if (this.superFastAnimation) {
        return this.getSuperFastCurrentSpriteAsOf(currentTime, startTime);
      } else {
        return this.getCurrentSpriteAsOf(currentTime, startTime);
      }
    }
    /**
     * @param {number} startTime 
     * @returns {boolean}
     */
    isAnimationLoopCompleted(startTime) {
      if (this.directionalSprite) {
        return false;
      }
      if (this.fastAnimation) {
        return this.spriteAnimationManager.isFastAnimationLoopCompleted(Date.now(), startTime, this.sprites.length);
      } else if (this.superFastAnimation) {
        return this.spriteAnimationManager.isSuperFastAnimationLoopCompleted(Date.now(), startTime, this.sprites.length);
      } else {
        return this.spriteAnimationManager.isDefaultAnimationLoopCompleted(Date.now(), startTime, this.sprites.length);
      }
    }
    /**
     * @override
     * @returns {boolean}
     */
    isDirectionalSprite() {
      return this.directionalSprite;
    }
  };

  // src/model/sprite/GervaisAnimatedSpritesheet.js
  var GervaisAnimatedSpritesheet = class extends Spritesheet {
    /**
     * @param {string} fileName 
     * @param {number} spriteSize 
     * @param {Array.<Object>} spritesheetMetadata
     * @param {number} sheetEndCol
     * @param {SpriteAnimationManager} spriteAnimationManager
     */
    constructor(fileName, spriteSize, spritesheetMetadata, sheetEndCol, spriteAnimationManager) {
      super(fileName, spriteSize);
      this.sheetEndCol = sheetEndCol;
      this.spritesheetMetadata = spritesheetMetadata;
      this.spriteAnimationManager = spriteAnimationManager;
      this.spriteMap = {};
      this.loadImage();
    }
    /**
     * @inheritdoc
     * @override
     */
    populateSpriteMap() {
      for (let i = 0; i < this.spritesheetMetadata.length; i++) {
        const datum = this.spritesheetMetadata[i];
        const spriteAnimation = this.loadSpriteAnimation(datum);
        this.spriteMap[datum.animationName] = spriteAnimation;
      }
      this.loaded = true;
    }
    /**
     * @private
     * @param {Object} datum 
     * @returns {SpriteAnimation}
     */
    loadSpriteAnimation(datum) {
      const directionalSprite = Object.hasOwn(datum, "directional") ? datum.directional : false;
      const fastAnimation = Object.hasOwn(datum, "fastAnimation") ? datum.fastAnimation : false;
      const superFastAnimation = Object.hasOwn(datum, "superFastAnimation") ? datum.superFastAnimation : false;
      const spriteFrames = this.createSpriteFrames(datum);
      return new GervaisSpriteAnimation(spriteFrames, this.spriteAnimationManager, fastAnimation, superFastAnimation, directionalSprite);
    }
    /**
     * @private
     * @returns {Array.<Sprite>} 
     */
    createSpriteFrames(datum) {
      const frames = [];
      const startRow = datum.startRow;
      const endRow = datum.endRow;
      const startCol = datum.startCol;
      const endCol = datum.endCol;
      const spriteSize = this.spriteSize;
      for (let row = startRow; row <= endRow; row++) {
        const spriteFrameY = row * spriteSize;
        let endColumn;
        if (row < endRow) {
          endColumn = this.sheetEndCol;
        } else {
          endColumn = Math.min(endCol, this.sheetEndCol);
        }
        for (let col = startCol; col <= endColumn; col++) {
          const spriteFrameX = col * spriteSize;
          frames.push(new BasicSprite(this, spriteFrameX, spriteFrameY));
        }
      }
      return frames;
    }
    /**
     * @param {string} name 
     * @returns {GervaisSpriteAnimation}
     */
    getSpriteAnimation(name) {
      return this.spriteMap[name];
    }
  };

  // src/model/sprite/SpellFXMetadata.js
  var SpellFXMetadata = [
    {
      "animationName": "Red Arrow",
      "startCol": 0,
      "startRow": 0,
      "endCol": 7,
      "endRow": 0,
      "directional": true
    },
    {
      "animationName": "Green Arrow",
      "startCol": 0,
      "startRow": 1,
      "endCol": 7,
      "endRow": 1,
      "directional": true
    },
    {
      "animationName": "Pink Arrow",
      "startCol": 0,
      "startRow": 2,
      "endCol": 7,
      "endRow": 2,
      "directional": true
    },
    {
      "animationName": "Pink Lightning",
      "startCol": 0,
      "startRow": 3,
      "endCol": 7,
      "endRow": 3,
      "directional": true
    },
    {
      "animationName": "Green Projectile",
      "startCol": 0,
      "startRow": 4,
      "endCol": 7,
      "endRow": 4,
      "directional": true
    },
    {
      "animationName": "Small Green Projectiles",
      "startCol": 0,
      "startRow": 5,
      "endCol": 7,
      "endRow": 5,
      "directional": true
    },
    {
      "animationName": "Fire Projectile",
      "startCol": 0,
      "startRow": 6,
      "endCol": 7,
      "endRow": 6,
      "directional": true
    },
    {
      "animationName": "Fire Arrow",
      "startCol": 0,
      "startRow": 7,
      "endCol": 7,
      "endRow": 7,
      "directional": true
    },
    {
      "animationName": "Ice Projectile",
      "startCol": 0,
      "startRow": 8,
      "endCol": 7,
      "endRow": 8,
      "directional": true
    },
    {
      "animationName": "Ice Arrow",
      "startCol": 0,
      "startRow": 9,
      "endCol": 7,
      "endRow": 9,
      "directional": true
    },
    {
      "animationName": "Lightning",
      "startCol": 0,
      "startRow": 10,
      "endCol": 7,
      "endRow": 10,
      "directional": true
    },
    {
      "animationName": "Lightning Arrow",
      "startCol": 0,
      "startRow": 11,
      "endCol": 7,
      "endRow": 11,
      "directional": true
    },
    {
      "animationName": "Grey Bullet",
      "startCol": 0,
      "startRow": 12,
      "endCol": 7,
      "endRow": 12,
      "directional": true
    },
    {
      "animationName": "Yellow Bullet",
      "startCol": 0,
      "startRow": 13,
      "endCol": 7,
      "endRow": 13,
      "directional": true
    },
    {
      "animationName": "Ninja Star",
      "startCol": 0,
      "startRow": 14,
      "endCol": 7,
      "endRow": 14,
      "directional": true
    },
    {
      "animationName": "Pink Star Projectile",
      "startCol": 0,
      "startRow": 15,
      "endCol": 7,
      "endRow": 15,
      "directional": true
    },
    {
      "animationName": "Web",
      "startCol": 0,
      "startRow": 16,
      "endCol": 7,
      "endRow": 16,
      "directional": true
    },
    {
      "animationName": "Pink Ball Projectile",
      "startCol": 0,
      "startRow": 17,
      "endCol": 7,
      "endRow": 17,
      "directional": true
    },
    {
      "animationName": "Yellow Star Projectile",
      "startCol": 0,
      "startRow": 18,
      "endCol": 7,
      "endRow": 18,
      "directional": false
    },
    {
      "animationName": "Gold Sparkles",
      "startCol": 0,
      "startRow": 19,
      "endCol": 7,
      "endRow": 19
    },
    {
      "animationName": "Green Sparkles",
      "startCol": 0,
      "startRow": 20,
      "endCol": 7,
      "endRow": 20
    },
    {
      "animationName": "Blue Sparkles",
      "startCol": 0,
      "startRow": 21,
      "endCol": 7,
      "endRow": 21
    },
    {
      "animationName": "Orange Sparkles",
      "startCol": 0,
      "startRow": 22,
      "endCol": 7,
      "endRow": 22
    },
    {
      "animationName": "Pink Sparkles",
      "startCol": 0,
      "startRow": 23,
      "endCol": 7,
      "endRow": 23
    },
    {
      "animationName": "Red Sparkles",
      "startCol": 0,
      "startRow": 24,
      "endCol": 7,
      "endRow": 24
    },
    {
      "animationName": "Green Skull",
      "startCol": 0,
      "startRow": 25,
      "endCol": 7,
      "endRow": 25
    },
    {
      "animationName": "Yellow Key",
      "startCol": 0,
      "startRow": 26,
      "endCol": 7,
      "endRow": 26
    },
    {
      "animationName": "Skull Cross",
      "startCol": 0,
      "startRow": 27,
      "endCol": 7,
      "endRow": 27
    },
    {
      "animationName": "Shields",
      "startCol": 0,
      "startRow": 28,
      "endCol": 7,
      "endRow": 28
    },
    {
      "animationName": "Red Crosses",
      "startCol": 0,
      "startRow": 29,
      "endCol": 7,
      "endRow": 29
    },
    {
      "animationName": "Fire Ring",
      "startCol": 0,
      "startRow": 30,
      "endCol": 7,
      "endRow": 30
    },
    {
      "animationName": "Ice Ring",
      "startCol": 0,
      "startRow": 31,
      "endCol": 7,
      "endRow": 31
    },
    {
      "animationName": "Green Ring",
      "startCol": 0,
      "startRow": 32,
      "endCol": 7,
      "endRow": 32
    },
    {
      "animationName": "Pink Ring",
      "startCol": 0,
      "startRow": 33,
      "endCol": 7,
      "endRow": 33
    },
    {
      "animationName": "Yellow Star",
      "startCol": 0,
      "startRow": 34,
      "endCol": 7,
      "endRow": 34
    },
    {
      "animationName": "Blue Star",
      "startCol": 0,
      "startRow": 35,
      "endCol": 7,
      "endRow": 35
    },
    {
      "animationName": "Green Star",
      "startCol": 0,
      "startRow": 36,
      "endCol": 7,
      "endRow": 36
    },
    {
      "animationName": "White Crosses",
      "startCol": 0,
      "startRow": 37,
      "endCol": 7,
      "endRow": 37
    },
    {
      "animationName": "Spider Web",
      "startCol": 0,
      "startRow": 38,
      "endCol": 7,
      "endRow": 38
    },
    {
      "animationName": "Torch",
      "startCol": 0,
      "startRow": 39,
      "endCol": 7,
      "endRow": 39
    },
    {
      "animationName": "Frost",
      "startCol": 0,
      "startRow": 40,
      "endCol": 7,
      "endRow": 41,
      "fastAnimation": true
    },
    {
      "animationName": "Yellow Star Circle",
      "startCol": 0,
      "startRow": 42,
      "endCol": 6,
      "endRow": 43
    },
    {
      "animationName": "Circles",
      "startCol": 0,
      "startRow": 44,
      "endCol": 4,
      "endRow": 45
    },
    {
      "animationName": "Gold Shield Spiral",
      "startCol": 0,
      "startRow": 46,
      "endCol": 7,
      "endRow": 47,
      "fastAnimation": true
    },
    {
      "animationName": "Green Shield Spiral",
      "startCol": 0,
      "startRow": 48,
      "endCol": 7,
      "endRow": 49,
      "fastAnimation": true
    },
    {
      "animationName": "Blue Shield Spiral",
      "startCol": 0,
      "startRow": 50,
      "endCol": 7,
      "endRow": 51,
      "fastAnimation": true
    },
    {
      "animationName": "Pink Shield Spiral",
      "startCol": 0,
      "startRow": 52,
      "endCol": 7,
      "endRow": 53,
      "fastAnimation": true
    },
    {
      "animationName": "Blue Firework",
      "startCol": 0,
      "startRow": 54,
      "endCol": 7,
      "endRow": 55,
      "fastAnimation": true
    },
    {
      "animationName": "Red Firework",
      "startCol": 0,
      "startRow": 56,
      "endCol": 7,
      "endRow": 57,
      "fastAnimation": true
    },
    {
      "animationName": "Bubbles",
      "startCol": 0,
      "startRow": 58,
      "endCol": 2,
      "endRow": 60,
      "fastAnimation": true
    },
    {
      "animationName": "Shield",
      "startCol": 0,
      "startRow": 61,
      "endCol": 7,
      "endRow": 62,
      "fastAnimation": true
    },
    {
      "animationName": "Color Spiral",
      "startCol": 0,
      "startRow": 63,
      "endCol": 7,
      "endRow": 64
    },
    {
      "animationName": "Arm Flex",
      "startCol": 0,
      "startRow": 65,
      "endCol": 4,
      "endRow": 66,
      "fastAnimation": true
    },
    {
      "animationName": "Super Speed",
      "startCol": 0,
      "startRow": 67,
      "endCol": 7,
      "endRow": 68,
      "fastAnimation": true
    },
    {
      "animationName": "Target",
      "startCol": 0,
      "startRow": 69,
      "endCol": 7,
      "endRow": 70,
      "fastAnimation": true
    },
    {
      "animationName": "Yellow Shield Spiral",
      "startCol": 0,
      "startRow": 71,
      "endCol": 6,
      "endRow": 72,
      "fastAnimation": true
    },
    {
      "animationName": "Pink Star Circle",
      "startCol": 0,
      "startRow": 73,
      "endCol": 6,
      "endRow": 74
    },
    {
      "animationName": "Blue Star Circle",
      "startCol": 0,
      "startRow": 75,
      "endCol": 6,
      "endRow": 76
    },
    {
      "animationName": "Green Star Circle",
      "startCol": 0,
      "startRow": 77,
      "endCol": 6,
      "endRow": 78
    },
    {
      "animationName": "Gold Star Circle",
      "startCol": 0,
      "startRow": 79,
      "endCol": 6,
      "endRow": 80
    },
    {
      "animationName": "Bread",
      "startCol": 0,
      "startRow": 81,
      "endCol": 7,
      "endRow": 81
    },
    {
      "animationName": "Yellow Fire Ring",
      "startCol": 0,
      "startRow": 82,
      "endCol": 7,
      "endRow": 82
    },
    {
      "animationName": "Totems",
      "startCol": 0,
      "startRow": 83,
      "endCol": 7,
      "endRow": 83
    },
    {
      "animationName": "Eye Blink",
      "startCol": 0,
      "startRow": 84,
      "endCol": 7,
      "endRow": 84
    },
    {
      "animationName": "Pink Star",
      "startCol": 0,
      "startRow": 85,
      "endCol": 7,
      "endRow": 85
    },
    {
      "animationName": "Orange Star",
      "startCol": 0,
      "startRow": 86,
      "endCol": 7,
      "endRow": 86
    },
    {
      "animationName": "Red Eye Blink",
      "startCol": 0,
      "startRow": 87,
      "endCol": 6,
      "endRow": 88
    },
    {
      "animationName": "Eagle",
      "startCol": 0,
      "startRow": 89,
      "endCol": 7,
      "endRow": 89
    },
    {
      "animationName": "Sleep",
      "startCol": 0,
      "startRow": 90,
      "endCol": 6,
      "endRow": 91
    },
    {
      "animationName": "Armor",
      "startCol": 0,
      "startRow": 92,
      "endCol": 7,
      "endRow": 92
    },
    {
      "animationName": "Blind Eye Blink",
      "startCol": 0,
      "startRow": 93,
      "endCol": 7,
      "endRow": 93
    },
    {
      "animationName": "Fire Rain",
      "startCol": 0,
      "startRow": 94,
      "endCol": 7,
      "endRow": 96,
      "fastAnimation": true
    },
    {
      "animationName": "Blue Rain",
      "startCol": 0,
      "startRow": 97,
      "endCol": 7,
      "endRow": 99,
      "fastAnimation": true
    },
    {
      "animationName": "Green Rain",
      "startCol": 0,
      "startRow": 100,
      "endCol": 7,
      "endRow": 102,
      "fastAnimation": true
    },
    {
      "animationName": "Lightning Rain",
      "startCol": 0,
      "startRow": 103,
      "endCol": 7,
      "endRow": 105,
      "fastAnimation": true
    },
    {
      "animationName": "Pink Rain",
      "startCol": 0,
      "startRow": 106,
      "endCol": 7,
      "endRow": 108,
      "fastAnimation": true
    },
    {
      "animationName": "Rainbow Rain",
      "startCol": 0,
      "startRow": 109,
      "endCol": 7,
      "endRow": 111,
      "fastAnimation": true
    },
    {
      "animationName": "Spear",
      "startCol": 0,
      "startRow": 112,
      "endCol": 7,
      "endRow": 112,
      "directional": true,
      "customScale": 1.5
    },
    {
      "animationName": "Red Damage",
      "startCol": 0,
      "startRow": 113,
      "endCol": 2,
      "endRow": 113
    },
    {
      "animationName": "White Damage",
      "startCol": 0,
      "startRow": 114,
      "endCol": 2,
      "endRow": 114
    },
    {
      "animationName": "Blue Damage",
      "startCol": 0,
      "startRow": 115,
      "endCol": 2,
      "endRow": 115
    },
    {
      "animationName": "Green Damage",
      "startCol": 0,
      "startRow": 116,
      "endCol": 2,
      "endRow": 116
    },
    {
      "animationName": "Red Splat",
      "startCol": 0,
      "startRow": 117,
      "endCol": 2,
      "endRow": 117
    },
    {
      "animationName": "Electric Damage",
      "startCol": 0,
      "startRow": 118,
      "endCol": 2,
      "endRow": 118
    },
    {
      "animationName": "Fire Damage",
      "startCol": 0,
      "startRow": 119,
      "endCol": 2,
      "endRow": 119
    },
    {
      "animationName": "Poison Damage",
      "startCol": 0,
      "startRow": 120,
      "endCol": 2,
      "endRow": 120
    },
    {
      "animationName": "Sonic Damage",
      "startCol": 0,
      "startRow": 121,
      "endCol": 2,
      "endRow": 121
    },
    {
      "animationName": "Pink Damage",
      "startCol": 0,
      "startRow": 122,
      "endCol": 2,
      "endRow": 122
    },
    {
      "animationName": "Fat Red Arrow",
      "startCol": 0,
      "startRow": 123,
      "endCol": 7,
      "endRow": 123,
      "directional": true
    },
    {
      "animationName": "Wall Arrow",
      "startCol": 0,
      "startRow": 124,
      "endCol": 7,
      "endRow": 124,
      "directional": true
    }
  ];

  // src/model/sprite/Sprites.js
  var Sprites = class {
    /**
     */
    constructor() {
      this.spriteAnimationManager = new SpriteAnimationManager();
      this.tileDamageSpriteOverlay = new TileDamageSpriteOverlay();
      this.oreSpriteOverlay = new OreSpriteOverlay();
      this.loaded = false;
      this.tileSpritesheet = new TileSpritesheet("spritesheet/tile_spritesheet.png", Settings.tile.size);
      this.tileTypeBackgroundSpritesheet = new TileTypeBackgroundSpritesheet("spritesheet/tile_type_background.png", Settings.tile.size);
      this.characterSpritesheet = new CharacterSpritesheet("spritesheet/character_spritesheet.png", Settings.tile.size, this.spriteAnimationManager);
      this.itemOverlaySpritesheet = new ItemOverlaySpritesheet("spritesheet/item_overlay_spritesheet.png", Settings.tile.size * 3, this.spriteAnimationManager);
      this.staticFixtureSpritesheet = new StaticFixtureSpritesheet("spritesheet/static_fixture_spritesheet.png", Settings.tile.size);
      this.monsterSpritesheet = new MonsterSpritesheet("spritesheet/monsters0.png", "spritesheet/monsters1.png", Settings.tile.size, this.spriteAnimationManager);
      this.tileSpriteOverlaySpritesheet = new TileOverlaySpritesheet(
        "spritesheet/tile_overlay.png",
        Settings.tile.size,
        this.spriteAnimationManager,
        this.tileDamageSpriteOverlay,
        this.oreSpriteOverlay
      );
      this.spellFxSpritesheet = new GervaisAnimatedSpritesheet("spritesheet/SpellFX.png", 31, SpellFXMetadata, 7, this.spriteAnimationManager);
    }
    /**
     * @returns {boolean}
     */
    isInitialized() {
      if (!this.loaded) {
        this.loaded = this.tileSpritesheet.loaded && this.tileTypeBackgroundSpritesheet.loaded && this.characterSpritesheet.loaded && this.itemOverlaySpritesheet.loaded && this.staticFixtureSpritesheet.loaded && this.monsterSpritesheet.isLoaded() && this.tileSpriteOverlaySpritesheet.loaded && this.spellFxSpritesheet.loaded;
      }
      return this.loaded;
    }
  };

  // src/model/grid/TileBorderCode.js
  var TileBorderCode = {
    /**
     * The tile is completely surrounded by closed tiles.
     * @constant
     * @type {number}
     */
    NO_OPEN_BORDERS: 0,
    /**
     * @constant
     * @type {number}
     */
    NORTH_BORDER_OPEN: 1,
    // PRIMARY
    /**
     * @constant
     * @type {number}
     */
    SOUTH_BORDER_OPEN: 2,
    // PRIMARY
    /**
     * @constant
     * @type {number}
     */
    NORTH_SOUTH_OPEN: 3,
    /**
     * @constant
     * @type {number}
     */
    WEST_BORDER_OPEN: 4,
    // PRIMARY
    /**
     * @constant
     * @type {number}
     */
    NORTH_WEST_OPEN: 5,
    /**
     * @constant
     * @type {number}
     */
    SOUTH_WEST_OPEN: 6,
    /**
     * @constant
     * @type {number}
     */
    NORTH_SOUTH_WEST_OPEN: 7,
    /**
     * @constant
     * @type {number}
     */
    EAST_BORDER_OPEN: 8,
    // PRIMARY
    /**
     * @constant
     * @type {number}
     */
    NORTH_EAST_OPEN: 9,
    /**
     * @constant
     * @type {number}
     */
    SOUTH_EAST_OPEN: 10,
    /**
     * @constant
     * @type {number}
     */
    NORTH_SOUTH_EAST_OPEN: 11,
    /**
     * @constant
     * @type {number}
     */
    WEST_EAST_OPEN: 12,
    /**
     * @constant
     * @type {number}
     */
    NORTH_WEST_EAST: 13,
    /**
     * @constant
     * @type {number}
     */
    SOUTH_WEST_EAST: 14,
    /**
     * The tile is completely surrounded by open tiles.
     * @constant
     * @type {number}
     */
    ALL_BORDERS_OPEN: 15
  };

  // src/model/grid/TileTemplate.js
  var TileTemplate = class {
    constructor() {
      this.northBorder = null;
      this.eastBorder = null;
      this.southBorder = null;
      this.westBorder = null;
      this.northEastBorder = null;
      this.northSouthBorder = null;
      this.northWestBorder = null;
      this.southEastBorder = null;
      this.eastWestBorder = null;
      this.southWestBorder = null;
      this.northEastSouthBorder = null;
      this.northSouthWestBorder = null;
      this.northEastWestBorder = null;
      this.eastWestSouthBorder = null;
      this.northEastSouthWestBorder = null;
      this.noBorder = null;
    }
    /**
     * @param {number} borderCode 
     * @returns {Sprite}
     */
    getTileSprite(borderCode) {
      switch (borderCode) {
        case TileBorderCode.NO_OPEN_BORDERS:
          return this.noBorder;
        case TileBorderCode.NORTH_BORDER_OPEN:
          return this.northBorder;
        case TileBorderCode.SOUTH_BORDER_OPEN:
          return this.southBorder;
        case TileBorderCode.NORTH_SOUTH_OPEN:
          return this.northSouthBorder;
        case TileBorderCode.WEST_BORDER_OPEN:
          return this.westBorder;
        case TileBorderCode.NORTH_WEST_OPEN:
          return this.northWestBorder;
        case TileBorderCode.SOUTH_WEST_OPEN:
          return this.southWestBorder;
        case TileBorderCode.NORTH_SOUTH_WEST_OPEN:
          return this.northSouthWestBorder;
        case TileBorderCode.EAST_BORDER_OPEN:
          return this.eastBorder;
        case TileBorderCode.NORTH_EAST_OPEN:
          return this.northEastBorder;
        case TileBorderCode.SOUTH_EAST_OPEN:
          return this.southEastBorder;
        case TileBorderCode.NORTH_SOUTH_EAST_OPEN:
          return this.northEastSouthBorder;
        case TileBorderCode.WEST_EAST_OPEN:
          return this.eastWestBorder;
        case TileBorderCode.NORTH_WEST_EAST:
          return this.northEastWestBorder;
        case TileBorderCode.SOUTH_WEST_EAST:
          return this.eastWestSouthBorder;
        case TileBorderCode.ALL_BORDERS_OPEN:
          return this.northEastSouthWestBorder;
        default:
          console.log("TileTemplate.getTileSprite() invalid border code: " + borderCode);
          return this.noBorder;
      }
    }
  };

  // src/model/grid/TileType.js
  var TileType = class {
    /**
     * @param {string} id
     * @param {string} name
     * @param {string} iconFileName
     * @param {boolean} opaque 
     * @param {boolean} lightingSupported
     * @param {number} tileTypeRarity See TileTypeRarity
     */
    constructor(id, name, iconFileName, opaque, lightingSupported, tileTypeRarity) {
      this.id = id;
      this.name = name;
      this.iconFileName = iconFileName;
      this.opaque = opaque;
      this.lightingSupported = lightingSupported;
      this.rarityModifier = tileTypeRarity;
      this.tileTemplate = null;
      this.tileTemplate2 = null;
      this.tileTemplate3 = null;
      this.tileTypeBackground = null;
      this.layerDescription = null;
    }
    /**
     * @returns {TileTemplate}
     */
    getRandomTemplate() {
      const r = Math.random();
      if (r < 0.333) {
        return this.tileTemplate;
      } else if (r < 0.666) {
        return this.tileTemplate2;
      } else {
        return this.tileTemplate3;
      }
    }
  };

  // src/model/grid/TileTypes.js
  var SpecialTileTypes = {
    /**
     * @constant
     * @type {TileType}
     */
    EMPTY: new TileType("0", "Empty", "sky.png", true, false, TileTypeRarity.COMMON),
    /**
     * @constant
     * @type {TileType}
     */
    SKY: new TileType("1", "Sky", "sky.png", true, false, TileTypeRarity.COMMON),
    /**
     * @constant
     * @type {TileType}
     */
    GRASS: new TileType("2", "Grass", "grass.png", true, false, TileTypeRarity.COMMON),
    /**
     * @constant
     * @type {TileType}
     */
    DIRT: new TileType("10", "Dirt", "dirt.png", true, true, TileTypeRarity.COMMON)
  };
  function populateTileTypeArray() {
    const tileTypes = [];
    let id = 11;
    tileTypes.push(new TileType("" + id++, "Blue Green Clay", "blue_green_clay.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Red Clay", "red_clay.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Grey Sandstone", "grey_sandstone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Brown Sandstone", "brown_sandstone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Green Pyronxenite", "green_pyronxenite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Blue Dunite", "blue_dunite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Deficient Hematite", "deficient_hematite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Blue Sandstone", "blue_sandstone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Pink Slate", "pink_slate.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Green Basalt", "green_basalt.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Deep Bismuth", "deep_bismuth.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Dark Phrenite", "dark_phrenite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Blue Stone", "blue_stone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Orange Alexandrite", "orange_alexandrite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Defective Cobalt", "defective_cobalt.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Green Schist", "green_schist.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Pale Blue Stone", "pale_blue_stone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Red Pyronxenite", "red_pyronxenite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Teal Clay", "teal_clay.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Bloodstone", "bloodstone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Grey Orange Granite", "grey_orange_granite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Aqua Carnelion", "aqua_carnelion.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Purple Grey Quartz", "purple_grey_quartz.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Substandard Gypsum", "substandard_gypsum.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Red Magnetite", "red_magnetite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Arkose Sandstone", "arkose_sandstone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Gabbro", "gabbro.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Dark Purple Clay", "dark_purple_clay.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Rose Stone", "rose_stone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Purple Grey Granite", "purple_grey_granite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Green Slate", "green_slate.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Blue Schist", "blue_schist.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Rotten Vanadium", "rotten_vanadium.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Green Quartz", "green_quartz.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Golden Slate", "golden_slate.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Slimy Pyrrhotite", "slimy_pyrrhotite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Green Jasper", "green_jasper.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Blood Agate", "blood_agate.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Compressed Bauxite", "compressed_bauxite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Darkest Adventurine", "darkest_adventurine.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Pink Amethyst", "pink_amethyst.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Dark Iron Stone", "dark_iron_stone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Brown Jasper", "brown_jasper.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Hellish Agate", "hellish_agate.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Nasty Bauxite", "nasty_bauxite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Diabolical Malachite", "diabolical_malachite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Sun Stone", "red_sunstone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Cruek Cesium", "cruel_cesium.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Orange Carnelion", "orange_carnelion.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Purple Charoite", "purple_charoite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Heliotrope Granite", "heliotrope_granite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Pink Kunzite", "pink_kunzite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Fractured Slate", "fractured_slate.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Pink Grey Granite", "pink_grey_granite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Blue Galaxy Granite", "blue_galaxy_granite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Black Quartz", "black_quartz.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Vile Hematite", "vile_hematite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Green Clay", "green_clay.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Purple Granite", "purple_granite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Blue Quartz", "blue_quartz.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Orange Basalt", "orange_basalt.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Yellow Sandstone", "yellow_sandstone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Blue Green Agate", "blue_green_agate.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Calamitous Calcite", "calamitous_calcite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Brown Basalt", "brown_basalt.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Emerald Dolomite", "emerald_dolomite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Dark Pyroxenite", "dark_pyroxenite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Violet Tanzanite", "violet_tanzanite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Green Serpentine", "green_serpentine.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Ruby Basalt", "ruby_basalt.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Purple Schist", "purple_schist.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Green Aragonite", "green_aragonite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Red Spinel", "red_spinel.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Infected Schist", "infected_schist.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Salmon Basalt", "salmon_basalt.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Enchanted Jasper", "enchanted_jasper.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Cursed Basalt", "cursed_basalt.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Sinister Slate", "sinister_slate.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Orange Apocalypse", "orange_apocalypse.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Devil Stone", "devil_stone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Asbestos", "asbestos.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Bleak Vanadium", "bleak_vanadium.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Poisoned Aragonite", "poisoned_aragonite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Purple Dunite", "purple_dunite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Corrupted Agate", "corrupted_agate.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Torched Aragonite", "torched_aragonite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Forbidden Quartz", "forbidden_quartz.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Violet Pyroxenite", "violet_pyroxenite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Slate Soulstone", "slate_soulstone.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Fractured Jasper", "fractured_jasper.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Sky Quartz", "sky_quartz.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Toxic Granite", "toxic_granite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Corroded Ruby", "corroded_ruby.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Offensive Shale", "offensive_shale.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Petrified Flamingos", "petrified_flamingos.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Crystallized Onyx", "crystallized_onyx.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Orange Jasper", "orange_jasper.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Satanic Slate", "satanic_slate.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Malignant Pyrite", "malignant_pyrite.png", true, true, TileTypeRarity.COMMON));
    tileTypes.push(new TileType("" + id++, "Pink Shale", "pink_shale.png", true, true, TileTypeRarity.COMMON));
    return tileTypes;
  }
  var TileTypeArray = populateTileTypeArray();
  var GoldTileTypes = {};
  var RubyTileTypes = {};
  var OreTileTypes = {};
  var UpgradeTileTypes = {};
  function getGold(baseType) {
    if (baseType === SpecialTileTypes.EMPTY || baseType === SpecialTileTypes.SKY) {
      return null;
    }
    let gold = GoldTileTypes[baseType.id];
    if (!gold) {
      gold = new TileType(baseType.id + "_g", "Gold", "gold.png", true, true, TileTypeRarity.GOLD);
      GoldTileTypes[baseType.id] = gold;
    }
    return gold;
  }
  function getRuby(baseType) {
    if (baseType === SpecialTileTypes.EMPTY || baseType === SpecialTileTypes.SKY) {
      return null;
    }
    let ruby = RubyTileTypes[baseType.id];
    if (!ruby) {
      ruby = new TileType(baseType.id + "_d", "Ruby", "ruby.png", true, true, TileTypeRarity.RUBY);
      RubyTileTypes[baseType.id] = ruby;
    }
    return ruby;
  }
  function getUpgrade(baseType) {
    if (baseType === SpecialTileTypes.EMPTY || baseType === SpecialTileTypes.SKY) {
      return null;
    }
    let upgrade = UpgradeTileTypes[baseType.id];
    if (!upgrade) {
      upgrade = new TileType(baseType.id + "_u", "Upgrade", "onyx.png", true, true, TileTypeRarity.UPGRADE);
      UpgradeTileTypes[baseType.id] = upgrade;
    }
    return upgrade;
  }
  function getOre(baseType) {
    if (baseType === SpecialTileTypes.EMPTY || baseType === SpecialTileTypes.SKY) {
      return null;
    }
    let upgrade = OreTileTypes[baseType.id];
    if (!upgrade) {
      upgrade = new TileType(baseType.id + "_o", "Ore", "purple_ore.png", true, true, TileTypeRarity.ORE);
      OreTileTypes[baseType.id] = upgrade;
    }
    return upgrade;
  }
  function addMapping(map, tileType) {
    map[tileType.id] = tileType;
    if (tileType === SpecialTileTypes.EMPTY || tileType === SpecialTileTypes.SKY) {
      return;
    }
    const gold = getGold(tileType);
    map[gold.id] = gold;
    const ore = getOre(tileType);
    map[ore.id] = ore;
    const upgrade = getUpgrade(tileType);
    map[upgrade.id] = upgrade;
    const ruby = getRuby(tileType);
    map[ruby.id] = ruby;
  }
  function buildTileTypeMap() {
    const map = {};
    addMapping(map, SpecialTileTypes.SKY);
    addMapping(map, SpecialTileTypes.GRASS);
    addMapping(map, SpecialTileTypes.DIRT);
    for (let i = 0; i < TileTypeArray.length; i++) {
      addMapping(map, TileTypeArray[i]);
    }
    return map;
  }
  var TileTypeMap = buildTileTypeMap();

  // src/util/Fast.js
  var buffer = new ArrayBuffer(4);
  var ui32 = new Uint32Array(buffer);
  var f32 = new Float32Array(buffer);
  var Fast = class {
    constructor() {
    }
    /**
     * @param {number} value 
     * @returns {number}
     */
    static floor(value2) {
      if (value2 < 0) {
        const fv = -this.floorPositive(-value2);
        return value2 === fv ? fv : fv - 1;
      } else {
        return this.floorPositive(value2);
      }
    }
    /**
     * @private
     * @param {number} value 
     * @returns {number}
     */
    static floorPositive(value2) {
      if (value2 < 2147483648) {
        return value2 | 0;
      } else {
        return Math.floor(value2);
      }
    }
    /**
     * Vector length.
     * @param {Vector} v 
     * @returns {number}
     */
    static len(v) {
      return 1 / this.invSqrt(v.x * v.x + v.y * v.y);
    }
    /**
     * Fast Normal.
     * @param {Vector} v 
     * @returns {Vector}
     */
    static nor(v) {
      const len = this.len(v);
      if (len != 0) {
        v.x /= len;
        v.y /= len;
      }
      return v;
    }
    /**
     * @param {Vector} v0 
     * @param {Vector} v1 
     * @returns {number}
     */
    static dist(v0, v1) {
      const dx = v0.x - v1.x;
      const dy = v0.y - v1.y;
      return 1 / this.invSqrt(dx * dx + dy * dy);
    }
    // From: https://gist.github.com/starfys/aaaee80838d0e013c27d
    /**
     * @param {number} x 
     * @returns {number}
     */
    static invSqrt(number) {
      f32[0] = number;
      ui32[0] = 1597463007 - (ui32[0] >> 1);
      const x = f32[0];
      return x * (1.5 - 0.5 * x * x * number);
    }
  };

  // src/GameModel.js
  var GameModel = class {
    /**
     * @abstract
     */
    constructor() {
    }
    /**
     * Perform full reset for:
     * 1. Delete all progress and start over.
     * 2. Prepare for save load.
     * @abstract
     */
    resetFull() {
    }
    /**
     * Just reset run-scoped data. 
     * Don't wipe out the skill tree or the prestige currency.
     * @abstract
     */
    resetForPrestige() {
    }
  };

  // src/model/grid/WorldGrid.js
  var WorldGrid = class extends GameModel {
    /**
     */
    constructor() {
      super();
      this.origin = new Vector(0, 0);
      this.grids = this.instantiateGrids();
      for (let i = 0; i < this.grids.length; i++) {
        this.grids[i].findTileNeighborsFull();
      }
      this.changeCount = 0;
      this.shiftCount = 0;
    }
    /**
     * @private
     * @returns {Grid[]}
     */
    instantiateGrids() {
      const c = Settings.grid.gridPixelWidth;
      const r = Settings.grid.gridPixelHeight;
      const grids = new Array(9);
      grids[0] = new Grid(this, new Vector(-c, -r));
      grids[1] = new Grid(this, new Vector(0, -r));
      grids[2] = new Grid(this, new Vector(c, -r));
      grids[3] = new Grid(this, new Vector(-c, 0));
      grids[4] = new Grid(this, new Vector(0, 0));
      grids[5] = new Grid(this, new Vector(c, 0));
      grids[6] = new Grid(this, new Vector(-c, r));
      grids[7] = new Grid(this, new Vector(0, r));
      grids[8] = new Grid(this, new Vector(c, r));
      return grids;
    }
    /**
     * @param {number} tileCol 
     * @param {number} tileRow 
     * @returns {GridTile}
     */
    getGridTile(tileCol, tileRow) {
      const grid = this.getGrid(tileCol, tileRow);
      if (!grid) {
        return null;
      }
      return grid.getGridTile(tileCol, tileRow);
    }
    /**
     * @param {number} tileCol 
     * @param {number} tileRow 
     * @returns {Grid}
     */
    getGrid(tileCol, tileRow) {
      const x = tileCol * Settings.tile.size;
      const y = tileRow * Settings.tile.size;
      const centerGrid = this.grids[4];
      if (!centerGrid) {
        return null;
      }
      if (centerGrid.containsXY(x, y)) {
        return centerGrid;
      }
      const centerLeftX = centerGrid.origin.x;
      const centerRightX = centerLeftX + Settings.grid.gridPixelWidth;
      const centerTopY = centerGrid.origin.y;
      const centerBottomY = centerTopY + Settings.grid.gridPixelHeight;
      let candidate = null;
      if (x >= centerLeftX && x < centerRightX) {
        if (y < centerTopY) {
          candidate = this.grids[1];
        } else if (y >= centerBottomY) {
          candidate = this.grids[7];
        }
      } else if (x < centerGrid.origin.x) {
        if (y >= centerTopY && y < centerBottomY) {
          candidate = this.grids[3];
        } else if (y < centerTopY) {
          candidate = this.grids[0];
        } else if (y >= centerBottomY) {
          candidate = this.grids[6];
        }
      } else if (x >= centerRightX) {
        if (y >= centerTopY && y < centerBottomY) {
          candidate = this.grids[5];
        } else if (y < centerTopY) {
          candidate = this.grids[2];
        } else if (y >= centerBottomY) {
          candidate = this.grids[8];
        }
      }
      if (candidate && candidate.containsXY(x, y)) {
        return candidate;
      }
      return null;
    }
    /**
     * @param {Vector} pixelLocation 
     * @returns {Grid}
     */
    findGridContaining(pixelLocation) {
      const tileCol = Fast.floor(pixelLocation.x / Settings.tile.size);
      const tileRow = Fast.floor(pixelLocation.y / Settings.tile.size);
      return this.getGrid(tileCol, tileRow);
    }
    /**
     * @param {Vector} pixelLocation 
     * @returns {GridTile}
     */
    findGridTile(pixelLocation) {
      const tileCol = Fast.floor(pixelLocation.x / Settings.tile.size);
      const tileRow = Fast.floor(pixelLocation.y / Settings.tile.size);
      return this.getGridTile(tileCol, tileRow);
    }
    /**
     * @param {number} x
     * @param {number} y
     * @returns {GridTile}
     */
    findGridTileXY(x, y) {
      const tileCol = Fast.floor(x / Settings.tile.size);
      const tileRow = Fast.floor(y / Settings.tile.size);
      return this.getGridTile(tileCol, tileRow);
    }
    /**
     * @param {Vector} pixelLocation 
     * @returns {GridRegion}
     */
    findGridRegion(pixelLocation) {
      if (!this.groups) {
        return null;
      }
      const tile = this.findGridTile(pixelLocation);
      return tile != null ? tile.getRegion() : null;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.changeCount = 0;
      this.shiftCount = 0;
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/grid/GridRegion.js
  var GridRegion = class extends GridBox {
    /**
     * @param {GridZone} zone
     * @param {Vector} origin
     */
    constructor(zone, origin) {
      super(origin);
      this.zone = zone;
      this.tiles = this.createTiles();
      this.mineTiles = [];
      this.vectorFieldNumber = -1;
    }
    /**
     * @private
     * @returns {Array.<GridTile>}
     */
    createTiles() {
      const tiles = new Array(Settings.grid.numTileColsInRegion * Settings.grid.numTileRowsInRegion);
      const grid = this.zone.grid;
      const origin = this.getOrigin();
      const x = origin.x;
      const y = origin.y;
      let i = 0;
      for (let col = 0; col < Settings.grid.numTileColsInRegion; col++) {
        for (let row = 0; row < Settings.grid.numTileRowsInRegion; row++) {
          tiles[i++] = new GridTile(grid, this, new Vector(x + Settings.tile.size * col, y + Settings.tile.size * row));
        }
      }
      return tiles;
    }
    /**
     * Invoked when the owner grid is assigned a new location.
     * @param {number} originX 
     * @param {number} originY 
     */
    initialize(originX, originY) {
      this.origin.set(originX, originY);
      const x = this.origin.x;
      const y = this.origin.y;
      let i = 0;
      for (let col = 0; col < Settings.grid.numTileColsInRegion; col++) {
        for (let row = 0; row < Settings.grid.numTileRowsInRegion; row++) {
          const tile = this.tiles[i++];
          tile.initialize(x + Settings.tile.size * col, y + Settings.tile.size * row);
        }
      }
      this.mineTiles.length = 0;
      this.vectorFieldNumber = -1;
    }
    /**
     * @param {GridTile} tile 
     * @returns {number}
     */
    getTileIndex(tile) {
      const col = tile.getTileCol() - this.getOriginTileCol();
      const row = tile.getTileRow() - this.getOriginTileRow();
      return col * Settings.grid.numTileRowsInRegion + row;
    }
    /**
     * @returns {GridZone}
     */
    getZone() {
      return this.zone;
    }
    /**
     * @returns {Grid}
     */
    getGrid() {
      return this.zone.grid;
    }
    /**
     * @returns {WorldGrid}
     */
    getWorldGrid() {
      return this.zone.getWorldGrid();
    }
    /**
     * @returns {Array.<GridTile>}
     */
    getTiles() {
      return this.tiles;
    }
    /**
     * @returns {number}
     */
    getPixelWidth() {
      return Settings.grid.regionPixelWidth;
    }
    /**
     * @returns {number}
     */
    getPixelHeight() {
      return Settings.grid.regionPixelHeight;
    }
    /**
     * @param {Vector} pixelLocation 
     * @returns {GridTile}
     */
    findGridTile(pixelLocation) {
      const tileCol = Fast.floor(pixelLocation.x / Settings.tile.size);
      const tileRow = Fast.floor(pixelLocation.y / Settings.tile.size);
      return this.getGridTileAbsolute(tileCol, tileRow);
    }
    /**
     * @param {number} tileCol 
     * @param {number} tileRow 
     * @returns {GridTile}
     */
    getGridTileAbsolute(tileCol, tileRow) {
      const origin = this.origin;
      const tileOriginCol = Fast.floor(origin.x / Settings.tile.size);
      const tileOriginRow = Fast.floor(origin.y / Settings.tile.size);
      return this.getGridTileLocal(tileCol - tileOriginCol, tileRow - tileOriginRow);
    }
    /**
     * @param {number} tileCol 
     * @param {number} tileRow 
     * @returns {GridTile}
     */
    getGridTileLocal(tileCol, tileRow) {
      if (tileCol < 0 || tileCol >= Settings.grid.numTileColsInRegion) {
        return null;
      }
      if (tileRow < 0 || tileRow >= Settings.grid.numTileRowsInRegion) {
        return null;
      }
      const index = tileCol * Settings.grid.numTileRowsInRegion + tileRow;
      if (index >= 0 && index < this.tiles.length) {
        return this.tiles[index];
      } else {
        console.log("GridRegion.getGridTileLocal() Failed to find tile. col=" + tileCol + " row=" + tileRow + " index=" + index);
        return null;
      }
    }
    // The tiles that are internal to a region (ie. not on the edge) only need to
    // have their neighbors found once.
    /**
     */
    findTileNeighborsFull() {
      for (let i = 0; i < this.tiles.length; i++) {
        this.tiles[i].findNeighbors();
      }
    }
    /**
     * @param {number} col 
     * @param {number} row 
     * @returns {GridTile}
     */
    getTile(col, row) {
      return this.tiles[col * Settings.grid.numTileRowsInRegion + row];
    }
    findRegionBorderTileNeighbors() {
      const rightCol = Settings.grid.numTileColsInRegion - 1;
      const topRow = Settings.grid.numTileRowsInRegion - 1;
      const bottomRow = 0;
      const leftCol = 0;
      this.getTile(rightCol, topRow).findNeighbors();
      this.getTile(rightCol, bottomRow).findNeighbors();
      this.getTile(leftCol, topRow).findNeighbors();
      this.getTile(leftCol, bottomRow).findNeighbors();
      for (let row = 1; row < Settings.grid.numTileRowsInRegion - 1; row++) {
        this.getTile(rightCol, row).findNeighbors();
      }
      for (let row = 1; row < Settings.grid.numTileRowsInRegion - 1; row++) {
        this.getTile(leftCol, row).findNeighbors();
      }
      for (let col = 1; col < Settings.grid.numTileColsInRegion - 1; col++) {
        this.getTile(col, bottomRow).findNeighbors();
      }
      for (let col = 1; col < Settings.grid.numTileColsInRegion - 1; col++) {
        this.getTile(col, topRow).findNeighbors();
      }
    }
    findTileNeighborsBorderRight() {
      const eastCol = Settings.grid.numTileColsInRegion - 1;
      for (let row = 0; row < Settings.grid.numTileRowsInRegion; row++) {
        this.getTile(eastCol, row).findNeighborRight();
      }
    }
    nullifyTileNeighborsBorderRight() {
      const eastCol = Settings.grid.numTileColsInRegion - 1;
      for (let row = 0; row < Settings.grid.numTileRowsInRegion; row++) {
        this.getTile(eastCol, row).nullifyNeighborRight();
      }
    }
    evaluateTileBordersRight() {
      const eastCol = Settings.grid.numTileColsInRegion - 1;
      for (let row = 0; row < Settings.grid.numTileRowsInRegion; row++) {
        this.getTile(eastCol, row).evaluateBorders();
      }
    }
    findTileNeighborsBorderLeft() {
      for (let row = 0; row < Settings.grid.numTileRowsInRegion; row++) {
        this.getTile(0, row).findNeighborLeft();
      }
    }
    nullifyTileNeighborsBorderLeft() {
      for (let row = 0; row < Settings.grid.numTileRowsInRegion; row++) {
        this.getTile(0, row).nullifyNeighborLeft();
      }
    }
    evaluateTileBordersLeft() {
      for (let row = 0; row < Settings.grid.numTileRowsInRegion; row++) {
        this.getTile(0, row).evaluateBorders();
      }
    }
    findTileNeighborsBorderBottom() {
      const southRow = Settings.grid.numTileRowsInRegion - 1;
      for (let col = 0; col < Settings.grid.numTileColsInRegion; col++) {
        this.getTile(col, southRow).findNeighborBottom();
      }
    }
    nullifyTileNeighborsBorderBottom() {
      const southRow = Settings.grid.numTileRowsInRegion - 1;
      for (let col = 0; col < Settings.grid.numTileColsInRegion; col++) {
        this.getTile(col, southRow).nullifyNeighborBottom();
      }
    }
    evaluateTileBordersBottom() {
      const southRow = Settings.grid.numTileRowsInRegion - 1;
      for (let col = 0; col < Settings.grid.numTileColsInRegion; col++) {
        this.getTile(col, southRow).evaluateBorders();
      }
    }
    findTileNeighborsBorderTop() {
      for (let col = 0; col < Settings.grid.numTileColsInRegion; col++) {
        this.getTile(col, 0).findNeighborTop();
      }
    }
    nullifyTileNeighborsBorderTop() {
      for (let col = 0; col < Settings.grid.numTileColsInRegion; col++) {
        this.getTile(col, 0).nullifyNeighborTop();
      }
    }
    evaluateTileBordersTop() {
      for (let col = 0; col < Settings.grid.numTileColsInRegion; col++) {
        this.getTile(col, 0).evaluateBorders();
      }
    }
  };

  // src/model/color/Color.js
  var HEX = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0A",
    "0B",
    "0C",
    "0D",
    "0E",
    "0F",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1A",
    "1B",
    "1C",
    "1D",
    "1E",
    "1F",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2A",
    "2B",
    "2C",
    "2D",
    "2E",
    "2F",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3A",
    "3B",
    "3C",
    "3D",
    "3E",
    "3F",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4A",
    "4B",
    "4C",
    "4D",
    "4E",
    "4F",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5A",
    "5B",
    "5C",
    "5D",
    "5E",
    "5F",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6A",
    "6B",
    "6C",
    "6D",
    "6E",
    "6F",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7A",
    "7B",
    "7C",
    "7D",
    "7E",
    "7F",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8A",
    "8B",
    "8C",
    "8D",
    "8E",
    "8F",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9A",
    "9B",
    "9C",
    "9D",
    "9E",
    "9F",
    "A0",
    "A1",
    "A2",
    "A3",
    "A4",
    "A5",
    "A6",
    "A7",
    "A8",
    "A9",
    "AA",
    "AB",
    "AC",
    "AD",
    "AE",
    "AF",
    "B0",
    "B1",
    "B2",
    "B3",
    "B4",
    "B5",
    "B6",
    "B7",
    "B8",
    "B9",
    "BA",
    "BB",
    "BC",
    "BD",
    "BE",
    "BF",
    "C0",
    "C1",
    "C2",
    "C3",
    "C4",
    "C5",
    "C6",
    "C7",
    "C8",
    "C9",
    "CA",
    "CB",
    "CC",
    "CD",
    "CE",
    "CF",
    "D0",
    "D1",
    "D2",
    "D3",
    "D4",
    "D5",
    "D6",
    "D7",
    "D8",
    "D9",
    "DA",
    "DB",
    "DC",
    "DD",
    "DE",
    "DF",
    "E0",
    "E1",
    "E2",
    "E3",
    "E4",
    "E5",
    "E6",
    "E7",
    "E8",
    "E9",
    "EA",
    "EB",
    "EC",
    "ED",
    "EE",
    "EF",
    "F0",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "FA",
    "FB",
    "FC",
    "FD",
    "FE",
    "FF"
  ];
  var Color = class _Color {
    /**
     * @param {number} r Floating point value between 0-1.
     * @param {number} g Floating point value between 0-1.
     * @param {number} b Floating point value between 0-1.
     * @param {number} a Floating point value between 0-1.
     */
    constructor(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
      this.fillColor = null;
      this.clamp();
    }
    /**
     * Creates a color using the RGBA color integer (eg. 0xc0c0c0FF).
     * @param {number} rgba 
     * @returns {Color}
     */
    static createColor(rgba) {
      const red = (rgba & 4278190080) >> 24;
      const green = (rgba & 16711680) >> 16;
      const blue = (rgba & 65280) >> 8;
      const alpha = rgba & 255;
      return new _Color(red / 255, green / 255, blue / 255, alpha / 255);
    }
    /**
     * @param {Color} color
     */
    set(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      this.a = color.a;
      this.fillColor = null;
    }
    /**
     * @param {number} alpha In the range of 0..1
     */
    setAlpha(alpha) {
      this.a = alpha;
    }
    /**
     * @param {number} alpha In the range of 0..1
     */
    addAlpha(alpha) {
      this.a += alpha;
      if (this.a > 1) {
        this.a = 1;
      }
    }
    reset() {
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
    }
    /**
     * @param {number} r 
     * @param {number} g 
     * @param {number} b 
     * @param {number} a 
     */
    setRgba(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
      this.clamp();
      this.fillColor = null;
    }
    /**
     * @param {number} r 
     * @param {number} g 
     * @param {number} b 
     * @param {number} a 
     */
    setRgbaFast(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
      this.fillColor = null;
    }
    resetFast() {
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.fillColor = null;
    }
    /**
     * @param {number} value 
     */
    mul(value2) {
      this.r *= value2;
      this.g *= value2;
      this.b *= value2;
      this.a *= value2;
      this.clamp();
      this.fillColor = null;
    }
    /**
     * @param {Color} color
     */
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      this.a += color.a;
      this.clamp();
      this.fillColor = null;
    }
    /**
     * @param {Color} color
     */
    addFast(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      this.a += color.a;
      this.fillColor = null;
    }
    /**
     * @param {number} r 
     * @param {number} g 
     * @param {number} b 
     * @param {number} a 
     */
    addRgba(r, g, b, a) {
      this.r += r;
      this.g += g;
      this.b += b;
      this.a += a;
      this.clamp();
      this.fillColor = null;
    }
    /**
     * @param {number} r 
     * @param {number} g 
     * @param {number} b 
     * @param {number} a 
     */
    addFastRgba(r, g, b, a) {
      this.r += r;
      this.g += g;
      this.b += b;
      this.a += a;
      this.fillColor = null;
    }
    /**
     * @returns {string}
     */
    getFillColor() {
      if (!this.fillColor) {
        this.fillColor = this.createFillColor();
      }
      return this.fillColor;
    }
    /**
     * @private
     * @returns {string}
     */
    createFillColor() {
      const aa = (1 - this.a) * 255 | 0, rr = this.r * 255 | 0, gg = this.g * 255 | 0, bb = this.b * 255 | 0;
      return "#" + HEX[rr] + HEX[gg] + HEX[bb] + HEX[aa];
    }
    clamp() {
      if (this.r < 0) {
        this.r = 0;
      } else if (this.r > 1) {
        this.r = 1;
      }
      if (this.g < 0) {
        this.g = 0;
      } else if (this.g > 1) {
        this.g = 1;
      }
      if (this.b < 0) {
        this.b = 0;
      } else if (this.b > 1) {
        this.b = 1;
      }
      if (this.a < 0) {
        this.a = 0;
      } else if (this.a > 1) {
        this.a = 1;
      }
    }
  };

  // src/model/lighting/TileLighting.js
  var AMBIENT_LIGHTING = new Color(0, 0, 0, 0.3);
  var TileLighting = class {
    constructor() {
      this.everVisibleToCharacter = false;
      this.currentlyVisibleToCharacter = false;
      this.environmentLighting = new Color(0, 0, 0, 0);
      this.dynamicLighting = new Color(0, 0, 0, 0);
      this.positionalLighting = new Color(0, 0, 0, 0);
      this.shadowColor = new Color(0, 0, 0, 0);
      this.sunlightFull = false;
      this.sunlightPartial = 0;
    }
    resetLighting() {
      this.dynamicLighting.resetFast();
      this.environmentLighting.resetFast();
      this.positionalLighting.resetFast();
      this.currentlyVisibleToCharacter = false;
    }
    resetPositionalLighting() {
      this.positionalLighting.resetFast();
      this.currentlyVisibleToCharacter = false;
    }
    resetEnvironmentLighting() {
      this.environmentLighting.resetFast();
    }
    resetDynamicLighting() {
      this.dynamicLighting.resetFast();
    }
    /**
     * @param {Color} lightColor
     */
    addPositionalLighting(lightColor) {
      this.positionalLighting.add(lightColor);
    }
    /**
     * @param {Color} lightColor
     */
    addEnvironmentLighting(lightColor) {
      this.environmentLighting.add(lightColor);
    }
    /**
     * @param {Color} lightColor
     */
    addDynamicLighting(lightColor) {
      this.dynamicLighting.add(lightColor);
    }
    markTileAsCurrentlyVisible() {
      this.currentlyVisibleToCharacter = true;
      this.everVisibleToCharacter = true;
    }
    markAsSunlightFull() {
      this.sunlightFull = true;
      this.everVisibleToCharacter = true;
    }
    /**
     * @returns {boolean}
     */
    isSunlightPartial() {
      return this.sunlightPartial > 0;
    }
    sunlightPartialIncrement() {
      this.sunlightPartial++;
      this.everVisibleToCharacter = true;
    }
    sunlightPartialDecrement() {
      if (this.sunlightPartial > 0) {
        this.sunlightPartial--;
      }
    }
    /**
     * Calculates the lighting of the tile.
     * @returns {Color}
     */
    calculateShadowColor() {
      this.shadowColor.set(AMBIENT_LIGHTING);
      if (this.currentlyVisibleToCharacter) {
        this.shadowColor.addFast(this.environmentLighting);
        this.shadowColor.addFast(this.dynamicLighting);
        this.shadowColor.addFast(this.positionalLighting);
        this.shadowColor.clamp();
      }
      if (this.sunlightFull) {
        this.shadowColor.setAlpha(1);
      } else if (this.sunlightPartial > 0) {
        this.shadowColor.addAlpha(0.3);
      }
      return this.shadowColor;
    }
    /**
     * Invoked when the associated tile is reset.
     */
    reset() {
      this.everVisibleToCharacter = false;
      this.currentlyVisibleToCharacter = false;
      this.sunlightFull = false;
      this.sunlightPartial = 0;
    }
  };

  // src/model/path/VectorFieldScores.js
  var VectorFieldScores = {
    PREMIUM: 100,
    COMMON_REVEAL_CAVERN: 5,
    COMMON_HIDDEN_NEIGHBOR: 3,
    WORTHLESS: 0,
    IN_RANGE_OPEN: -10,
    // tile is in range but open
    IN_RANGE_UNSEEN: -20,
    // tile is in range but never seen.
    UNSET: -1e3
  };

  // src/model/grid/PathData.js
  var PathData = class {
    constructor() {
      this.pathNumber = 0;
      this.closed = false;
      this.cameFrom = null;
      this.cost = 0;
      this.score = 0;
      this.inOpenList = false;
      this.mineScore = -1;
      this.mineVectorFieldNumber = -1;
    }
    /**
     * @param {number} pathNumber 
     * @returns {GridTile}
     */
    getCameFrom(pathNumber) {
      if (this.pathNumber != pathNumber) {
        this.reset(pathNumber);
      }
      return this.cameFrom;
    }
    /**
     * @param {GridTile} cameFrom 
     * @param {number} cost 
     * @param {number} score 
     * @param {number} pathNumber 
     */
    set(cameFrom, cost, score, pathNumber) {
      if (this.pathNumber != pathNumber) {
        this.reset(pathNumber);
      }
      this.cameFrom = cameFrom;
      this.cost = cost;
      this.score = score;
    }
    /**
     * @param {number} pathNumber 
     * @returns {number}
     */
    getCost(pathNumber) {
      if (this.pathNumber != pathNumber) {
        this.reset(pathNumber);
      }
      return this.cost;
    }
    /**
     * @param {number} cost 
     * @param {number} pathNumber 
     */
    setCost(cost, pathNumber) {
      if (this.pathNumber != pathNumber) {
        this.reset(pathNumber);
      }
      this.cost = cost;
    }
    /**
     * @param {number} pathNumber 
     * @returns {number}
     */
    getScore(pathNumber) {
      if (this.pathNumber != pathNumber) {
        this.reset(pathNumber);
      }
      return this.score;
    }
    /**
     * @param {boolean} closed 
     * @param {number} pathNumber 
     */
    setClosed(closed, pathNumber) {
      if (this.pathNumber != pathNumber) {
        this.reset(pathNumber);
      }
      this.closed = closed;
    }
    /**
     * @param {number} pathNumber 
     * @returns {boolean}
     */
    isClosed(pathNumber) {
      if (this.pathNumber != pathNumber) {
        this.reset(pathNumber);
      }
      return this.closed;
    }
    /**
     * @param {boolean} inOpenList 
     * @param {number} pathNumber 
     */
    setInOpenList(inOpenList, pathNumber) {
      if (this.pathNumber != pathNumber) {
        this.reset(pathNumber);
      }
      this.inOpenList = inOpenList;
    }
    /**
     * @param {number} pathNumber 
     * @returns {boolean}
     */
    isInOpenList(pathNumber) {
      if (this.pathNumber != pathNumber) {
        this.reset(pathNumber);
      }
      return this.inOpenList;
    }
    /**
     * @param {number} vectorFieldNumber 
     * @returns {number}
     */
    getMineScore(vectorFieldNumber) {
      if (this.mineVectorFieldNumber != vectorFieldNumber) {
        return VectorFieldScores.UNSET;
      } else {
        return this.mineScore;
      }
    }
    /**
     * @param {number} mineScore 
     * @param {number} vectorFieldNumber 
     */
    setMineScore(mineScore, vectorFieldNumber) {
      this.mineVectorFieldNumber = vectorFieldNumber;
      this.mineScore = mineScore;
    }
    /**
     * @private
     * @param {number} pathNumber 
     */
    reset(pathNumber) {
      this.pathNumber = pathNumber;
      this.closed = false;
      this.cameFrom = null;
      this.cost = 0;
      this.score = 0;
      this.inOpenList = false;
    }
  };

  // src/model/fixture/FixtureDescription.js
  var FixtureDescription = class {
    /**
     * @param {string} spriteName 
     * @param {boolean} traversable 
     * @param {boolean} opaque 
     * @param {boolean} stateSavable 
     */
    constructor(spriteName, traversable, opaque, stateSavable) {
      this.spriteName = spriteName;
      this.traversable = traversable;
      this.opaque = opaque;
      this.stateSavable = stateSavable;
      this.sprite = null;
    }
  };

  // src/model/grid/GridTile.js
  var NEIGHBOR_TOP_INDEX = 0;
  var NEIGHBOR_BOTTOM_INDEX = 1;
  var NEIGHBOR_RIGHT_INDEX = 2;
  var NEIGHBOR_LEFT_INDEX = 3;
  var WORKING_PERCENT = new BigNum(0);
  var GridTile = class extends GridBox {
    /**
     * @param {Grid} grid
     * @param {GridRegion} region 
     * @param {Vector} origin 
     */
    constructor(grid, region, origin) {
      super(origin);
      this.grid = grid;
      this.region = region;
      this.sprite = null;
      this.backgroundSprite = null;
      this.neighbors = new Array(4);
      this.neighbors[NEIGHBOR_TOP_INDEX] = null;
      this.neighbors[NEIGHBOR_BOTTOM_INDEX] = null;
      this.neighbors[NEIGHBOR_RIGHT_INDEX] = null;
      this.neighbors[NEIGHBOR_LEFT_INDEX] = null;
      this.tileType = SpecialTileTypes.EMPTY;
      this.tileTemplate = null;
      this.borderCode = 0;
      this.open = false;
      this.fixtureDescription = null;
      this.lighting = new TileLighting();
      this.pathData = new PathData();
      this.initialHealth = null;
      this.health = null;
      this.healthPercent = 100;
      this.mineTileIndex = -1;
    }
    /**
     * Invoked when assigned to a grid.
     * @param {number} originX 
     * @param {number} originY 
     */
    initialize(originX, originY) {
      this.origin.set(originX, originY);
      this.tileType = SpecialTileTypes.EMPTY;
      this.tileTemplate = null;
      this.sprite = null;
      this.fixtureDescription = null;
      this.backgroundSprite = null;
      this.open = false;
      this.mineTileIndex = -1;
      this.health = null;
      this.initialHealth = null;
      this.healthPercent = 100;
      this.lighting.reset();
    }
    /**
     * Invoked when the terrain generator has assigned a tile type and the open/closed status of the tile.
     * @param {boolean} open 
     * @param {TileType} tileType 
     */
    tileInit(open, tileType) {
      this.borderCode = -1;
      this.open = open;
      this.setTileType(tileType);
    }
    /**
     * @param {TileType} tileType 
     */
    setTileType(tileType) {
      if (!tileType) {
        console.log("GridTyple.setTileType is null");
        return;
      }
      if (this.tileType === tileType) {
        return;
      }
      this.tileType = tileType;
      this.tileTemplate = tileType.getRandomTemplate();
      if (this.tileTemplate && !this.open && this.borderCode != -1) {
        this.sprite = this.tileTemplate.getTileSprite(this.borderCode);
      }
    }
    /**
     * @returns {BigNum}
     */
    getHealth() {
      if (this.open) {
        return null;
      }
      if (!this.health) {
        this.calculateTileHealth();
      }
      return this.health;
    }
    /**
     * @param {BigNum} goldOutput
     */
    calculateTileGold(goldOutput) {
      if (this.tileType.rarityModifier !== TileTypeRarity.GOLD) {
        goldOutput.setZero();
        return;
      }
      goldOutput.copy(this.tileType.layerDescription.baseGold);
    }
    /**
     * @private
     */
    calculateTileHealth() {
      if (this.open) {
        this.health = null;
      } else {
        this.health = new BigNum(0);
        this.tileType.layerDescription.calculateTileHealth(this.getTileRow(), this.health);
        this.initialHealth = new BigNum(0);
        this.initialHealth.copy(this.health);
      }
    }
    /**
     * @returns {boolean}
     */
    isCommon() {
      return this.tileType.rarityModifier === TileTypeRarity.COMMON;
    }
    /**
     * @returns {boolean}
     */
    isCurrency() {
      return this.tileType.rarityModifier === TileTypeRarity.ORE;
    }
    /**
     * @returns {boolean}
     */
    isPriority() {
      return this.tileType.rarityModifier === TileTypeRarity.GOLD || this.tileType.rarityModifier === TileTypeRarity.RUBY || this.tileType.rarityModifier === TileTypeRarity.UPGRADE;
    }
    /**
     * @returns {Grid}
     */
    getGrid() {
      return this.grid;
    }
    /**
     * @returns {GridRegion}
     */
    getRegion() {
      return this.region;
    }
    /**
     * @returns {WorldGrid}
     */
    getWorldGrid() {
      return this.grid.getWorldGrid();
    }
    /**
     * @returns {Sprite}
     */
    getSprite() {
      return this.sprite;
    }
    /**
     * @param {Sprite} sprite 
     */
    setSprite(sprite) {
      this.sprite = sprite;
    }
    /**
     * @returns {Vector}
     */
    createCenterPositionVector() {
      const position = new Vector(0, 0);
      this.assignCenterPosition(position);
      return position;
    }
    /**
     * @param {Vector} position 
     */
    assignCenterPosition(position) {
      position.set(this.origin.x + Settings.tile.halfSize, this.origin.y + Settings.tile.halfSize);
    }
    /**
     * @returns {boolean}
     */
    isTraversable() {
      if (this.open) {
        return !this.fixtureDescription || this.fixtureDescription.traversable;
      } else {
        return false;
      }
    }
    /**
     * @returns {boolean}
     */
    isOpaque() {
      if (this.open) {
        return this.fixtureDescription && this.fixtureDescription.opaque;
      } else {
        return this.tileType.opaque;
      }
    }
    /**
     * @returns {number}
     */
    getPixelWidth() {
      return Settings.tile.size;
    }
    /**
     * @returns {number}
     */
    getPixelHeight() {
      return Settings.tile.size;
    }
    /**
     * @returns {number}
     */
    getTileCol() {
      return this.getOriginTileCol();
    }
    /**
     * @returns {number}
     */
    getTileRow() {
      return this.getOriginTileRow();
    }
    /**
     * @returns {string}
     */
    createId() {
      return this.getTileCol() + "_" + this.getTileRow();
    }
    /**
     * @returns {Array.<GridTile>}
     */
    getNeighbors() {
      return this.neighbors;
    }
    findNeighbors() {
      this.neighbors[0] = null;
      this.neighbors[1] = null;
      this.neighbors[2] = null;
      this.neighbors[3] = null;
      const col = this.getTileCol();
      const row = this.getTileRow();
      const topNeighbor = this.getNeighborColRow(col, row - 1);
      if (topNeighbor) {
        this.neighbors[NEIGHBOR_TOP_INDEX] = topNeighbor;
        topNeighbor.neighbors[NEIGHBOR_BOTTOM_INDEX] = this;
      }
      const bottomNeighbor = this.getNeighborColRow(col, row + 1);
      if (bottomNeighbor) {
        this.neighbors[NEIGHBOR_BOTTOM_INDEX] = bottomNeighbor;
        bottomNeighbor.neighbors[NEIGHBOR_TOP_INDEX] = this;
      }
      const rightNeighbor = this.getNeighborColRow(col + 1, row);
      if (rightNeighbor) {
        this.neighbors[NEIGHBOR_RIGHT_INDEX] = rightNeighbor;
        rightNeighbor.neighbors[NEIGHBOR_LEFT_INDEX] = this;
      }
      const leftNeighbor = this.getNeighborColRow(col - 1, row);
      if (leftNeighbor) {
        this.neighbors[NEIGHBOR_LEFT_INDEX] = leftNeighbor;
        leftNeighbor.neighbors[NEIGHBOR_RIGHT_INDEX] = this;
      }
    }
    nullifyNeighborRight() {
      this.neighbors[NEIGHBOR_RIGHT_INDEX] = null;
    }
    nullifyNeighborLeft() {
      this.neighbors[NEIGHBOR_LEFT_INDEX] = null;
    }
    nullifyNeighborBottom() {
      this.neighbors[NEIGHBOR_BOTTOM_INDEX] = null;
    }
    nullifyNeighborTop() {
      this.neighbors[NEIGHBOR_TOP_INDEX] = null;
    }
    findNeighborRight() {
      this.neighbors[NEIGHBOR_RIGHT_INDEX] = null;
      const col = this.getTileCol();
      const row = this.getTileRow();
      const rightNeighbor = this.getNeighborColRow(col + 1, row);
      if (rightNeighbor) {
        this.neighbors[NEIGHBOR_RIGHT_INDEX] = rightNeighbor;
        rightNeighbor.neighbors[NEIGHBOR_LEFT_INDEX] = this;
      }
    }
    findNeighborLeft() {
      this.neighbors[NEIGHBOR_LEFT_INDEX] = null;
      const col = this.getTileCol();
      const row = this.getTileRow();
      const leftNeighbor = this.getNeighborColRow(col - 1, row);
      if (leftNeighbor) {
        this.neighbors[NEIGHBOR_LEFT_INDEX] = leftNeighbor;
        leftNeighbor.neighbors[NEIGHBOR_RIGHT_INDEX] = this;
      }
    }
    findNeighborTop() {
      this.neighbors[NEIGHBOR_TOP_INDEX] = null;
      const col = this.getTileCol();
      const row = this.getTileRow();
      const topNeighbor = this.getNeighborColRow(col, row - 1);
      if (topNeighbor) {
        this.neighbors[NEIGHBOR_TOP_INDEX] = topNeighbor;
        topNeighbor.neighbors[NEIGHBOR_BOTTOM_INDEX] = this;
      }
    }
    findNeighborBottom() {
      this.neighbors[NEIGHBOR_BOTTOM_INDEX] = null;
      const col = this.getTileCol();
      const row = this.getTileRow();
      const bottomNeighbor = this.getNeighborColRow(col, row + 1);
      if (bottomNeighbor) {
        this.neighbors[NEIGHBOR_BOTTOM_INDEX] = bottomNeighbor;
        bottomNeighbor.neighbors[NEIGHBOR_TOP_INDEX] = this;
      }
    }
    /**
     * @param {GridTile} tile 
     * @returns {boolean}
     */
    isAdjacentTo(tile) {
      const row1 = this.getTileRow();
      const row2 = tile.getTileRow();
      if (Math.abs(row1 - row2) > 1) {
        return false;
      }
      const col1 = this.getTileCol();
      const col2 = tile.getTileCol();
      if (Math.abs(col1 - col2) > 1) {
        return false;
      }
      return true;
    }
    /**
     * @param {GridTile} tile 
     * @returns {boolean}
     */
    isNeighborTile(tile) {
      return tile === this.neighbors[0] || tile === this.neighbors[1] || tile === this.neighbors[2] || tile === this.neighbors[3];
    }
    /**
     * @private
     * @param {number} col 
     * @param {number} row 
     * @returns {GridTile}
     */
    getNeighborColRow(col, row) {
      let neighbor = this.region.getGridTileAbsolute(col, row);
      if (!neighbor) {
        const zone = this.region.zone;
        neighbor = zone.getGridTileAbsolute(col, row);
        if (!neighbor) {
          const grid = zone.grid;
          neighbor = grid.getGridTileAbsolute(col, row);
          if (!neighbor) {
            const worldGrid = zone.grid.worldGrid;
            neighbor = worldGrid.getGridTile(col, row);
          }
        }
      }
      return neighbor;
    }
    /**
     * @param {Vector} position
     * @returns {GridTile}
     */
    getNeighbor(position) {
      if (this.contains(position)) {
        return this;
      }
      const neighbor = this.findNeighborContaining(position);
      if (neighbor) {
        return neighbor;
      }
      const tileCol = Fast.floor(position.x / Settings.tile.size);
      const tileRow = Fast.floor(position.y / Settings.tile.size);
      return this.getNeighborColRow(tileCol, tileRow);
    }
    /**
     * @returns {GridTile}
     */
    getNeighborLeft() {
      return this.neighbors[NEIGHBOR_LEFT_INDEX];
    }
    /**
     * @returns {GridTile}
     */
    getNeighborRight() {
      return this.neighbors[NEIGHBOR_RIGHT_INDEX];
    }
    /**
     * @returns {GridTile}
     */
    getNeighborTop() {
      return this.neighbors[NEIGHBOR_TOP_INDEX];
    }
    /**
     * @returns {GridTile}
     */
    getNeighborBottom() {
      return this.neighbors[NEIGHBOR_BOTTOM_INDEX];
    }
    /**
     * @returns {GridTile}
     */
    getNeighborTopLeft() {
      const top = this.neighbors[NEIGHBOR_TOP_INDEX];
      if (!top) {
        return null;
      }
      return top.getNeighborLeft();
    }
    /**
     * @returns {GridTile}
     */
    getNeighborTopRight() {
      const top = this.neighbors[NEIGHBOR_TOP_INDEX];
      if (!top) {
        return null;
      }
      return top.getNeighborRight();
    }
    /**
     * @returns {GridTile}
     */
    getNeighborBottomLeft() {
      const bottom = this.neighbors[NEIGHBOR_BOTTOM_INDEX];
      if (!bottom) {
        return null;
      }
      return bottom.getNeighborLeft();
    }
    /**
     * @returns {GridTile}
     */
    getNeighborBottomRight() {
      const bottom = this.neighbors[NEIGHBOR_BOTTOM_INDEX];
      if (!bottom) {
        return null;
      }
      return bottom.getNeighborRight();
    }
    /**
     * @param {GridTile} tile
     * @returns {boolean}
     */
    isNeighborLeft(tile) {
      return tile === this.neighbors[NEIGHBOR_LEFT_INDEX];
    }
    /**
     * @param {GridTile} tile
     * @returns {boolean}
     */
    isNeighborRight(tile) {
      return tile === this.neighbors[NEIGHBOR_RIGHT_INDEX];
    }
    /**
     * @param {GridTile} tile
     * @returns {boolean}
     */
    isNeighborTop(tile) {
      return tile === this.neighbors[NEIGHBOR_TOP_INDEX];
    }
    /**
     * @param {GridTile} tile
     * @returns {boolean}
     */
    isNeighborBottom(tile) {
      return tile === this.neighbors[NEIGHBOR_BOTTOM_INDEX];
    }
    /**
     * @param {Vector} coordinate 
     * @returns {GridTile}
     */
    findNeighborContaining(coordinate) {
      for (let i = 0; i < this.neighbors.length; i++) {
        const neighbor = this.neighbors[i];
        if (neighbor && neighbor.contains(coordinate)) {
          return neighbor;
        }
      }
      const topLeft = this.getNeighborTopLeft();
      if (topLeft && topLeft.contains(coordinate)) {
        return topLeft;
      }
      const topRight = this.getNeighborTopRight();
      if (topRight && topRight.contains(coordinate)) {
        return topRight;
      }
      const bottomLeft = this.getNeighborBottomLeft();
      if (bottomLeft && bottomLeft.contains(coordinate)) {
        return bottomLeft;
      }
      const bottomRight = this.getNeighborBottomRight();
      if (bottomRight && bottomRight.contains(coordinate)) {
        return bottomRight;
      }
      return null;
    }
    /**
     * @param {number} tileColDelta 
     * @param {number} tileRowDelta 
     * @returns {GridTile}
     */
    findRelativeTile(tileColDelta, tileRowDelta) {
      const worldGrid = this.getGrid().getWorldGrid();
      const tileCol = this.getTileCol() + tileColDelta;
      const tileRow = this.getTileRow() + tileRowDelta;
      return worldGrid.getGridTile(tileCol, tileRow);
    }
    evaluateBorders() {
      if (this.open) {
        this.borderCode = 0;
        this.sprite = null;
      } else {
        const prevBorderCode = this.borderCode, topNeighbor = this.neighbors[NEIGHBOR_TOP_INDEX], bottomNeighbor = this.neighbors[NEIGHBOR_BOTTOM_INDEX], rightNeighbor = this.neighbors[NEIGHBOR_RIGHT_INDEX], leftNeighbor = this.neighbors[NEIGHBOR_LEFT_INDEX];
        const n = topNeighbor && topNeighbor.open ? 1 : 0, s = bottomNeighbor && bottomNeighbor.open ? 2 : 0, w = leftNeighbor && leftNeighbor.open ? 4 : 0, e = rightNeighbor && rightNeighbor.open ? 8 : 0;
        this.borderCode = n + s + w + e;
        if (prevBorderCode !== this.borderCode && this.tileTemplate) {
          this.sprite = this.tileTemplate.getTileSprite(this.borderCode);
        }
      }
    }
    // /**
    //  * Invoked on an open tile that has been made closed.
    //  */
    // onTileFilled() {
    //     // Change the state to closed
    //     this.open = false;
    //     // Force the border code to be calculated.
    //     this.borderCode = -1;
    //     // Update the sprite.
    //     this.evaluateBorders();
    //     // Update the state change and add the tile to the grid state change collection.
    //     this.handleTileClosed();
    //     this.health = null;        
    //     // Mark the grid state as changed.
    //     this.getGrid().markGridAsChanged();
    //     //////this.calculateTileHealth();
    //     // Update the neighbor tile borders
    //     for (let i = 0; i < this.neighbors.length; i++) {
    //         const neighbor = this.neighbors[i];
    //         if (neighbor) {
    //             neighbor.evaluateBorders();
    //         }
    //     }
    // }
    /**
     * Invoked when a character has mined the tile.
     * @param {BigNum} damage The damage in the current frame
     */
    onTileDamaged(damage) {
      if (this.open || !damage) {
        return;
      }
      if (!this.health) {
        this.calculateTileHealth();
      }
      this.health.sub(damage);
      if (this.health.lessThanEqualsZero()) {
        this.onTileBreak();
      } else {
        this.healthPercent = this.calculateHealthPercent();
      }
    }
    /**
     * @private
     * @returns {number}
     */
    calculateHealthPercent() {
      if (this.open) {
        return 0;
      }
      if (!this.health) {
        return 100;
      }
      if (this.health.equalsZero()) {
        return 0;
      }
      WORKING_PERCENT.copy(this.health);
      WORKING_PERCENT.divide(this.initialHealth);
      const ratio = WORKING_PERCENT.toNumber();
      return ratio * 100 | 0;
    }
    /**
     * @returns {boolean}
     */
    isTileDamaged() {
      if (this.open) {
        return false;
      }
      if (!this.health) {
        return false;
      }
      return !this.health.equals(this.initialHealth);
    }
    /**
     * Invoked on the tile when it has been broken.
     */
    onTileBreak() {
      if (!this.open) {
        this.open = true;
        this.borderCode = -1;
        this.evaluateBorders();
        this.handleTileOpened();
        const top = this.getNeighborTop();
        if (top && top.open && top.fixtureDescription) {
          top.fixtureDescription = null;
        }
        const bottom = this.getNeighborBottom();
        if (bottom && bottom.open && bottom.fixtureDescription) {
          bottom.fixtureDescription = null;
        }
        this.pathData.mineScore = 0;
        this.pathData.mineVectorFieldNumber = 0;
        this.health = null;
        this.initialHealth = null;
        this.healthPercent = 0;
        if (this.mineTileIndex >= 0) {
          this.region.mineTiles[this.mineTileIndex] = null;
          this.mineTileIndex = -1;
        }
        this.getGrid().markGridAsChanged();
      }
      for (let i = 0; i < this.neighbors.length; i++) {
        const neighbor = this.neighbors[i];
        if (neighbor) {
          neighbor.evaluateBorders();
        }
      }
    }
    /**
     * @private
     */
    handleTileOpened() {
      if (!this.open) {
        return;
      }
      const neighborTop = this.getNeighborTop();
      if (neighborTop && neighborTop.open && neighborTop.lighting.sunlightFull) {
        this.handleSunlightStart();
      }
    }
    /**
     */
    handleSunlightStart() {
      this.markAsSunlightFull();
      const neighborLeft = this.getNeighborLeft();
      if (neighborLeft && !neighborLeft.lighting.sunlightFull) {
        neighborLeft.lighting.sunlightPartialIncrement();
      }
      const neighborRight = this.getNeighborRight();
      if (neighborRight && !neighborRight.lighting.sunlightFull) {
        neighborRight.lighting.sunlightPartialIncrement();
      }
      if (!this.open) {
        return;
      }
      const neighborBottom = this.getNeighborBottom();
      if (neighborBottom && !neighborBottom.lighting.sunlightFull) {
        neighborBottom.handleSunlightStart();
      }
    }
    /**
     */
    handleSunlightStop() {
      this.lighting.sunlightFull = false;
      const neighborLeft = this.getNeighborLeft();
      if (neighborLeft) {
        neighborLeft.lighting.sunlightPartialDecrement();
      }
      const neighborRight = this.getNeighborRight();
      if (neighborRight) {
        neighborRight.lighting.sunlightPartialDecrement();
      }
      if (!this.open) {
        return;
      }
      const neighborBottom = this.getNeighborBottom();
      if (neighborBottom && neighborBottom.lighting.sunlightFull) {
        neighborBottom.handleSunlightStop();
      }
    }
    //////////////////////////////////////////////////
    // Lighting
    //////////////////////////////////////////////////
    markTileAsEverVisible() {
      this.lighting.everVisibleToCharacter = true;
      if (this.mineTileIndex < 0 && !this.open && (this.isCurrency() || this.isPriority())) {
        this.region.mineTiles.push(this);
        this.mineTileIndex = this.region.mineTiles.length - 1;
      }
    }
    markTileAsCurrentlyVisible() {
      this.lighting.markTileAsCurrentlyVisible();
      if (this.mineTileIndex < 0 && !this.open && (this.isCurrency() || this.isPriority())) {
        this.region.mineTiles.push(this);
        this.mineTileIndex = this.region.mineTiles.length - 1;
      }
    }
    markAsSunlightFull() {
      this.lighting.markAsSunlightFull();
      if (this.mineTileIndex < 0 && !this.open && (this.isCurrency() || this.isPriority())) {
        this.region.mineTiles.push(this);
        this.mineTileIndex = this.region.mineTiles.length - 1;
      }
    }
    /**
     * @param {Color} lightColor
     */
    addPositionalLighting(lightColor) {
      this.lighting.addPositionalLighting(lightColor);
      this.markTileAsCurrentlyVisible();
    }
    /**
     * @param {Color} lightColor
     */
    addEnvironmentLighting(lightColor) {
      this.lighting.addEnvironmentLighting(lightColor);
      this.markTileAsEverVisible();
    }
    /**
     * @param {Color} lightColor
     */
    addDynamicLighting(lightColor) {
      this.lighting.addDynamicLighting(lightColor);
      this.markTileAsEverVisible();
    }
    //////////////////////////////////////////////////
    // Hash
    //////////////////////////////////////////////////
    /**
     * Returns the hash for the grid tile.
     * @returns {number}
     */
    hash() {
      const col = this.origin.x / Settings.tile.size;
      const row = this.origin.y / Settings.tile.size;
      let hash = 17;
      hash = 31 * hash + col;
      hash = 31 * hash + row;
      return hash;
    }
  };

  // src/model/grid/GridZone.js
  var GridZone = class extends GridBox {
    /**
     * @param {Grid} grid 
     * @param {Vector} origin 
     */
    constructor(grid, origin) {
      super(origin);
      this.grid = grid;
      this.regions = this.createRegions();
    }
    /**
     * @private
     * @returns {Array.<GridRegion>}
     */
    createRegions() {
      const origin = this.getOrigin();
      const x = origin.x;
      const y = origin.y;
      const regions = new Array(Settings.grid.numRegionColsInZone * Settings.grid.numRegionRowsInZone);
      let i = 0;
      for (let col = 0; col < Settings.grid.numRegionColsInZone; col++) {
        for (let row = 0; row < Settings.grid.numRegionRowsInZone; row++) {
          regions[i++] = new GridRegion(this, new Vector(x + Settings.grid.regionPixelWidth * col, y + Settings.grid.regionPixelHeight * row));
        }
      }
      return regions;
    }
    /**
     * Invoked when the parent grid is assigned a new location.
     * @param {number} originX 
     * @param {number} originY 
     */
    initialize(originX, originY) {
      this.origin.set(originX, originY);
      const x = this.origin.x;
      const y = this.origin.y;
      let i = 0;
      for (let col = 0; col < Settings.grid.numRegionColsInZone; col++) {
        for (let row = 0; row < Settings.grid.numRegionRowsInZone; row++) {
          const region = this.regions[i++];
          region.initialize(x + Settings.grid.regionPixelWidth * col, y + Settings.grid.regionPixelHeight * row);
        }
      }
    }
    /**
     * @returns {WorldGrid}
     */
    getWorldGrid() {
      return this.grid.getWorldGrid();
    }
    /**
     * @returns {Grid}
     */
    getGrid() {
      return this.grid;
    }
    /**
     * @returns {Array.<GridRegion>}
     */
    getRegions() {
      return this.regions;
    }
    /**
     * @returns {number}
     */
    getPixelWidth() {
      return Settings.grid.zonePixelWidth;
    }
    /**
     * @returns {number}
     */
    getPixelHeight() {
      return Settings.grid.zonePixelHeight;
    }
    /**
     * @param {number} tileCol 
     * @param {number} tileRow 
     * @returns {GridTile}
     */
    getGridTileAbsolute(tileCol, tileRow) {
      const origin = this.origin;
      const tileOriginCol = Fast.floor(origin.x / Settings.tile.size);
      const tileOriginRow = Fast.floor(origin.y / Settings.tile.size);
      return this.getGridTileLocal(tileCol - tileOriginCol, tileRow - tileOriginRow);
    }
    /**
     * @param {number} tileCol 
     * @param {number} tileRow 
     * @returns {GridTile}
     */
    getGridTileLocal(tileCol, tileRow) {
      const regionCol = Fast.floor(tileCol / Settings.grid.regionTileWidth);
      const regionRow = Fast.floor(tileRow / Settings.grid.regionTileHeight);
      if (regionCol < 0 || regionCol >= Settings.grid.numRegionColsInZone) {
        return null;
      }
      if (regionRow < 0 || regionRow >= Settings.grid.numRegionRowsInZone) {
        return null;
      }
      const index = regionCol * Settings.grid.numRegionRowsInZone + regionRow;
      if (index >= 0 && index < this.regions.length) {
        const region = this.regions[index];
        const zoneOrigin = this.getOrigin();
        const zoneTileOriginCol = Fast.floor(zoneOrigin.x / Settings.tile.size);
        const zoneTileOriginRow = Fast.floor(zoneOrigin.y / Settings.tile.size);
        const regionOrigin = region.getOrigin();
        const regionTileOriginCol = Fast.floor(regionOrigin.x / Settings.tile.size);
        const regionTileOriginRow = Fast.floor(regionOrigin.y / Settings.tile.size);
        return region.getGridTileLocal(tileCol + zoneTileOriginCol - regionTileOriginCol, tileRow + zoneTileOriginRow - regionTileOriginRow);
      } else {
        console.log("GridZone.getGridTileLocal() Failed to find tile. col=" + tileCol + " row=" + tileRow + " index=" + index);
        return null;
      }
    }
    /**
     * @private
     */
    findTileNeighborsFull() {
      for (let i = 0; i < this.regions.length; i++) {
        this.regions[i].findTileNeighborsFull();
      }
    }
    findRegionNeighborsBorderEast() {
      const eastCol = Settings.grid.numRegionColsInZone - 1;
      for (let row = 0; row < Settings.grid.numRegionRowsInZone; row++) {
        this.findRegion(eastCol, row).findTileNeighborsBorderRight();
      }
    }
    findRegionNeighborsBorderWest() {
      for (let row = 0; row < Settings.grid.numRegionRowsInZone; row++) {
        this.findRegion(0, row).findTileNeighborsBorderLeft();
      }
    }
    findRegionNeighborsBorderSouth() {
      const southRow = Settings.grid.numRegionColsInZone - 1;
      for (let col = 0; col < Settings.grid.numRegionColsInZone; col++) {
        this.findRegion(col, southRow).findTileNeighborsBorderBottom();
      }
    }
    findRegionNeighborsBorderNorth() {
      for (let col = 0; col < Settings.grid.numRegionColsInZone; col++) {
        this.findRegion(col, 0).findTileNeighborsBorderTop();
      }
    }
    /**
     * @param {number} col
     * @param {number} row
     * @returns {GridRegion}
     */
    findRegion(col, row) {
      return this.regions[col * Settings.grid.numRegionRowsInZone + row];
    }
    // tile neighbors for zone/zone boundaries
    findZoneBorderRegionNeighbors() {
      const eastCol = Settings.grid.numRegionColsInZone - 1;
      const northRow = Settings.grid.numRegionRowsInZone - 1;
      const southRow = 0;
      const westCol = 0;
      const regionNE = this.findRegion(eastCol, northRow);
      const regionSE = this.findRegion(eastCol, southRow);
      const regionNW = this.findRegion(westCol, northRow);
      const regionSW = this.findRegion(westCol, southRow);
      regionNE.findTileNeighborsBorderTop();
      regionNE.findTileNeighborsBorderRight();
      regionSE.findTileNeighborsBorderBottom();
      regionSE.findTileNeighborsBorderRight();
      regionNW.findTileNeighborsBorderTop();
      regionNW.findTileNeighborsBorderLeft();
      regionSW.findTileNeighborsBorderBottom();
      regionSW.findTileNeighborsBorderLeft();
      if (Settings.grid.numRegionRowsInZone > 2) {
        for (let row = 1; row < Settings.grid.numRegionRowsInZone - 1; row++) {
          this.findRegion(eastCol, row).findTileNeighborsBorderRight();
        }
        for (let row = 1; row < Settings.grid.numRegionRowsInZone - 1; row++) {
          this.findRegion(westCol, row).findTileNeighborsBorderLeft();
        }
      }
      if (Settings.grid.numRegionColsInZone > 2) {
        for (let col = 1; col < Settings.grid.numRegionColsInZone - 1; col++) {
          this.findRegion(col, southRow).findTileNeighborsBorderBottom();
        }
        for (let col = 1; col < Settings.grid.numRegionColsInZone - 1; col++) {
          this.findRegion(col, northRow).findTileNeighborsBorderTop();
        }
      }
    }
    findTileNeighborsZoneBorderRight() {
      const eastCol = Settings.grid.numRegionColsInZone - 1;
      for (let row = 0; row < Settings.grid.numRegionRowsInZone; row++) {
        this.findRegion(eastCol, row).findTileNeighborsBorderRight();
      }
    }
    nullifyTileNeighborsZoneBorderRight() {
      const eastCol = Settings.grid.numRegionColsInZone - 1;
      for (let row = 0; row < Settings.grid.numRegionRowsInZone; row++) {
        this.findRegion(eastCol, row).nullifyTileNeighborsBorderRight();
      }
    }
    findTileNeighborsZoneBorderLeft() {
      for (let row = 0; row < Settings.grid.numRegionRowsInZone; row++) {
        this.findRegion(0, row).findTileNeighborsBorderLeft();
      }
    }
    nullifyTileNeighborsZoneBorderLeft() {
      for (let row = 0; row < Settings.grid.numRegionRowsInZone; row++) {
        this.findRegion(0, row).nullifyTileNeighborsBorderLeft();
      }
    }
    findTileNeighborsZoneBorderBottom() {
      const southRow = Settings.grid.numRegionRowsInZone - 1;
      for (let col = 0; col < Settings.grid.numRegionColsInZone; col++) {
        this.findRegion(col, southRow).findTileNeighborsBorderBottom();
      }
    }
    nullifyTileNeighborsZoneBorderBottom() {
      const southRow = Settings.grid.numRegionRowsInZone - 1;
      for (let col = 0; col < Settings.grid.numRegionColsInZone; col++) {
        this.findRegion(col, southRow).nullifyTileNeighborsBorderBottom();
      }
    }
    findTileNeighborsZoneBorderTop() {
      for (let col = 0; col < Settings.grid.numRegionColsInZone; col++) {
        this.findRegion(col, 0).findTileNeighborsBorderTop();
      }
    }
    nullifyTileNeighborsZoneBorderTop() {
      for (let col = 0; col < Settings.grid.numRegionColsInZone; col++) {
        this.findRegion(col, 0).nullifyTileNeighborsBorderTop();
      }
    }
    ///////////////////////////////////////
    // Tile Border Evaluation
    ///////////////////////////////////////
    evaluateTileBordersRight() {
      const eastCol = Settings.grid.numRegionColsInZone - 1;
      for (let row = 0; row < Settings.grid.numRegionRowsInZone; row++) {
        this.findRegion(eastCol, row).evaluateTileBordersRight();
      }
    }
    evaluateTileBordersLeft() {
      for (let row = 0; row < Settings.grid.numRegionRowsInZone; row++) {
        this.findRegion(0, row).evaluateTileBordersLeft();
      }
    }
    evaluateTileBordersBottom() {
      const southRow = Settings.grid.numRegionRowsInZone - 1;
      for (let col = 0; col < Settings.grid.numRegionColsInZone; col++) {
        this.findRegion(col, southRow).evaluateTileBordersBottom();
      }
    }
    evaluateTileBordersTop() {
      for (let col = 0; col < Settings.grid.numRegionColsInZone; col++) {
        this.findRegion(col, 0).evaluateTileBordersTop();
      }
    }
  };

  // src/Projection.js
  var Projection = class extends GameModel {
    constructor() {
      super();
      this.gridCenter = new Vector(Settings.start.startX, Settings.start.startY);
      this.stayCenteredOnCharacter = true;
      this.screenOrigin = new Vector(0, 0);
      this.visibleHalfWidth = 0;
      this.visibleHalfHeight = 0;
      this.visibleHalfWidthWorld = 0;
      this.visibleHalfHeightWorld = 0;
      this.screenScaleFactor = 1;
      this.zoom = Settings.projection.zoomDefault;
      this.canvas = null;
    }
    /**
     * @param {HTMLCanvasElement} canvas 
     */
    setCanvas(canvas) {
      this.canvas = canvas;
    }
    resetProjectionState() {
      this.setGridCenter(Settings.projection.startCenterX, Settings.projection.startCenterY);
      this.zoom = Settings.projection.zoomDefault;
      this.canvas = null;
    }
    /**
     * Sets the coordinate of grid that is at the center of the screen.
     * @param {number} worldX
     * @param {number} worldY
     */
    setGridCenter(worldX, worldY) {
      this.gridCenter.set(worldX, worldY);
    }
    /**
     * @param {number} deltaX
     * @param {number} deltaY
     */
    updateSpaceCenter(deltaX, deltaY) {
      this.gridCenter.addXY(deltaX, deltaY);
    }
    updateProjectionForFrame() {
      if (!this.canvas) {
        return;
      }
      this.visibleHalfWidth = this.canvas.width / 2;
      this.visibleHalfHeight = this.canvas.height / 2;
      this.visibleHalfWidthWorld = this.visibleHalfWidth / this.zoom;
      this.visibleHalfHeightWorld = this.visibleHalfHeight / this.zoom;
      this.screenOrigin.set(
        this.zoom * this.gridCenter.x - this.visibleHalfWidth,
        this.zoom * this.gridCenter.y - this.visibleHalfHeight
      );
      this.screenOrigin.x = this.screenOrigin.x | 0;
      this.screenOrigin.y = this.screenOrigin.y | 0;
    }
    /**
     * @param {number} screenDistance
     * @returns {number}
     */
    screenToWorldDistance(screenDistance) {
      return screenDistance / this.zoom;
    }
    /**
     * @param {Vector} screenCoordinate
     * @param {Vector} worldCoordinate The output vector.
     */
    screenToWorld(screenCoordinate, worldCoordinate) {
      var factor = 1 / this.zoom;
      worldCoordinate.set(
        factor * (this.screenOrigin.x + screenCoordinate.x),
        factor * (this.screenOrigin.y + screenCoordinate.y)
      );
    }
    // /**
    //  * @param {Vector} screenCoordinate
    //  * @param {Vector} worldCoordinate The output vector.
    //  * @returns {number}
    //  */
    // screenToWorld(screenCoordinate, worldCoordinate) {
    //     var factor = 1.0 / this.zoom;
    //
    //     worldCoordinate.set(
    //         factor * (this.screenOrigin.x + screenCoordinate.x),
    //         factor * (this.screenOrigin.y + (Game.canvas.height - screenCoordinate.y))
    //     );
    // }
    /**
     * @param {Vector} worldCoordinate
     * @param {Vector} screenCoordinate The output vector.
     */
    worldToScreen(worldCoordinate, screenCoordinate) {
      screenCoordinate.x = this.zoom * worldCoordinate.x - this.screenOrigin.x;
      screenCoordinate.y = this.zoom * worldCoordinate.y - this.screenOrigin.y;
    }
    // /**
    //  * @param {Vector} worldCoordinate
    //  */
    // isWorldCoordinateVisible(worldCoordinate) {
    //     this.worldToScreen(worldCoordinate, this.internalScreenPosition);
    //
    //     return this.internalScreenPosition.x >= 0 && this.internalScreenPosition.x <= Game.canvas.width
    //         && this.internalScreenPosition.y >= 0 && this.internalScreenPosition.y <= Game.canvas.height;
    // }
    /**
     * @param {number} zoom 
     */
    setZoom(zoom) {
      this.zoom = zoom;
      if (this.zoom < Settings.projection.zoomOutScaleLimit) {
        this.zoom = Settings.projection.zoomOutScaleLimit;
      }
      if (this.zoom > Settings.projection.zoomInScaleLimit) {
        this.zoom = Settings.projection.zoomInScaleLimit;
      }
    }
    zoomOut() {
      this.zoom -= Settings.projection.zoomStep;
      if (this.zoom < Settings.projection.zoomOutScaleLimit) {
        this.zoom = Settings.projection.zoomOutScaleLimit;
      }
    }
    zoomIn() {
      this.zoom += Settings.projection.zoomStep;
      if (this.zoom > Settings.projection.zoomInScaleLimit) {
        this.zoom = Settings.projection.zoomInScaleLimit;
      }
    }
    /**
     * @param {GridBox} gridBox 
     * @param {Vector} nearbyOrigin 
     * @param {number} nearbyRadius 
     * @returns {boolean}
     */
    isNearby(gridBox, nearbyOrigin, nearbyRadius) {
      return this.isNearbyX(gridBox.origin.x, gridBox.getPixelWidth(), nearbyOrigin, nearbyRadius) && this.isNearbyY(gridBox.origin.y, gridBox.getPixelHeight(), nearbyOrigin, nearbyRadius);
    }
    /**
     * @param {number} x
     * @param {number} y
     * @param {Vector} nearbyOrigin 
     * @param {number} nearbyRadius 
     * @returns {boolean}
     */
    isNearbyXY(x, y, nearbyOrigin, nearbyRadius) {
      return this.isNearbyX(x, 1, nearbyOrigin, nearbyRadius) && this.isNearbyY(y, 1, nearbyOrigin, nearbyRadius);
    }
    /**
     * @param {Vector} position 
     * @param {number} size 
     * @returns {boolean}
     */
    isVisible(position, size) {
      return this.isVisibleX(position.x, size) && this.isVisibleY(position.y, size);
    }
    /**
     * @param {number} x 
     * @param {number} y 
     * @param {number} size 
     * @returns {boolean}
     */
    isVisibleXY(x, y, size) {
      return this.isVisibleX(x, size) && this.isVisibleY(y, size);
    }
    /**
     * @param {GridBox} gridBox 
     * @returns {boolean}
     */
    isVisibleGridBox(gridBox) {
      return this.isVisibleX(gridBox.origin.x, gridBox.getPixelWidth()) && this.isVisibleY(gridBox.origin.y, gridBox.getPixelHeight());
    }
    // isVisibleRectangle(rectangle) {
    //     return this.isVisibleX(rectangle.x, rectangle.width) && this.isVisibleY(rectangle.y, rectangle.height);
    // }
    // /**
    //  * @private
    //  * @param {number} x 
    //  * @param {number} width 
    //  * @returns {boolean}
    //  */
    // isVisibleX(x, width) {
    //     return (x < this.gridCenter.x + this.visibleHalfWidthWorld) && (x + width >= this.gridCenter.x - this.visibleHalfWidthWorld);
    // }
    /**
     * @private
     * @param {number} x 
     * @param {number} width 
     * @returns {boolean}
     */
    isVisibleX(x, width) {
      return x < this.gridCenter.x + this.visibleHalfWidthWorld && x + width >= this.gridCenter.x - this.visibleHalfWidthWorld;
    }
    /**
     * @private
     * @param {number} y 
     * @param {number} height 
     * @returns {boolean}
     */
    isVisibleY(y, height) {
      return y < this.gridCenter.y + this.visibleHalfHeightWorld && y + height >= this.gridCenter.y - this.visibleHalfHeightWorld;
    }
    /**
     * @returns {number}
     */
    getMaxVisibleHalfWidth() {
      return Math.max(this.visibleHalfHeightWorld, this.visibleHalfWidthWorld);
    }
    /**
     * @private
     * @param {number} x
     * @param {number} width 
     * @param {Vector} nearbyOrigin 
     * @param {number} nearbyRadius 
     * @returns {boolean} 
     */
    isNearbyX(x, width, nearbyOrigin, nearbyRadius) {
      return x < nearbyOrigin.x + nearbyRadius && x + width >= nearbyOrigin.x - nearbyRadius;
    }
    /**
     * @private
     * @param {number} y
     * @param {number} height 
     * @param {Vector} nearbyOrigin 
     * @param {number} nearbyRadius 
     * @returns {boolean}
     */
    isNearbyY(y, height, nearbyOrigin, nearbyRadius) {
      return y < nearbyOrigin.y + nearbyRadius && y + height >= nearbyOrigin.y - nearbyRadius;
    }
    // This is never called:
    /**
     * @param {Vector} screenCoordinate 
     * @param {number} screenWidth 
     * @param {number} screenHeight 
     */
    clampToScreen(screenCoordinate, screenWidth, screenHeight) {
      const x = Math.min(Math.max(screenCoordinate.x, 0), this.canvas.width - screenWidth);
      const y = Math.min(Math.max(screenCoordinate.y, 0), this.canvas.height - screenHeight);
      screenCoordinate.set(x, y);
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.resetProjectionState();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetProjectionState();
    }
  };

  // src/model/grid/GridInversionOfControl.js
  var GridInversionOfControl = class {
    constructor() {
    }
    /**
     * @param {WorldGrid} worldGrid
     * @param {Projection} projection 
     * @param {Function} gridCallback Accepts a grid as a parameter
     */
    static allVisibleGrids(worldGrid, projection, gridCallback) {
      const grids = worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const grid = grids[i];
        if (grid && grid.loaded && projection.isVisibleGridBox(grid)) {
          gridCallback(grid);
        }
      }
    }
    /**
     * @param {WorldGrid} worldGrid
     * @param {Projection} projection 
     * @param {Function} regionCallback Accepts a region as a parameter
     */
    static allVisibleRegions(worldGrid, projection, regionCallback) {
      const grids = worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const grid = grids[i];
        if (grid && grid.loaded && projection.isVisibleGridBox(grid)) {
          this.allVisibleRegionsInGrid(grid, projection, regionCallback);
        }
      }
    }
    /**
     * @param {WorldGrid} worldGrid
     * @param {Projection} projection 
     * @param {Function} tileCallback Accepts a GridTile as a parameter
     */
    static allVisibleTiles(worldGrid, projection, tileCallback) {
      const grids = worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const grid = grids[i];
        if (!grid) {
          continue;
        }
        if (projection.isVisibleGridBox(grid)) {
          this.allVisibleTilesInGrid(grid, projection, tileCallback);
        }
      }
    }
    /**
     * @param {WorldGrid} worldGrid
     * @param {Projection} projection 
     * @param {Vector} nearbyOrigin 
     * @param {number} nearbyRadius The radius in pixels, not tiles.
     * @param {Function} regionCallback Accepts a region as a parameter
     */
    static allNearbyRegions(worldGrid, projection, nearbyOrigin, nearbyRadius, regionCallback) {
      const grids = worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const grid = grids[i];
        if (!grid || !grid.isLoaded()) {
          continue;
        }
        if (grid.contains(nearbyOrigin) || projection.isNearby(grid, nearbyOrigin, nearbyRadius)) {
          this.allNearbyRegionsInGrid(grid, projection, regionCallback, nearbyOrigin, nearbyRadius);
        }
      }
    }
    /**
     * @param {Grid} grid 
     * @param {Projection} projection 
     * @param {Function} tileCallback Accepts a GridTile as a parameter
     */
    static allVisibleTilesInGrid(grid, projection, tileCallback) {
      if (!grid) {
        return;
      }
      const zones = grid.zones;
      for (let z = 0; z < zones.length; z++) {
        const zone = zones[z];
        if (projection.isVisibleGridBox(zone)) {
          const regions = zone.getRegions();
          for (let r = 0; r < regions.length; r++) {
            const region = regions[r];
            if (projection.isVisibleGridBox(region)) {
              const tiles = region.getTiles();
              for (let t = 0; t < tiles.length; t++) {
                const tile = tiles[t];
                if (projection.isVisibleGridBox(tile)) {
                  tileCallback(tile);
                }
              }
            }
          }
        }
      }
    }
    /**
     * @param {Grid} grid 
     * @param {Function} tileCallback Accepts a GridTile as a parameter
     */
    static allTilesInGrid(grid, tileCallback) {
      if (!grid) {
        return;
      }
      const zones = grid.zones;
      for (let z = 0; z < zones.length; z++) {
        const regions = zones[z].getRegions();
        for (let r = 0; r < regions.length; r++) {
          const tiles = regions[r].getTiles();
          for (let t = 0; t < tiles.length; t++) {
            tileCallback(tiles[t]);
          }
        }
      }
    }
    /**
     * @param {GridZone} zone
     * @param {Function} tileCallback Accepts a GridTile as a parameter
     */
    static allTilesInGridZone(zone, tileCallback) {
      if (!zone) {
        return;
      }
      const regions = zone.getRegions();
      for (let r = 0; r < regions.length; r++) {
        const tiles = regions[r].getTiles();
        for (let t = 0; t < tiles.length; t++) {
          tileCallback(tiles[t]);
        }
      }
    }
    /**
     * @private
     * @param {Grid} grid 
     * @param {Projection} projection 
     * @param {Function} regionCallback Accepts a region as a parameter
     */
    static allVisibleRegionsInGrid(grid, projection, regionCallback) {
      if (!grid) {
        return;
      }
      const zones = grid.zones;
      for (let z = 0; z < zones.length; z++) {
        const zone = zones[z];
        if (projection.isVisibleGridBox(zone)) {
          const regions = zone.getRegions();
          for (let r = 0; r < regions.length; r++) {
            const region = regions[r];
            if (projection.isVisibleGridBox(region)) {
              regionCallback(region);
            }
          }
        }
      }
    }
    /**
     * @private
     * @param {Grid} grid 
     * @param {Projection} projection 
     * @param {Function} regionCallback Accepts a region as a parameter
     * @param {Vector} nearbyOrigin 
     * @param {number} nearbyRadius The radius in pixels, not tiles.
     */
    static allNearbyRegionsInGrid(grid, projection, regionCallback, nearbyOrigin, nearbyRadius) {
      if (!grid) {
        return;
      }
      const zones = grid.zones;
      for (let z = 0; z < zones.length; z++) {
        const zone = zones[z];
        if (projection.isNearby(zone, nearbyOrigin, nearbyRadius)) {
          const regions = zone.getRegions();
          for (let r = 0; r < regions.length; r++) {
            const region = regions[r];
            if (projection.isNearby(region, nearbyOrigin, nearbyRadius)) {
              regionCallback(region);
            }
          }
        }
      }
    }
    /**
     * @param {Grid} grid 
     * @param {Function} regionCallback Accepts a region as a parameter
     */
    static allRegionsInGrid(grid, regionCallback) {
      if (!grid) {
        return;
      }
      const zones = grid.zones;
      for (let z = 0; z < zones.length; z++) {
        const zone = zones[z];
        const regions = zone.getRegions();
        for (let r = 0; r < regions.length; r++) {
          regionCallback(regions[r]);
        }
      }
    }
  };

  // src/model/lighting/LightSource.js
  var LightSource = class extends CachedInstance {
    constructor() {
      super();
      this.color = null;
      this.radius = 0;
      this.tile = null;
    }
    /**
     * @param {GridTile} tile
     * @param {Color} color 
     * @param {number} radius 
     */
    set(tile, color, radius) {
      this.tile = tile;
      this.color = color;
      this.radius = radius;
    }
    /**
     * @returns {GridTile}
     */
    getTile() {
      return this.tile;
    }
    /**
     * @param {GridTile} tile 
     */
    setTile(tile) {
      this.tile = tile;
    }
    /**
     * @returns {Color}
     */
    getColor() {
      return this.color;
    }
    /**
     * @returns {number}
     */
    getTileRadius() {
      return this.radius;
    }
    /////////////////////////////////////////////
    // CachedInstance
    /////////////////////////////////////////////
    /**
     * @param {boolean} finishedAndAvailable 
     */
    reset(finishedAndAvailable) {
      super.reset(finishedAndAvailable);
      this.color = null;
      this.radius = 0;
      this.tile = null;
    }
  };

  // src/model/grid/Grid.js
  var NEIGHBOR_TOP_INDEX2 = 0;
  var NEIGHBOR_BOTTOM_INDEX2 = 1;
  var NEIGHBOR_RIGHT_INDEX2 = 2;
  var NEIGHBOR_LEFT_INDEX2 = 3;
  var Grid = class extends GridBox {
    /**
     * @param {WorldGrid} worldGrid
     * @param {Vector} origin 
     */
    constructor(worldGrid, origin) {
      super(origin);
      this.worldGrid = worldGrid;
      this.gridChangeCount = 0;
      this.zones = this.createZoneArray();
      this.neighbors = new Array(4);
      this.neighbors[NEIGHBOR_TOP_INDEX2] = null;
      this.neighbors[NEIGHBOR_BOTTOM_INDEX2] = null;
      this.neighbors[NEIGHBOR_RIGHT_INDEX2] = null;
      this.neighbors[NEIGHBOR_LEFT_INDEX2] = null;
      this.characters = [];
      this.lightSources = [];
      this.loaded = false;
    }
    /**
     * @private
     * @returns {Array.<GridZone>}
     */
    createZoneArray() {
      const zones = new Array(Settings.grid.numZoneColsInGrid * Settings.grid.numZoneRowsInGrid);
      const origin = this.origin;
      const x = origin.x;
      const y = origin.y;
      let i = 0;
      for (let col = 0; col < Settings.grid.numZoneColsInGrid; col++) {
        for (let row = 0; row < Settings.grid.numZoneRowsInGrid; row++) {
          zones[i++] = new GridZone(this, new Vector(x + Settings.grid.zonePixelWidth * col, y + Settings.grid.zonePixelHeight * row));
        }
      }
      return zones;
    }
    unloadGrid() {
      if (this.characters.length > 0) {
        const size = this.characters.length;
        for (let i = size - 1; i >= 0; i--) {
          const character = this.characters[i];
          if (character.isMonster()) {
            if (!character.isFinishedAndAvailable()) {
              character.reset(true);
            }
          } else if (character.isPartyMember()) {
            console.log("Grid.unloadGrid() party character is in grid that is being unloaded.");
            character.position.resetFull();
            character.resetTurnState();
          }
        }
        this.characters.length = 0;
      }
      if (this.lightSources != null) {
        const size = this.lightSources.length;
        for (let i = size - 1; i >= 0; i--) {
          const lightSource = this.lightSources[i];
          if (!lightSource.isFinishedAndAvailable()) {
            lightSource.reset(true);
          }
        }
        this.lightSources.length = 0;
      }
      this.loaded = false;
    }
    /**
     * @returns {LightSource[]}
     */
    getLightSources() {
      return this.lightSources;
    }
    /**
     * @param {LightSource} lightSource 
     */
    addLightSource(lightSource) {
      this.lightSources.push(lightSource);
    }
    /**
     * @param {LightSource} lightSource 
     */
    removeLightSource(lightSource) {
      if (this.lightSources == null || this.lightSources.length === 0 || !lightSource) {
        return;
      }
      const index = this.lightSources.indexOf(lightSource);
      if (index >= 0) {
        this.lightSources.splice(index, 1);
      }
    }
    /**
     * @param {GridTile} tile 
     */
    removeLightSourceForTile(tile) {
      if (this.lightSources == null || this.lightSources.length === 0 || tile == null) {
        return;
      }
      for (let i = 0; i < this.lightSources.length; i++) {
        const lightSource = this.lightSources[i];
        if (lightSource.getTile() === tile) {
          this.lightSources.splice[i, 1];
          break;
        }
      }
    }
    /**
     * @param {Character} character 
     */
    addCharacter(character) {
      if (character) {
        this.characters.push(character);
      }
    }
    /**
     * @param {Character} character 
     */
    removeCharacter(character) {
      if (character) {
        const index = this.characters.indexOf(character);
        if (index !== -1) {
          this.characters.splice(index, 1);
        }
      }
    }
    /**
     * This must be invoked whenever a grid is assigned to a new location.
     */
    initializeZonesForGrid() {
      this.gridChangeCount = 0;
      const zones = this.zones;
      const origin = this.origin;
      const x = origin.x;
      const y = origin.y;
      let i = 0;
      for (let col = 0; col < Settings.grid.numZoneColsInGrid; col++) {
        for (let row = 0; row < Settings.grid.numZoneRowsInGrid; row++) {
          zones[i++].initialize(x + Settings.grid.zonePixelWidth * col, y + Settings.grid.zonePixelHeight * row);
        }
      }
    }
    /**
     * @param {Grid} top 
     * @param {Grid} bottom 
     * @param {Grid} right 
     * @param {Grid} left 
     */
    setGridNeighbors(top, bottom, right, left) {
      this.neighbors[NEIGHBOR_TOP_INDEX2] = top;
      this.neighbors[NEIGHBOR_BOTTOM_INDEX2] = bottom;
      this.neighbors[NEIGHBOR_RIGHT_INDEX2] = right;
      this.neighbors[NEIGHBOR_LEFT_INDEX2] = left;
    }
    /**
     * Invoked when the state of the grid has changed such that it should be saved.
     */
    markGridAsChanged() {
      this.gridChangeCount++;
      this.worldGrid.changeCount++;
    }
    // /**
    //  * @param {number} worldSeed 
    //  */
    // onNewWorldSeed(worldSeed) {
    //     // // If the grid is currently loaded, then we need to unload it
    //     // if (this.zones) {
    //     //     this.unloadGridInternal(false); // <-- false = do not save the grid state.
    //     // }
    // }    
    /**
     * @returns {WorldGrid}
     */
    getWorldGrid() {
      return this.worldGrid;
    }
    /**
     * @returns {boolean}
     */
    isLoaded() {
      return this.loaded;
    }
    /**
     * @returns {Array.<GridZone>}
     */
    getZones() {
      return this.zones;
    }
    /**
     * @returns {number}
     */
    getGridCol() {
      return Fast.floor(this.origin.x / Settings.grid.gridPixelWidth);
    }
    /**
     * @returns {number}
     */
    getGridRow() {
      return Fast.floor(this.origin.y / Settings.grid.gridPixelHeight);
    }
    /**
     * @returns {number}
     */
    static calculateGridCol(tileCol) {
      return Fast.floor(tileCol / Settings.grid.gridTileWidth);
    }
    /**
     * @returns {number}
     */
    static calculateGridRow(tileRow) {
      return Fast.floor(tileRow / Settings.grid.gridTileHeight);
    }
    /**
     * @returns {number}
     */
    getPixelWidth() {
      return Settings.grid.gridPixelWidth;
    }
    /**
     * @returns {number}
     */
    getPixelHeight() {
      return Settings.grid.gridPixelHeight;
    }
    // All the level generation code calls this method.
    /**
     * @param {number} tileCol 
     * @param {number} tileRow 
     * @returns {GridTile}
     */
    getGridTile(tileCol, tileRow) {
      return this.getGridTileAbsolute(tileCol, tileRow);
    }
    /**
     * @param {Vector} pixelLocation 
     * @returns {GridTile}
     */
    findGridTile(pixelLocation) {
      if (!this.contains(pixelLocation)) {
        return null;
      }
      const tileCol = Fast.floor(pixelLocation.x / Settings.tile.size);
      const tileRow = Fast.floor(pixelLocation.y / Settings.tile.size);
      return this.getGridTileAbsolute(tileCol, tileRow);
    }
    /**
     * @param {number} tileCol 
     * @param {number} tileRow 
     * @returns {GridTile}
     */
    getGridTileAbsolute(tileCol, tileRow) {
      const origin = this.origin;
      const tileOriginCol = Fast.floor(origin.x / Settings.tile.size);
      const tileOriginRow = Fast.floor(origin.y / Settings.tile.size);
      return this.getGridTileLocal(tileCol - tileOriginCol, tileRow - tileOriginRow);
    }
    /**
     * @param {number} tileCol 
     * @param {number} tileRow 
     * @returns {GridTile}
     */
    getGridTileLocal(tileCol, tileRow) {
      const zoneCol = Fast.floor(tileCol / Settings.grid.zoneTileWidth);
      const zoneRow = Fast.floor(tileRow / Settings.grid.zoneTileHeight);
      if (zoneCol < 0 || zoneCol >= Settings.grid.numZoneColsInGrid) {
        return null;
      }
      if (zoneRow < 0 || zoneRow >= Settings.grid.numZoneRowsInGrid) {
        return null;
      }
      const index = zoneCol * Settings.grid.numZoneRowsInGrid + zoneRow;
      if (index >= 0 && index < this.zones.length) {
        const zone = this.zones[index];
        const gridOrigin = this.origin;
        const gridTileOriginCol = gridOrigin.x / Settings.tile.size;
        const gridTileOriginRow = gridOrigin.y / Settings.tile.size;
        const zoneOrigin = zone.origin;
        const zoneTileOriginCol = zoneOrigin.x / Settings.tile.size;
        const zoneTileOriginRow = zoneOrigin.y / Settings.tile.size;
        return zone.getGridTileLocal(tileCol + gridTileOriginCol - zoneTileOriginCol, tileRow + gridTileOriginRow - zoneTileOriginRow);
      } else {
        console.log("Grid.getGridTileLocal() Failed to find tile. col=" + tileCol + " row=" + tileRow + " index=" + index);
        return null;
      }
    }
    /**
     * @param {number} col 
     * @param {number} row 
     * @param {TileType} tileType 
     * @returns {boolean}
     */
    isTileType(col, row, tileType) {
      const tile = this.getGridTile(col, row);
      return tile !== null && tile.getTileType() === tileType;
    }
    /**
     * @param {number} col 
     * @param {number} row 
     * @param {TileType} tileType 
     * @returns {boolean}
     */
    isNotTileType(col, row, tileType) {
      const tile = this.getGridTile(col, row);
      return tile === null || tile.getTileType() !== tileType;
    }
    /////////////////////////////////
    // Util
    /////////////////////////////////
    /**
     * @returns {Vector}
     */
    createCenterVector() {
      const center = new Vector();
      this.assignCenterVector(center);
      return center;
    }
    /**
     * @param {Vector} center 
     */
    assignCenterVector(center) {
      const halfWidth = Fast.floor(Settings.grid.gridPixelWidth / 2);
      const halfHeight = Fast.floor(Settings.grid.gridPixelHeight / 2);
      const origin = this.getOrigin();
      center.x = origin.x + halfWidth;
      center.y = origin.y + halfHeight;
    }
    ////////////////////////////////////////////////
    /**
     * Finds all the tile neighbors. This should only be called once per grid instance.
     */
    findTileNeighborsFull() {
      for (let i = 0; i < this.zones.length; i++) {
        this.zones[i].findTileNeighborsFull();
      }
    }
    /**
     * @param {WorldGrid} worldGrid
     */
    findWorldGridTileNeighbors() {
      if (this.neighbors[NEIGHBOR_TOP_INDEX2]) {
        this.findTileNeighborsGridBorderTop();
      } else {
        this.nullifyTileNeighborsGridBorderTop();
      }
      if (this.neighbors[NEIGHBOR_BOTTOM_INDEX2]) {
        this.findTileNeighborsGridBorderBottom();
      } else {
        this.nullifyTileNeighborsGridBorderBottom();
      }
      if (this.neighbors[NEIGHBOR_LEFT_INDEX2]) {
        this.findTileNeighborsGridBorderLeft();
      } else {
        this.nullifyTileNeighborsGridBorderLeft();
      }
      if (this.neighbors[NEIGHBOR_RIGHT_INDEX2]) {
        this.findTileNeighborsGridBorderRight();
      } else {
        this.nullifyTileNeighborsGridBorderRight();
      }
    }
    /**
     * Called by the GridLoader during terrain generation.
     */
    evaluateWorldGridTileNeighborBorders() {
      if (this.neighbors[NEIGHBOR_TOP_INDEX2]) {
        this.evaluateTileBordersTop();
      }
      if (this.neighbors[NEIGHBOR_BOTTOM_INDEX2]) {
        this.evaluateTileBordersBottom();
      }
      if (this.neighbors[NEIGHBOR_LEFT_INDEX2]) {
        this.evaluateTileBordersLeft();
      }
      if (this.neighbors[NEIGHBOR_RIGHT_INDEX2]) {
        this.evaluateTileBordersRight();
      }
    }
    /**
     */
    evaluateAllTileBorders() {
      GridInversionOfControl.allTilesInGrid(
        this,
        /**
         * @param {GridTile} tile 
         */
        function(tile) {
          tile.evaluateBorders();
        }
      );
    }
    /**
     * Set all border/edge tile neighbors to null.
     * We need to do this prior to terrain generation.
     */
    nullifyBorderNeighbors() {
      this.nullifyTileNeighborsGridBorderRight();
      this.nullifyTileNeighborsGridBorderLeft();
      this.nullifyTileNeighborsGridBorderBottom();
      this.nullifyTileNeighborsGridBorderTop();
    }
    /**
     * @private
     */
    findTileNeighborsGridBorderRight() {
      const eastCol = Settings.grid.numZoneColsInGrid - 1;
      for (let row = 0; row < Settings.grid.numZoneRowsInGrid; row++) {
        this.findZone(eastCol, row).findTileNeighborsZoneBorderRight();
      }
    }
    /**
     * @private
     */
    nullifyTileNeighborsGridBorderRight() {
      const eastCol = Settings.grid.numZoneColsInGrid - 1;
      for (let row = 0; row < Settings.grid.numZoneRowsInGrid; row++) {
        this.findZone(eastCol, row).nullifyTileNeighborsZoneBorderRight();
      }
    }
    /**
     * @private
     */
    evaluateTileBordersRight() {
      const eastCol = Settings.grid.numZoneColsInGrid - 1;
      for (let row = 0; row < Settings.grid.numZoneRowsInGrid; row++) {
        this.findZone(eastCol, row).evaluateTileBordersRight();
      }
    }
    /**
     * @private
     */
    findTileNeighborsGridBorderLeft() {
      for (let row = 0; row < Settings.grid.numZoneRowsInGrid; row++) {
        this.findZone(0, row).findTileNeighborsZoneBorderLeft();
      }
    }
    /**
     * @private
     */
    nullifyTileNeighborsGridBorderLeft() {
      for (let row = 0; row < Settings.grid.numZoneRowsInGrid; row++) {
        this.findZone(0, row).nullifyTileNeighborsZoneBorderLeft();
      }
    }
    /**
     * @private
     */
    evaluateTileBordersLeft() {
      for (let row = 0; row < Settings.grid.numZoneRowsInGrid; row++) {
        this.findZone(0, row).evaluateTileBordersLeft();
      }
    }
    /**
     * @private
     */
    findTileNeighborsGridBorderBottom() {
      const southRow = Settings.grid.numZoneRowsInGrid - 1;
      for (let col = 0; col < Settings.grid.numZoneColsInGrid; col++) {
        this.findZone(col, southRow).findTileNeighborsZoneBorderBottom();
      }
    }
    /**
     * @private
     */
    nullifyTileNeighborsGridBorderBottom() {
      const southRow = Settings.grid.numZoneRowsInGrid - 1;
      for (let col = 0; col < Settings.grid.numZoneColsInGrid; col++) {
        this.findZone(col, southRow).nullifyTileNeighborsZoneBorderBottom();
      }
    }
    /**
     * @private
     */
    evaluateTileBordersBottom() {
      const southRow = Settings.grid.numZoneRowsInGrid - 1;
      for (let col = 0; col < Settings.grid.numZoneColsInGrid; col++) {
        this.findZone(col, southRow).evaluateTileBordersBottom();
      }
    }
    /**
     * @private
     */
    findTileNeighborsGridBorderTop() {
      for (let col = 0; col < Settings.grid.numZoneColsInGrid; col++) {
        this.findZone(col, 0).findTileNeighborsZoneBorderTop();
      }
    }
    /**
     * @private
     */
    nullifyTileNeighborsGridBorderTop() {
      for (let col = 0; col < Settings.grid.numZoneColsInGrid; col++) {
        this.findZone(col, 0).nullifyTileNeighborsZoneBorderTop();
      }
    }
    /**
     * @private
     */
    evaluateTileBordersTop() {
      for (let col = 0; col < Settings.grid.numZoneColsInGrid; col++) {
        this.findZone(col, 0).evaluateTileBordersTop();
      }
    }
    /**
     * @private
     * @param {number} col Local col index
     * @param {number} row Local row index
     * @returns {GridZone}
     */
    findZone(col, row) {
      return this.zones[col * Settings.grid.numZoneRowsInGrid + row];
    }
  };

  // src/model/character/CharacterTarget.js
  var CharacterTarget = class {
    constructor() {
      this.targetTile = null;
      this.mineTile = null;
      this.invalidated = false;
      this.behaviorId = null;
    }
    /**
     * @param {GridTile} targetTile 
     * @param {GridTile} mineTile
     * @param {string} behaviorId
     */
    setTargetTile(targetTile, mineTile, behaviorId) {
      this.resetTarget();
      this.targetTile = targetTile;
      this.mineTile = mineTile;
      this.invalidated = false;
      this.behaviorId = behaviorId;
    }
    /**
     * 
     * @param {Grid} grid 
     */
    onGridUnload(grid) {
      if (this.targetTile && this.targetTile.grid === grid) {
        this.resetTarget();
        return;
      }
      if (this.mineTile && this.mineTile.grid === grid) {
        this.resetTarget();
      }
    }
    resetTarget() {
      this.targetTile = null;
      this.mineTile = null;
      this.invalidated = false;
      this.behaviorId = null;
    }
  };

  // src/model/path/plan/PathPlan.js
  var PathPlan = class {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      this.startTile = startTile;
      this.endTile = endTile;
      this.pathSteps = pathSteps;
      this.fallSpeedMultiplier = 1;
    }
    /**
     * @return {boolean} True if this plan requires that the character be standing on top of a solid tile when it starts.
     */
    isSolidFloorRequiredAtStart() {
      return true;
    }
    /**
     * @abstract
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
    }
    /**
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {number} tileCenterX 
     * @returns {boolean} True when the center has been reached.
     */
    walkLeftToCenterX(character, frameTimeRatio, tileCenterX) {
      const characterCenterX = character.position.worldCoordinateCenter.x;
      const distanceToEnd = Math.abs(characterCenterX - tileCenterX);
      if (distanceToEnd === 0) {
        return true;
      }
      character.setCharacterAction(CharacterAction.WALK);
      character.position.facingLeft = true;
      const walkDistancePerFrame = this.getWalkDistanceThisFrame(frameTimeRatio);
      if (distanceToEnd < walkDistancePerFrame) {
        character.position.moveX(-distanceToEnd);
        return true;
      } else {
        character.position.moveX(-walkDistancePerFrame);
        return false;
      }
    }
    /**
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {number} tileCenterX 
     * @returns {boolean} True when the center has been reached.
     */
    walkRightToCenterX(character, frameTimeRatio, tileCenterX) {
      const characterCenterX = character.position.worldCoordinateCenter.x;
      const distanceToEnd = Math.abs(tileCenterX - characterCenterX);
      if (distanceToEnd === 0) {
        return true;
      }
      character.setCharacterAction(CharacterAction.WALK);
      character.position.facingLeft = false;
      const walkDistancePerFrame = this.getWalkDistanceThisFrame(frameTimeRatio);
      if (distanceToEnd < walkDistancePerFrame) {
        character.position.moveX(distanceToEnd);
        return true;
      } else {
        character.position.moveX(walkDistancePerFrame);
        return false;
      }
    }
    /**
     * Jump from a lower position to a higher position that is directly above.
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {Vector} endTile
     * @returns {boolean} True when done
     */
    jumpUp(character, frameTimeRatio, endTile) {
      character.setCharacterAction(CharacterAction.JUMP);
      const yDistancePerFrame = this.getJumpDistanceThisFrame(frameTimeRatio);
      const distanceToJumpTop = character.position.worldCoordinateOrigin.y - endTile.origin.y;
      if (distanceToJumpTop < yDistancePerFrame) {
        character.position.setY(endTile.origin.y);
        return true;
      } else {
        character.position.moveY(-yDistancePerFrame);
        return false;
      }
    }
    /**
     * Jump from a lower position to a higher position that is to the left.
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {Vector} jumpCoordinate 
     * @param {Vector} landCoordinate 
     */
    jumpUpAndLeft(character, frameTimeRatio, jumpCoordinate, landCoordinate) {
      const jumpCoordinateX = jumpCoordinate.x;
      const landCoordinateX = landCoordinate.x;
      const halfJumpDistance = (jumpCoordinateX - landCoordinateX) / 2;
      const midAirJumpCenterX = landCoordinateX + halfJumpDistance;
      const jumpVerticalDistance = jumpCoordinate.y - landCoordinate.y + Settings.tile.halfSize;
      const midAirJumpY = jumpCoordinate.y - jumpVerticalDistance;
      const xDistancePerFrame = this.getWalkDistanceThisFrame(frameTimeRatio);
      character.position.facingLeft = true;
      if (character.position.worldCoordinateCenter.x > midAirJumpCenterX) {
        character.setCharacterAction(CharacterAction.JUMP);
        const yDistancePerFrame2 = this.getJumpDistanceThisFrame(frameTimeRatio);
        const distanceToJumpCenter = character.position.worldCoordinateCenter.x - midAirJumpCenterX;
        const distanceToJumpTop = character.position.worldCoordinateOrigin.y - midAirJumpY;
        if (distanceToJumpCenter > distanceToJumpTop) {
          const yRatio = this.calcRatio(distanceToJumpTop, distanceToJumpCenter);
          const yMotion = Math.min(yRatio * yDistancePerFrame2, distanceToJumpTop);
          const xMotion = Math.min(xDistancePerFrame, distanceToJumpCenter);
          character.position.moveXY(-xMotion, -yMotion);
        } else {
          const xRatio = this.calcRatio(distanceToJumpCenter, distanceToJumpTop);
          const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToJumpCenter);
          const yMotion = Math.min(yDistancePerFrame2, distanceToJumpTop);
          character.position.moveXY(-xMotion, -yMotion);
        }
        return;
      }
      character.setCharacterAction(CharacterAction.FALL);
      const yDistancePerFrame = this.getFallDistanceThisFrame(frameTimeRatio);
      const distanceToLandX = character.position.worldCoordinateCenter.x - landCoordinateX;
      const distanceToLandY = this.endTile.origin.y - character.position.worldCoordinateOrigin.y;
      if (distanceToLandX === 0 && distanceToLandY === 0) {
        return;
      }
      if (distanceToLandX > distanceToLandY) {
        const yRatio = this.calcRatio(distanceToLandY, distanceToLandX);
        const yMotion = Math.min(yRatio * yDistancePerFrame, distanceToLandY);
        const xMotion = Math.min(xDistancePerFrame, distanceToLandX);
        character.position.moveXY(-xMotion, yMotion);
      } else {
        const xRatio = this.calcRatio(distanceToLandX, distanceToLandY);
        const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToLandX);
        const yMotion = Math.min(yDistancePerFrame, distanceToLandY);
        character.position.moveXY(-xMotion, yMotion);
      }
    }
    /**
     * Jump from a lower position to a higher position that is to the right.
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {Vector} jumpCoordinate 
     * @param {Vector} landCoordinate 
     */
    jumpUpAndRight(character, frameTimeRatio, jumpCoordinate, landCoordinate) {
      const jumpCoordinateX = jumpCoordinate.x;
      const landCoordinateX = landCoordinate.x;
      const halfJumpDistance = (landCoordinateX - jumpCoordinateX) / 2;
      const midAirJumpCenterX = jumpCoordinateX + halfJumpDistance;
      const jumpVerticalDistance = jumpCoordinate.y - landCoordinate.y + Settings.tile.halfSize;
      const midAirJumpY = jumpCoordinate.y - jumpVerticalDistance;
      const xDistancePerFrame = this.getWalkDistanceThisFrame(frameTimeRatio);
      character.position.facingLeft = false;
      if (character.position.worldCoordinateCenter.x < midAirJumpCenterX) {
        character.setCharacterAction(CharacterAction.JUMP);
        const yDistancePerFrame2 = this.getJumpDistanceThisFrame(frameTimeRatio);
        const distanceToJumpCenter = midAirJumpCenterX - character.position.worldCoordinateCenter.x;
        const distanceToJumpTop = character.position.worldCoordinateOrigin.y - midAirJumpY;
        if (distanceToJumpCenter > distanceToJumpTop) {
          const yRatio = this.calcRatio(distanceToJumpTop, distanceToJumpCenter);
          const yMotion = Math.min(yRatio * yDistancePerFrame2, distanceToJumpTop);
          const xMotion = Math.min(xDistancePerFrame, distanceToJumpCenter);
          character.position.moveXY(xMotion, -yMotion);
        } else {
          const xRatio = this.calcRatio(distanceToJumpCenter, distanceToJumpTop);
          const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToJumpCenter);
          const yMotion = Math.min(yDistancePerFrame2, distanceToJumpTop);
          character.position.moveXY(xMotion, -yMotion);
        }
        return;
      }
      character.setCharacterAction(CharacterAction.FALL);
      const yDistancePerFrame = this.getFallDistanceThisFrame(frameTimeRatio);
      const distanceToLandX = landCoordinateX - character.position.worldCoordinateCenter.x;
      const distanceToLandY = landCoordinate.y - character.position.worldCoordinateOrigin.y;
      if (distanceToLandX === 0 && distanceToLandY === 0) {
        return;
      }
      if (distanceToLandX > distanceToLandY) {
        const yRatio = this.calcRatio(distanceToLandY, distanceToLandX);
        const yMotion = Math.min(yRatio * yDistancePerFrame, distanceToLandY);
        const xMotion = Math.min(xDistancePerFrame, distanceToLandX);
        character.position.moveXY(xMotion, yMotion);
      } else {
        const xRatio = this.calcRatio(distanceToLandX, distanceToLandY);
        const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToLandX);
        const yMotion = Math.min(yDistancePerFrame, distanceToLandY);
        character.position.moveXY(xMotion, yMotion);
      }
    }
    /**
     * Jump from a higher position to a lower position that is to the left.
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {Vector} jumpCoordinate 
     * @param {Vector} landCoordinate 
     */
    jumpDownAndLeft(character, frameTimeRatio, jumpCoordinate, landCoordinate) {
      const jumpCoordinateX = jumpCoordinate.x;
      const landCoordinateX = landCoordinate.x;
      const halfJumpDistance = (jumpCoordinateX - landCoordinateX) / 2;
      const midAirJumpCenterX = landCoordinateX + halfJumpDistance;
      const jumpVerticalDistance = Settings.tile.halfSize;
      const midAirJumpY = jumpCoordinate.y - jumpVerticalDistance;
      const xDistancePerFrame = this.getWalkDistanceThisFrame(frameTimeRatio);
      character.position.facingLeft = true;
      if (character.position.worldCoordinateCenter.x > midAirJumpCenterX) {
        character.setCharacterAction(CharacterAction.JUMP);
        const yDistancePerFrame2 = this.getJumpDistanceThisFrame(frameTimeRatio);
        const distanceToJumpCenter = character.position.worldCoordinateCenter.x - midAirJumpCenterX;
        const distanceToJumpTop = character.position.worldCoordinateOrigin.y - midAirJumpY;
        if (distanceToJumpCenter > distanceToJumpTop) {
          const yRatio = this.calcRatio(distanceToJumpTop, distanceToJumpCenter);
          const yMotion = Math.min(yRatio * yDistancePerFrame2, distanceToJumpTop);
          const xMotion = Math.min(xDistancePerFrame, distanceToJumpCenter);
          character.position.moveXY(-xMotion, -yMotion);
        } else {
          const xRatio = this.calcRatio(distanceToJumpCenter, distanceToJumpTop);
          const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToJumpCenter);
          const yMotion = Math.min(yDistancePerFrame2, distanceToJumpTop);
          character.position.moveXY(-xMotion, -yMotion);
        }
        return;
      }
      character.setCharacterAction(CharacterAction.FALL);
      const yDistancePerFrame = this.getFallDistanceThisFrame(frameTimeRatio);
      const distanceToLandX = character.position.worldCoordinateCenter.x - landCoordinateX;
      const distanceToLandY = this.endTile.origin.y - character.position.worldCoordinateOrigin.y;
      if (distanceToLandX === 0 && distanceToLandY === 0) {
        return;
      }
      if (distanceToLandX > distanceToLandY) {
        const yRatio = this.calcRatio(distanceToLandY, distanceToLandX);
        const yMotion = Math.min(yRatio * yDistancePerFrame, distanceToLandY);
        const xMotion = Math.min(xDistancePerFrame, distanceToLandX);
        character.position.moveXY(-xMotion, yMotion);
      } else {
        const xRatio = this.calcRatio(distanceToLandX, distanceToLandY);
        const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToLandX);
        const yMotion = Math.min(yDistancePerFrame, distanceToLandY);
        character.position.moveXY(-xMotion, yMotion);
      }
    }
    /**
     * Jump from a higher position to a lower position that is to the right.
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {Vector} jumpCoordinate 
     * @param {Vector} landCoordinate 
     */
    jumpDownAndRight(character, frameTimeRatio, jumpCoordinate, landCoordinate) {
      const jumpCoordinateX = jumpCoordinate.x;
      const landCoordinateX = landCoordinate.x;
      const halfJumpDistance = (landCoordinateX - jumpCoordinateX) / 2;
      const midAirJumpCenterX = jumpCoordinateX + halfJumpDistance;
      const jumpVerticalDistance = Settings.tile.halfSize;
      const midAirJumpY = jumpCoordinate.y - jumpVerticalDistance;
      const xDistancePerFrame = this.getWalkDistanceThisFrame(frameTimeRatio);
      character.position.facingLeft = false;
      if (character.position.worldCoordinateCenter.x < midAirJumpCenterX) {
        character.setCharacterAction(CharacterAction.JUMP);
        const yDistancePerFrame2 = this.getJumpDistanceThisFrame(frameTimeRatio);
        const distanceToJumpCenter = midAirJumpCenterX - character.position.worldCoordinateCenter.x;
        const distanceToJumpTop = character.position.worldCoordinateOrigin.y - midAirJumpY;
        if (distanceToJumpCenter > distanceToJumpTop) {
          const yRatio = this.calcRatio(distanceToJumpTop, distanceToJumpCenter);
          const yMotion = Math.min(yRatio * yDistancePerFrame2, distanceToJumpTop);
          const xMotion = Math.min(xDistancePerFrame, distanceToJumpCenter);
          character.position.moveXY(xMotion, -yMotion);
        } else {
          const xRatio = this.calcRatio(distanceToJumpCenter, distanceToJumpTop);
          const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToJumpCenter);
          const yMotion = Math.min(yDistancePerFrame2, distanceToJumpTop);
          character.position.moveXY(xMotion, -yMotion);
        }
        return;
      }
      character.setCharacterAction(CharacterAction.FALL);
      const yDistancePerFrame = this.getFallDistanceThisFrame(frameTimeRatio);
      const distanceToLandX = landCoordinateX - character.position.worldCoordinateCenter.x;
      const distanceToLandY = landCoordinate.y - character.position.worldCoordinateOrigin.y;
      if (distanceToLandX === 0 && distanceToLandY === 0) {
        return;
      }
      if (distanceToLandX > distanceToLandY) {
        const yRatio = this.calcRatio(distanceToLandY, distanceToLandX);
        const yMotion = Math.min(yRatio * yDistancePerFrame, distanceToLandY);
        const xMotion = Math.min(xDistancePerFrame, distanceToLandX);
        character.position.moveXY(xMotion, yMotion);
      } else {
        const xRatio = this.calcRatio(distanceToLandX, distanceToLandY);
        const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToLandX);
        const yMotion = Math.min(yDistancePerFrame, distanceToLandY);
        character.position.moveXY(xMotion, yMotion);
      }
    }
    /**
     * Jump left from one tile to another, both at the same height.
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {Vector} jumpCoordinate 
     * @param {Vector} landCoordinate 
     * @param {number} jumpHeight
     */
    jumpLeft(character, frameTimeRatio, jumpCoordinate, landCoordinate, jumpHeight) {
      const jumpCoordinateX = jumpCoordinate.x;
      const landCoordinateX = landCoordinate.x;
      const halfJumpDistance = (jumpCoordinateX - landCoordinateX) / 2;
      const midAirJumpCenterX = landCoordinateX + halfJumpDistance;
      const midAirJumpY = jumpCoordinate.y - jumpHeight;
      const xDistancePerFrame = this.getWalkDistanceThisFrame(frameTimeRatio);
      character.position.facingLeft = true;
      if (character.position.worldCoordinateCenter.x > midAirJumpCenterX) {
        character.setCharacterAction(CharacterAction.JUMP);
        const yDistancePerFrame2 = this.getJumpDistanceThisFrame(frameTimeRatio);
        const distanceToJumpCenter = character.position.worldCoordinateCenter.x - midAirJumpCenterX;
        const distanceToJumpTop = character.position.worldCoordinateOrigin.y - midAirJumpY;
        if (distanceToJumpCenter > distanceToJumpTop) {
          const yRatio = this.calcRatio(distanceToJumpTop, distanceToJumpCenter);
          const yMotion = Math.min(yRatio * yDistancePerFrame2, distanceToJumpTop);
          const xMotion = Math.min(xDistancePerFrame, distanceToJumpCenter);
          character.position.moveXY(-xMotion, -yMotion);
        } else {
          const xRatio = this.calcRatio(distanceToJumpCenter, distanceToJumpTop);
          const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToJumpCenter);
          const yMotion = Math.min(yDistancePerFrame2, distanceToJumpTop);
          character.position.moveXY(-xMotion, -yMotion);
        }
        return;
      }
      character.setCharacterAction(CharacterAction.FALL);
      const yDistancePerFrame = this.getFallDistanceThisFrame(frameTimeRatio);
      const distanceToLandX = character.position.worldCoordinateCenter.x - landCoordinateX;
      const distanceToLandY = this.endTile.origin.y - character.position.worldCoordinateOrigin.y;
      if (distanceToLandX === 0 && distanceToLandY === 0) {
        return;
      }
      if (distanceToLandX > distanceToLandY) {
        const yRatio = this.calcRatio(distanceToLandY, distanceToLandX);
        const yMotion = Math.min(yRatio * yDistancePerFrame, distanceToLandY);
        const xMotion = Math.min(xDistancePerFrame, distanceToLandX);
        character.position.moveXY(-xMotion, yMotion);
      } else {
        const xRatio = this.calcRatio(distanceToLandX, distanceToLandY);
        const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToLandX);
        const yMotion = Math.min(yDistancePerFrame, distanceToLandY);
        character.position.moveXY(-xMotion, yMotion);
      }
    }
    /**
     * Jump right from one tile to another, both at the same height.
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {Vector} jumpCoordinate 
     * @param {Vector} landCoordinate 
     * @param {number} jumpHeight
     */
    jumpRight(character, frameTimeRatio, jumpCoordinate, landCoordinate, jumpHeight) {
      const jumpCoordinateX = jumpCoordinate.x;
      const landCoordinateX = landCoordinate.x;
      const halfJumpDistance = (landCoordinateX - jumpCoordinateX) / 2;
      const midAirJumpCenterX = jumpCoordinateX + halfJumpDistance;
      const midAirJumpY = jumpCoordinate.y - jumpHeight;
      const xDistancePerFrame = this.getWalkDistanceThisFrame(frameTimeRatio);
      character.position.facingLeft = false;
      if (character.position.worldCoordinateCenter.x < midAirJumpCenterX) {
        character.setCharacterAction(CharacterAction.JUMP);
        const yDistancePerFrame2 = this.getJumpDistanceThisFrame(frameTimeRatio);
        const distanceToJumpCenter = midAirJumpCenterX - character.position.worldCoordinateCenter.x;
        const distanceToJumpTop = character.position.worldCoordinateOrigin.y - midAirJumpY;
        if (distanceToJumpCenter > distanceToJumpTop) {
          const yRatio = this.calcRatio(distanceToJumpTop, distanceToJumpCenter);
          const yMotion = Math.min(yRatio * yDistancePerFrame2, distanceToJumpTop);
          const xMotion = Math.min(xDistancePerFrame, distanceToJumpCenter);
          character.position.moveXY(xMotion, -yMotion);
        } else {
          const xRatio = this.calcRatio(distanceToJumpCenter, distanceToJumpTop);
          const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToJumpCenter);
          const yMotion = Math.min(yDistancePerFrame2, distanceToJumpTop);
          character.position.moveXY(xMotion, -yMotion);
        }
        return;
      }
      character.setCharacterAction(CharacterAction.FALL);
      const yDistancePerFrame = this.getFallDistanceThisFrame(frameTimeRatio);
      const distanceToLandX = landCoordinateX - character.position.worldCoordinateCenter.x;
      const distanceToLandY = landCoordinate.y - character.position.worldCoordinateOrigin.y;
      if (distanceToLandX === 0 && distanceToLandY === 0) {
        return;
      }
      if (distanceToLandX > distanceToLandY) {
        const yRatio = this.calcRatio(distanceToLandY, distanceToLandX);
        const yMotion = Math.min(yRatio * yDistancePerFrame, distanceToLandY);
        const xMotion = Math.min(xDistancePerFrame, distanceToLandX);
        character.position.moveXY(xMotion, yMotion);
      } else {
        const xRatio = this.calcRatio(distanceToLandX, distanceToLandY);
        const xMotion = Math.min(xRatio * xDistancePerFrame, distanceToLandX);
        const yMotion = Math.min(yDistancePerFrame, distanceToLandY);
        character.position.moveXY(xMotion, yMotion);
      }
    }
    /**
     * Fall from a higher position to a lower position that is to the left.
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {Vector} landCoordinate 
     */
    fallDownAndLeft(character, frameTimeRatio, landCoordinate) {
      character.position.facingLeft = true;
      character.setCharacterAction(CharacterAction.FALL);
      const yDistancePerFrame = this.getFallDistanceThisFrame(frameTimeRatio);
      const xDistancePerFrame = this.getWalkDistanceThisFrame(frameTimeRatio);
      const distanceToLandX = character.position.worldCoordinateCenter.x - landCoordinate.x;
      const distanceToLandY = landCoordinate.y - character.position.worldCoordinateOrigin.y;
      const xMotion = Math.min(xDistancePerFrame, distanceToLandX);
      const yMotion = Math.min(yDistancePerFrame, distanceToLandY);
      character.position.moveXY(-xMotion, yMotion);
    }
    /**
     * Fall from a higher position to a lower position that is to the right.
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {Vector} landCoordinate 
     */
    fallDownAndRight(character, frameTimeRatio, landCoordinate) {
      character.position.facingLeft = false;
      character.setCharacterAction(CharacterAction.FALL);
      const yDistancePerFrame = this.getFallDistanceThisFrame(frameTimeRatio);
      const xDistancePerFrame = this.getWalkDistanceThisFrame(frameTimeRatio);
      const distanceToLandX = landCoordinate.x - character.position.worldCoordinateCenter.x;
      const distanceToLandY = landCoordinate.y - character.position.worldCoordinateOrigin.y;
      const xMotion = Math.min(xDistancePerFrame, distanceToLandX);
      const yMotion = Math.min(yDistancePerFrame, distanceToLandY);
      character.position.moveXY(xMotion, yMotion);
    }
    /**
     * Fall from a higher position to a lower position that is to the left.
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {Vector} landCoordinate 
     * @returns {boolean} True when completed.
     */
    fallDown(character, frameTimeRatio, landCoordinate) {
      character.setCharacterAction(CharacterAction.FALL);
      const yDistancePerFrame = this.getFallDistanceThisFrame(frameTimeRatio);
      const distanceToLandY = landCoordinate.origin.y - character.position.worldCoordinateOrigin.y;
      if (yDistancePerFrame < distanceToLandY) {
        character.position.moveY(yDistancePerFrame);
        return false;
      } else {
        character.position.setY(landCoordinate.origin.y);
        return true;
      }
    }
    /**
     * @param {number} frameTimeRatio 
     * @returns {number}
     */
    getWalkDistanceThisFrame(frameTimeRatio) {
      return Settings.physics.walkRatePerFrame * frameTimeRatio;
    }
    /**
     * @param {number} frameTimeRatio 
     * @returns {number}
     */
    getFallDistanceThisFrame(frameTimeRatio) {
      return Settings.physics.gravityRatePerFrame * frameTimeRatio * this.fallSpeedMultiplier;
    }
    /**
     * @param {number} frameTimeRatio 
     * @returns {number}
     */
    getJumpDistanceThisFrame(frameTimeRatio) {
      return Settings.physics.jumpRatePerFrame * frameTimeRatio;
    }
    /**
     * @param {Position} position
     * @returns {number}
     */
    getDistanceAboveFloor(position) {
      const floorY = position.tile.origin.y;
      const characterY = position.worldCoordinateOrigin.y;
      return floorY - characterY;
    }
    /**
     * 
     * @param {Character} character 
     * @param {GridTile} endTile 
     */
    assertEndTileReached(character, endTile) {
      if (character.position.tile !== endTile) {
        const origin = endTile.origin;
        character.position.setTileAndOriginPosition(endTile, origin.x, origin.y);
      } else {
        character.position.setPositionToTileOrigin();
      }
    }
    /**
     * Calculate the ratio between two numbers, avoiding 0 denominator.
     * @private
     * @param {number} numerator 
     * @param {number} denominator 
     * @returns {number}
     */
    calcRatio(numerator, denominator) {
      if (numerator === denominator) {
        return 1;
      }
      if (numerator === 0) {
        return 0;
      }
      if (denominator === 0) {
        console.log("calcRatio() 0 denominator");
        return 1e3;
      }
      return numerator / denominator;
    }
    /**
     * @abstract
     * @returns {String}
     */
    toString() {
      return "Base PathPlan toString() sub-class did not override.";
    }
  };

  // src/model/character/Position.js
  var Position = class {
    /**
     * 
     * @param {Character} character 
     */
    constructor(character) {
      this.character = character;
      this.worldCoordinateOrigin = new Vector(0, 0);
      this.worldCoordinateCenter = new Vector(0, 0);
      this.tile = null;
      this.grid = null;
      this.facingLeft = true;
      this.gravityThisFrame = 0;
      this.pathPlan = [];
    }
    /**
     * @private
     * @param {Grid} grid 
     */
    setGrid(grid) {
      if (this.grid == grid) {
        return;
      }
      if (this.grid) {
        this.grid.removeCharacter(this.character);
      }
      if (grid != null) {
        grid.addCharacter(this.character);
      }
      this.grid = grid;
    }
    castVerticalPositionToInteger() {
      this.worldCoordinateOrigin.y = Fast.floor(this.worldCoordinateOrigin.y);
      this.worldCoordinateCenter.y = this.worldCoordinateOrigin.y + Settings.tile.halfSize;
    }
    /**
     * @param {GridTile} tile 
     * @param {number} x 
     * @param {number} y 
     */
    setTileAndOriginPosition(tile, x, y) {
      this.worldCoordinateOrigin.set(x, y);
      this.tile = tile;
      this.onWorldCoordinateChange();
    }
    /**
     * Returns true if the miner is close enough to the tile orgin to have their position reset to origin
     * without looking jerky.
     * @returns {boolean}
     */
    isNearTileOrigin() {
      if (!this.tile) {
        return false;
      }
      const dx = this.worldCoordinateOrigin.x - this.tile.origin.x;
      const dy = this.worldCoordinateOrigin.y - this.tile.origin.y;
      return Math.abs(dx) <= Settings.tile.quarterSize && Math.abs(dy) <= Settings.tile.quarterSize;
    }
    /**
     * 
     */
    setPositionToTileOrigin() {
      if (!this.tile) {
        return;
      }
      this.setTileAndOriginPosition(this.tile, this.tile.origin.x, this.tile.origin.y);
    }
    // setPositionToClosestTileOrigin() {
    //     if (!this.tile) {
    //         return;
    //     }
    //     // if we are close to the origin of our tile, then use that.
    //     // if we are close to a neighbor tile, and if it is open, use that.
    //     const dx = this.worldCoordinateOrigin.x - this.tile.origin.x;
    //     const dy = this.worldCoordinateOrigin.y - this.tile.origin.y;
    //     console.log('setPositionToClosestTileOrigin() dx=' + dx + ' dy=' + dy);
    //     if (dx < Settings.tile.halfSize && dy < Settings.tile.halfSize) {
    //         console.log('setPositionToClosestTileOrigin() using tile origin.');
    //         this.setTileAndOriginPosition(this.tile, this.tile.origin.x, this.tile.origin.y);
    //     }
    //     const closestNeighbor = this.findClosestNeighbor();
    //     if (closestNeighbor) {
    //         console.log('setPositionToClosestTileOrigin() switching to neighbor tile.');
    //         this.tile = closestNeighbor;
    //     }
    //     this.setTileAndOriginPosition(this.tile, this.tile.origin.x, this.tile.origin.y);
    // }
    /**
     * @private
     * @returns {GridTile}
     */
    findClosestNeighbor() {
      const neighbors = this.tile.neighbors;
      let closest = null;
      let closestDist = 1e6;
      for (let i = 0; i < neighbors.length; i++) {
        const neighbor = neighbors[i];
        if (!neighbor || !neighbor.open) {
          continue;
        }
        const dist = this.tile.origin.distanceSquared(neighbor.origin);
        if (!closest || dist < closestDist) {
          closest = neighbor;
          closestDist = dist;
        }
      }
      return closest;
    }
    /**
     * @returns {boolean}
     */
    isCenteredOnTile() {
      return this.tile && this.tile.origin.equals(this.worldCoordinateOrigin);
    }
    /**
     * Updates the origin position of the character.
     * @param {Vector} coordinate 
     */
    setWorldCoordinateOrigin(coordinate) {
      this.worldCoordinateOrigin.copy(coordinate);
      this.onWorldCoordinateChange();
    }
    /**
     * Updates the origin position of the character.
     * @param {number} x 
     * @param {number} y 
     */
    setWorldCoordinateOriginXY(x, y) {
      this.worldCoordinateOrigin.set(x, y);
      this.onWorldCoordinateChange();
    }
    /**
     * @param {number} movement 
     */
    moveX(movement) {
      this.worldCoordinateOrigin.addXY(movement, 0);
      this.onWorldCoordinateChange();
    }
    /**
     * @param {number} movement 
     */
    moveY(movement) {
      this.worldCoordinateOrigin.addXY(0, movement);
      this.onWorldCoordinateChange();
    }
    /**
     * Set the x-coordinate to a specific value.
     * @param {number} value 
     */
    setX(value2) {
      this.worldCoordinateOrigin.x = value2;
      this.onWorldCoordinateChange();
    }
    /**
     * Set the y-coordinate to a specific value.
     * @param {number} value 
     */
    setY(value2) {
      this.worldCoordinateOrigin.y = value2;
      this.onWorldCoordinateChange();
    }
    /**
     * @param {number} moveX 
     * @param {number} moveY
     */
    moveXY(moveX, moveY) {
      this.worldCoordinateOrigin.addXY(moveX, moveY);
      this.onWorldCoordinateChange();
    }
    /**
     * @private
     */
    onWorldCoordinateChange() {
      this.worldCoordinateCenter.copy(this.worldCoordinateOrigin);
      this.worldCoordinateCenter.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
      if (!this.tile) {
        console.log("Position.onWorldCoordinateChange() tile is null");
        return;
      }
      if (!this.tile.contains(this.worldCoordinateOrigin)) {
        const safeTile = this.tile;
        this.tile = this.tile.findNeighborContaining(this.worldCoordinateOrigin);
        if (!this.tile) {
          if (this.grid) {
            this.tile = this.grid.findGridTile(this.worldCoordinateOrigin);
          }
          if (!this.tile) {
            this.tile = safeTile.getWorldGrid().findGridTile(this.worldCoordinateOrigin);
          }
        }
      }
      if (this.tile) {
        this.setGrid(this.tile.grid);
      } else {
        console.log("Position.onWorldCoordinateChange() character lost their tile after move.");
        this.character.onInvalidGrid();
      }
    }
    // /**
    //  * Removes the character from the grid. This should be invoked when the character dies.
    //  */
    // removeFromGrid() {
    //     if (this.grid && this.character) {
    //         this.grid.removeCharacter(this.character);
    //         this.grid = null;
    //     }
    // }
    // isInMotion() {
    //     return this.pathPlan.length > 0;
    // }
    // /**
    //  * 
    //  * @param {Grid} grid 
    //  */
    // onGridUnload(grid) {
    //     if (this.pathPlan.length === 0) {
    //         return;
    //     }
    //     for (let i = 0; i < this.pathPlan.length; i++) {
    //         const plan = this.pathPlan[i];
    //     }
    // }
    resetPathPlan() {
      if (this.pathPlan.length > 0) {
        this.pathPlan.length = 0;
        this.setPositionToTileOrigin();
      }
    }
    resetFull() {
      this.resetPathPlan();
      this.setGrid(null);
      this.tile = null;
      this.gravityThisFrame = 0;
    }
  };

  // src/model/character/turn/TurnAction.js
  var TurnAction = class {
    constructor() {
    }
    /**
     * Invoked for a character once per frame.
     * @abstract
     * @param {Character} character The character making the turn action.
     * @param {number} frameTimeRatio The time frame ratio.
     * @param {boolean} turnStart True if this is the start of a turn.
     */
    performAction(character, frameTimeRatio, turnStart) {
    }
    /**
     * Returns true if this turn action will move the character and affect the path plan.
     * @abstract
     * @returns {boolean}
     */
    isMovementAction() {
      return false;
    }
    /**
     * @abstract
     * @returns {string}
     */
    toString() {
      return "BaseTurnAction";
    }
  };

  // src/model/character/Character.js
  var Character = class extends CachedInstance {
    constructor() {
      super();
      this.position = new Position(this);
      this.target = new CharacterTarget();
      this.turnAction = null;
      this.pathCompletedTime = 0;
    }
    /**
     * @returns {boolean}
     */
    isMonster() {
      return true;
    }
    /**
     * @returns {boolean}
     */
    isPartyMember() {
      return false;
    }
    /**
     * @returns {boolean}
     */
    isMinion() {
      return false;
    }
    /**
     * @returns {boolean}
     */
    isDead() {
      return false;
    }
    // /**
    //  * @abstract
    //  * @param {Character} character 
    //  * @returns {boolean}
    //  */
    // isEnemy(character) {
    //     return true;
    // }
    /**
     * Returns -1 if this isn't a miner in the crew.
     * @abstract
     * @returns {number}
     */
    getMinerIndex() {
      return -1;
    }
    /**
     * @returns {string}
     */
    getMonsterDescriptionId() {
      return null;
    }
    /**
     * @returns {number}
     */
    getCharacterLevel() {
      return 1;
    }
    // /**
    //  * @abstract
    //  * @returns {number}
    //  */
    // getDamage() {
    //     return 1;        
    // }
    // /**
    //  * Reduce the character's health.
    //  * @param {number} health 
    //  */
    // decrementHealth(health) {
    //     if (health < 0) {
    //         console.log('Character.decrementHealth() negative health specified.');
    //         return;
    //     }
    //     this.health = Math.max(0, this.health - health);
    // }
    /**
     * @abstract
     * @param {string} characterAction  See CharacterAction
     */
    setCharacterAction(characterAction) {
    }
    /**
     * @abstract
     * @returns {Sprite}
     */
    getCharacterSprite() {
      return null;
    }
    /**
     * @abstract
     * @returns {Sprite}
     */
    getItemOverlaySprite() {
      return null;
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isThrusterActive() {
      return false;
    }
    /**
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     */
    followPathPlan(frameTimeRatio, turnStart) {
      if (this.position.pathPlan.length === 0) {
        return;
      }
      const plan = this.position.pathPlan[0];
      if (plan.executePlan(this, frameTimeRatio, turnStart)) {
        this.position.pathPlan.shift();
      }
    }
    /**
     * @abstract
     */
    chooseTurn() {
    }
    /**
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart
     */
    performFrameActions(frameTimeRatio, turnStart) {
      if (!this.turnAction) {
        return;
      }
      this.turnAction.performAction(this, frameTimeRatio, turnStart);
    }
    /**
     * 
     */
    resetTurnState() {
      this.turnAction = null;
      this.characterAction = CharacterAction.STAND;
      this.target.resetTarget();
      this.position.resetPathPlan();
    }
    ///////////////////////////////////////////////
    // 
    ///////////////////////////////////////////////
    /**
     * Invoked if the character is found to be in a grid that was unloaded.
     * We do not want the character to retain references to tiles that are in a grid
     * that was recycled and moved.
     */
    onInvalidGrid() {
      this.resetGameModel();
    }
    resetGameModel() {
      this.position.resetFull();
      this.resetTurnState();
    }
  };

  // src/model/character/brain/CharacterBehavior.js
  var CharacterBehavior = class {
    /**
     * 
     * @param {number} behaviorId 
     */
    constructor(behaviorId) {
      this.behaviorId = behaviorId;
    }
    /**
     * Applies the behavior, but only if it is appropriate for the current state of the world.
     * @abstract
     * @param {Character} character
     * @return {boolean} True if the behavior was applied.
     */
    applyIfAppropriate(character) {
      return false;
    }
    /**
     * Returns true if this is an 'auto-play' behavior rather than an manual play behavior.
     * @abstract
     * @returns {boolean}
     */
    isAutoPlayBehavior() {
      return false;
    }
    /**
     * @abstract
     * @returns {string}
     */
    getName() {
      return "CharacterBehavior****";
    }
  };

  // src/model/character/brain/CharacterBrain.js
  var CharacterBrain = class {
    /**
     * @param {string} id The brain id
     * @param {Array.<CharacterBehavior>} behaviors 
     */
    constructor(id, behaviors) {
      this.id = id;
      this.behaviors = behaviors;
    }
    // /**
    //  * 
    //  * @param {Character} character 
    //  * @returns {boolean}
    //  */
    // isValidForTurnChoice(character) {
    //     if (character.position.isCenteredOnTile()) {
    //         return true;
    //     }
    //     // We are still carrying out a turn. Do not choose a new one.
    //     if (character.turnAction && character.turnAction.isMovementAction() && character.position.pathPlan.length > 0) {
    //         return;
    //     }
    // }
    /**
     * @param {Character} character
     */
    chooseTurn(character) {
      if (!character.position.isCenteredOnTile()) {
        if (character.turnAction && character.turnAction.isMovementAction() && character.position.pathPlan.length > 0) {
          return;
        } else if (character.position.gravityThisFrame === 0) {
          console.log("CharacterBrain.chooseTurn() not centered on tile and have no path plan. partyMember=" + character.isPartyMember() + " monster=" + character.isMonster());
          character.resetTurnState();
        }
      }
      character.turnAction = null;
      const tile = character.position.tile;
      if (!tile) {
        character.resetTurnState();
        return;
      }
      const grid = tile.grid;
      if (!grid.isLoaded()) {
        console.log("CharacterBarin.chooseTurn() character in grid that is not loaded.");
        character.resetTurnState();
        return;
      }
      if (character.position.gravityThisFrame > 0) {
        return;
      }
      this.applyBehaviors(character, this.behaviors);
      if (!character.turnAction) {
        character.position.resetPathPlan();
        character.setCharacterAction(CharacterAction.STAND);
      }
    }
    /**
     * @param {Character} character
     * @param {CharacterBehavior[]} behaviors
     */
    applyBehaviors(character, behaviors) {
      let behaviorApplied = false;
      for (let i = 0; i < behaviors.length; i++) {
        if (behaviors[i].applyIfAppropriate(character)) {
          behaviorApplied = true;
          break;
        }
      }
      if (!behaviorApplied) {
        character.target.resetTarget();
      }
    }
  };

  // src/model/character/MonsterCharacter.js
  var MonsterCharacter = class extends Character {
    constructor() {
      super();
      this.sprite = null;
      this.monsterDescription = null;
      this.brain = null;
      this.damage = 1;
    }
    /**
     * @param {CharacterBrain} brain
     * @param {Sprite} sprite
     * @param {MonsterDescription} monsterDescription
     */
    set(brain, sprite, monsterDescription) {
      this.brain = brain;
      this.sprite = sprite;
      this.monsterDescription = monsterDescription;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isMonster() {
      return true;
    }
    // /**
    //  * @override
    //  * @param {Character} character 
    //  * @returns {boolean}
    //  */
    // isEnemy(character) {
    //     return !character.isMonster();
    // }
    /**
     * @override
     * @returns {string}
     */
    getMonsterDescriptionId() {
      return this.monsterDescription.id;
    }
    /**
     * @returns {Sprite}
     */
    getCharacterSprite() {
      return this.sprite;
    }
    /**
     * @override
     * @returns {number}
     */
    getDamage() {
      return this.damage;
    }
    /**
     * @override
     */
    chooseTurn() {
      this.brain.chooseTurn(this);
    }
    /**
     * @param {boolean} finishedAndAvailable 
     */
    reset(finishedAndAvailable) {
      super.reset(finishedAndAvailable);
      if (this.finishedAndAvailable) {
        this.position.resetFull();
        this.resetTurnState();
        this.brain = null;
      }
    }
  };

  // src/model/cache/CyclingCache.js
  var CyclingCache = class {
    constructor() {
      this.cache = [];
      this.index = 0;
      this.totalSize = 0;
      this.count = 0;
      this.currentActiveCount = 0;
      this.maxActiveCount = 0;
    }
    /**
     * @returns {CachedInstance}
     */
    get() {
      if (this.cache.length == 0) {
        this.growCache(this.getInitialSize());
      }
      if (this.index >= this.cache.length) {
        this.index = 0;
      }
      this.index = this.findNextAvailableIndex(this.index);
      const c = this.cache[this.index];
      this.index++;
      c.reset(false);
      return c;
    }
    /**
     * @private
     * @param {number} index 
     * @returns {number}
     */
    findNextAvailableIndex(index) {
      let size = this.cache.length;
      if (this.maxActiveCount >= size) {
        index = size;
        this.growCache(this.getGrowAmount());
        size = this.cache.length;
      }
      let wrapCount = 0;
      do {
        if (index >= size) {
          wrapCount++;
          if (wrapCount == 1) {
            index = 0;
          } else {
            this.growCache(this.getGrowAmount());
            size = this.cache.length;
          }
        }
        const c = this.cache[index];
        if (c.isFinishedAndAvailable()) {
          return index;
        } else {
          index++;
        }
      } while (wrapCount < 2);
    }
    /**
     * @returns {Array.<CachedInstance>}
     */
    getUnderlyingCache() {
      return this.cache;
    }
    /**
     * @private
     * @param {number} amount 
     */
    growCache(amount) {
      for (let i = 0; i < amount; i++) {
        const c = this.createInstance();
        c.setCycleCacheListener(this);
        this.cache.push(c);
      }
      console.log("CyclingCache.growCache() amount=" + amount + " newSize=" + this.cache.length + " Type: " + this.constructor.name);
    }
    /**
     * @private
     * @param {number} newSize 
     */
    shrinkToSize(newSize) {
      const excess = this.cache.length - newSize;
      if (excess > 0) {
        this.cache.splice(newSize, excess);
      }
    }
    resetCache() {
      const size = this.cache.length;
      if (size == 0) {
        return;
      }
      this.count++;
      this.totalSize += this.maxActiveCount;
      const average = this.totalSize / this.count;
      for (let i = 0; i < size; i++) {
        const c = this.cache[i];
        if (!c.isFinishedAndAvailable()) {
          c.reset(true);
        }
      }
      if (this.count > 5) {
        const growAmount = this.getGrowAmount();
        const minShrinkThreshold = this.getInitialSize() + 2 * growAmount;
        if (size > average * 1.75 && size > minShrinkThreshold) {
          const shrinkTarget = average * 1.2 | 0;
          let newSize = this.getInitialSize();
          while (newSize < shrinkTarget) {
            newSize += growAmount;
          }
          if (newSize < size) {
            this.shrinkToSize(newSize);
          }
          this.totalSize = 0;
          this.count = 0;
        }
      }
      this.maxActiveCount = 0;
      this.currentActiveCount = 0;
      this.index = 0;
    }
    // public String getName() {
    //     return getClass().getSimpleName();
    // }
    /**
     * @abstract
     * @returns {number}
     */
    getGrowAmount() {
    }
    /**
     * @abstract
     * @returns {number}
     */
    getInitialSize() {
    }
    /**
     * @abstract
     * @returns {CachedInstance}
     */
    createInstance() {
    }
    // getLogSizeThreshold() {
    //     return Math.max(this.getGrowAmount() * 20, 1000);
    // }
    /**
     * @override
     * @param {boolean} finished 
     */
    onAvailabilityChanged(finished) {
      if (finished) {
        this.currentActiveCount--;
      } else {
        this.currentActiveCount++;
        this.maxActiveCount = Math.max(this.maxActiveCount, this.currentActiveCount);
      }
    }
  };

  // src/model/character/MonsterCharacterCache.js
  var MonsterCharacterCache = class extends CyclingCache {
    constructor() {
      super();
      this.initialCacheSize = 50;
      this.growAmount = 15;
    }
    /**
     * @override
     * @returns {number}
     */
    getGrowAmount() {
      return this.growAmount;
    }
    /**
     * @override
     * @returns {number}
     */
    getInitialSize() {
      return this.initialCacheSize;
    }
    /**
     * @override
     * @returns {MonsterCharacter}
     */
    createInstance() {
      return new MonsterCharacter();
    }
  };

  // src/model/monster/MonsterBrainIds.js
  var MonsterBrainIds = {
    /**
     * @constant
     * @type {string}
     */
    BASIC: "B"
  };

  // src/util/Rand.js
  var Rand = class {
    constructor() {
    }
    /**
     * Returns a random integer in the range of 0 to limit (exclusive).
     * @param limit The max value of the resulting integer (exclusive).
     * @returns {number}
     */
    static randomInt(limit) {
      return Math.random() * limit | 0;
    }
  };

  // src/util/NearbyTileUtil.js
  var NearbyTileUtil = class {
    constructor() {
    }
    /**
     * Finds an available tile near the main miner that is not occupied
     * by any crew member.
     * @param {Character} character
     * @param {Crew} crew
     * @param {GridTile} tile 
     * @returns {GridTile}
     */
    static findAvailableTileNearMainMiner(character, crew) {
      return this.findAvailableNearbyTile(character, crew, crew.main.position.tile);
    }
    /**
     * Finds an available tile near the specified tile that is not occupied
     * by any crew member.
     * @param {Character} character
     * @param {Crew} crew
     * @param {GridTile} centerTile
     * @returns {GridTile}
     */
    static findAvailableNearbyTile(character, crew, centerTile) {
      if (!centerTile) {
        return null;
      }
      const directNeighbor = this.findAvailableNeighborTile(character, crew, centerTile);
      if (directNeighbor) {
        return directNeighbor;
      }
      const regionNeighbor = this.findAvailableRegionTile(character, crew, centerTile.region);
      if (regionNeighbor) {
        return regionNeighbor;
      }
      const regionTile = this.forceFindTileInRegion(centerTile.region);
      if (regionTile) {
        return regionTile;
      }
      const zoneNeighbor = this.findAvailableZoneTile(character, crew, centerTile.region.zone);
      if (zoneNeighbor) {
        return zoneNeighbor;
      }
      const forcedNeighbor = this.forceFindTileInZone(centerTile.region.zone);
      if (forcedNeighbor) {
        return forcedNeighbor;
      }
      console.log("NearbyTileUtil.findAvailableTileNearMainMiner() Complete failure.");
      return null;
    }
    /**
     * @private
     * @param {Character} character
     * @param {Crew} crew
     * @param {GridTile} tile 
     * @returns {GridTile}
     */
    static findAvailableNeighborTile(character, crew, tile) {
      const neighbors = tile.neighbors;
      for (let i = 0; i < 5; i++) {
        const neighbor = neighbors[Rand.randomInt(neighbors.length)];
        if (neighbor && this.isTileClear(character, crew, neighbor)) {
          return neighbor;
        }
      }
      return null;
    }
    /**
     * @private
     * @param {Character} character
     * @param {Crew} crew 
     * @param {GridZone} zone 
     * @returns {GridTile}
     */
    static findAvailableZoneTile(character, crew, zone) {
      const regions = zone.regions;
      for (let i = 0; i < 5; i++) {
        const region = regions[Rand.randomInt(regions.length)];
        const zoneTile = this.findAvailableRegionTile(character, crew, region);
        if (zoneTile) {
          return zoneTile;
        }
      }
      return null;
    }
    /**
     * @private
     * @param {GridZone} zone 
     * @returns {GridTile}
     */
    static forceFindTileInZone(zone) {
      const regions = zone.regions;
      for (let i = 0; i < regions.length; i++) {
        const tile = this.forceFindTileInRegion(regions[i]);
        if (tile) {
          return tile;
        }
      }
      return null;
    }
    /**
     * @private
     * @param {Character} character
     * @param {Crew} crew 
     * @param {GridRegion} region 
     * @returns {GridTile}
     */
    static findAvailableRegionTile(character, crew, region) {
      const tiles = region.tiles;
      for (let i = 0; i < 12; i++) {
        const regionTile = tiles[Rand.randomInt(tiles.length)];
        if (regionTile && this.isTileClear(character, crew, regionTile)) {
          return regionTile;
        }
      }
      return null;
    }
    /**
     * @private
     * @param {GridRegion} region 
     * @returns {GridTile}
     */
    static forceFindTileInRegion(region) {
      if (!region) {
        return null;
      }
      const tile = region.tiles[Rand.randomInt(region.tiles.length)];
      if (!tile.open) {
        tile.onTileBreak();
      }
      return tile;
    }
    /**
     * @private
     * @param {Character} character
     * @param {Crew} crew
     * @param {GridTile} tile 
     * @returns {boolean}
     */
    static isClosedTileAvailable(character, crew, tile) {
      for (let i = 0; i < crew.miners.length; i++) {
        const miner = crew.miners[i];
        if (miner === character) {
          continue;
        }
        if (tile === miner.target.targetTile) {
          return false;
        }
      }
      return true;
    }
    /**
     * @private
     * @param {Character} character
     * @param {Crew} crew
     * @param {GridTile} tile 
     * @returns {boolean}
     */
    static isTileClear(character, crew, tile) {
      if (!tile || !tile.isTraversable()) {
        return false;
      }
      for (let i = 0; i < crew.miners.length; i++) {
        const miner = crew.miners[i];
        if (miner === character) {
          continue;
        }
        if (tile === miner.position.tile || tile === miner.target.targetTile) {
          return false;
        }
      }
      return true;
    }
  };

  // src/model/character/CharacterClass.js
  var CharacterClass = class {
    /**
     * @param {CharacterSpritesheet} characterSpritesheet 
     */
    constructor(characterSpritesheet) {
      this.characterSpritesheet = characterSpritesheet;
    }
    /**
     * @param {number} characterAction See CharacterAction.
     * @param {number} characterActionStart Timestamp of start of action.
     * @returns {Sprite}
     */
    getSprite(characterAction, characterActionStart) {
      const spriteAnimation = this.characterSpritesheet.getSpriteAnimation(characterAction);
      if (!spriteAnimation) {
        return null;
      }
      return spriteAnimation.getSpriteAsOf(Date.now(), characterActionStart);
    }
  };

  // src/model/item/ItemType.js
  var ItemType = class {
    /**
     * 
     * @param {string} id 
     * @param {string} name 
     * @param {string} attackType See AttackType.  Set to null if this is not a weapon.
     * @param {boolean} armor
     * @param {boolean} accessory 
     * @param {string} iconSpriteName The representative sprite for this type of item. We'll see if we need this.
     */
    constructor(id, name, attackType, armor, accessory, iconSpriteName) {
      this.id = id;
      this.name = name;
      this.attackType = attackType;
      this.armor = armor;
      this.accessory = accessory;
      this.iconSpriteName = iconSpriteName;
    }
  };

  // src/model/item/Item.js
  var Item = class {
    /**
     * @param {ItemType} itemType
     * @param {Sprite} iconSprite
     * @param {SpriteAnimation} staticAnimation
     * @param {SpriteAnimation} activeAnimation
     */
    constructor(itemType, iconSprite, staticAnimation, activeAnimation) {
      this.itemType = itemType;
      this.iconSprite = iconSprite;
      this.staticAnimation = staticAnimation;
      this.activeAnimation = activeAnimation;
      this.itemActive = false;
      this.itemAnimating = false;
      this.activeAnimationStartTime = 0;
    }
    /**
     * This should be called repeatedly on the character's equipped item to keep it up
     * to date on the active status.
     * @param {boolean} itemActive 
     */
    setItemActive(itemActive) {
      this.itemActive = itemActive;
      if (itemActive) {
        if (!this.itemAnimating) {
          this.activeAnimationStartTime = Date.now();
          this.itemAnimating = true;
        }
      } else {
        if (this.itemAnimating && this.activeAnimation.isAnimationLoopCompleted(this.activeAnimationStartTime)) {
          this.itemAnimating = false;
          this.activeAnimationStartTime = 0;
        }
      }
    }
    /**
     * @returns {Sprite}
     */
    getItemOverlaySprite() {
      if (this.itemActive) {
        return this.activeAnimation.getSpriteAsOf(Date.now(), this.activeAnimationStartTime);
      } else if (this.itemAnimating) {
        if (this.activeAnimation.isAnimationLoopCompleted(this.activeAnimationStartTime)) {
          this.itemAnimating = false;
        } else {
          return this.activeAnimation.getSpriteAsOf(Date.now(), this.activeAnimationStartTime);
        }
      }
      return this.staticAnimation.getSpriteAsOf(Date.now(), this.activeAnimationStartTime);
    }
    /**
     * @returns {boolean}
     */
    isAnimationLoopCompleted() {
      if (this.itemAnimating) {
        return this.activeAnimation.isAnimationLoopCompleted(this.activeAnimationStartTime);
      }
      return true;
    }
  };

  // src/model/time/GameTime.js
  var GameTime = class extends GameModel {
    constructor() {
      super();
      this.turnNumber = 0;
      this.frameNumber = 0;
      this.saveTime = 0;
    }
    // resetGameModels() {
    //     this.turnNumber = 0;
    //     this.frameNumber = 0;
    // }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.turnNumber = 0;
      this.frameNumber = 0;
      this.saveTime = 0;
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.turnNumber = 0;
      this.frameNumber = 0;
    }
  };

  // src/model/character/Thruster.js
  var Thruster = class {
    /**
     * 
     * @param {SpriteAnimation} animation 
     * @param {GameTime} gameTime
     */
    constructor(animation, gameTime) {
      this.animation = animation;
      this.gameTime = gameTime;
      this.active = false;
      this.activeTurn = -1;
      this.animationStartTime = 0;
    }
    /**
     * @param {boolean} active 
     */
    setActive(active) {
      if (active && !this.active) {
        this.animationStartTime = Date.now();
      }
      if (active) {
        this.activeTurn = this.gameTime.turnNumber;
      }
      this.active = active;
    }
    deactivateNow() {
      this.active = false;
      this.activeTurn = -1;
    }
    /**
     * The thruster lasts for a full turn at a minimum.
     * @returns {boolean}
     */
    isActive() {
      return this.active || this.activeTurn >= this.gameTime.turnNumber - 1;
    }
    /**
     * @returns {Sprite}
     */
    getOverlaySprite() {
      if (this.isActive()) {
        return this.animation.getSpriteAsOf(Date.now(), this.animationStartTime);
      }
      return null;
    }
  };

  // src/model/value/ValueType.js
  var ValueType = {
    /**
     * @constant
     * @type {number}
     */
    NUMBER: 1,
    /**
     * @constant
     * @type {number}
     */
    BOOLEAN: 2,
    /**
     * @constant
     * @type {number}
     */
    BIG_NUM: 3
  };

  // src/model/value/Value.js
  var Value = class {
    /**
     * @param {string} id 
     */
    constructor(id) {
      this.id = id;
    }
    /**
     * @abstract
     */
    reset() {
    }
    /**
     * @abstract
     * @returns {number}
     */
    getValueType() {
      return ValueType.BIG_NUM;
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isAtInitialValue() {
      return true;
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isValueApplicable() {
      return true;
    }
  };

  // src/model/value/BigNumValue.js
  var BigNumValue = class extends Value {
    /**
     * @param {string} id 
     * @param {BigNum} initialValue
     */
    constructor(id, initialValue) {
      super(id);
      this.initialValue = new BigNum(0).copy(initialValue);
      this.value = new BigNum(0).copy(initialValue);
    }
    /**
     * @returns {BigNum}
     */
    getValue() {
      return this.value;
    }
    /**
     * @param {BigNum} value 
     */
    setValue(value2) {
      this.value.copy(value2);
    }
    setZero() {
      this.value.setZero();
    }
    /**
     * @param {BigNum} value 
     */
    incrementValue(value2) {
      this.value.add(value2);
    }
    /**
     * @override
     */
    reset() {
      this.value.copy(this.initialValue);
    }
    /**
     * @override
     * @returns {number}
     */
    getValueType() {
      return ValueType.BIG_NUM;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isAtInitialValue() {
      return this.value.equals(this.initialValue);
    }
    /**
     * @override
     * @returns {boolean}
     */
    isValueApplicable() {
      return this.value.greaterThanZero();
    }
  };

  // src/model/value/NumberValue.js
  var NumberValue = class extends Value {
    /**
     * @param {string} id 
     * @param {number} initialValue
     */
    constructor(id, initialValue) {
      super(id);
      this.value = initialValue;
      this.initialValue = initialValue;
    }
    /**
     * @returns {number}
     */
    getValue() {
      return this.value;
    }
    /**
     * @param {number} value 
     */
    setValue(value2) {
      this.value = value2;
    }
    /**
     * @param {number} value 
     */
    incrementValue(value2) {
      this.value += value2;
    }
    /**
     * @param {number} value 
     */
    decrementValue(value2) {
      this.value -= value2;
      if (this.value < this.initialValue) {
        this.value = this.initialValue;
      }
    }
    /**
     * This is only applicable if the value represents a percent.
     * @returns {boolean} True if the percentage is randomly determined to be applied.
     */
    isPercentageApplied() {
      if (this.value <= 0) {
        return false;
      } else if (this.value >= 100) {
        return true;
      }
      return Rand.randomInt(100) < this.value;
    }
    /**
     * If the value represents a percentage, return it as a fraction.
     * @returns {number}
     */
    getPercentAsFraction() {
      return this.value === 0 ? 0 : this.value / 100;
    }
    /**
     * @override
     */
    reset() {
      this.value = this.initialValue;
    }
    /**
     * @override
     * @returns {number}
     */
    getValueType() {
      return ValueType.NUMBER;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isAtInitialValue() {
      return this.value === this.initialValue;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isValueApplicable() {
      return this.value > 0;
    }
  };

  // src/model/value/BooleanValue.js
  var BooleanValue = class extends Value {
    /**
     * @param {string} id 
     * @param {boolean} value 
     */
    constructor(id, value2) {
      super(id);
      this.initialValue = value2;
      this.value = value2;
    }
    /**
     * @returns {boolean}
     */
    isValue() {
      return this.value;
    }
    /**
     * @param {boolean} value 
     */
    setValue(value2) {
      this.value = value2;
    }
    toggleValue() {
      this.value = !this.value;
    }
    /**
     * @override
     */
    reset() {
      this.value = this.initialValue;
    }
    /**
     * @override
     * @returns {number}
     */
    getValueType() {
      return ValueType.BOOLEAN;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isAtInitialValue() {
      return this.value === this.initialValue;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isValueApplicable() {
      return this.value != this.initialValue;
    }
  };

  // src/model/value/Values.js
  var Values = class extends GameModel {
    constructor() {
      super();
      this.baseAdditiveBonusPerTurn = new BigNumValue("baseAdditiveBonusPerTurn", new BigNum(0));
      this.baseMultiplicativeBonusValue = new BigNumValue("baseMultiBonusValue", new BigNum(0));
      this.minedDamageBonusMultiplier = new BigNumValue("minedDamageBonusValue", new BigNum(0));
      this.minedOreBonus = new BigNumValue("minedOreBonusValue", new BigNum(0));
      this.bonusOreMultiplier = new NumberValue(null, 0);
      this.bonusUpgradeMultiplier = new NumberValue(null, 0);
      this.bonusGoldIncrement = new NumberValue(null, 0);
      this.goldOreBonusMultiplier = new BigNumValue(null, new BigNum(1));
      this.skillOreBonusMultiplier = new BigNumValue(null, new BigNum(0));
      this.skillPrestigeBonusMultiplier = new NumberValue(null, 0);
      this.skillRubyBonusMultiplier = new NumberValue(null, 0);
      this.skillBlockBonusMultiplier = new NumberValue(null, 0);
      this.skillDepthBonusMultiplier = new NumberValue(null, 0);
      this.skillUpgradeAdditiveBonusMultiplier = new NumberValue(null, 0);
      this.skillUpgradeMultiplicativeBonusMultiplier = new NumberValue(null, 0);
      this.fallSpeedUpgrades = new NumberValue(null, 0);
      this.fallSpeedBonusActive = new BooleanValue(null, false);
      this.skillMinedDamageBonus = new NumberValue(null, 0);
      this.skillMinedOreBonusUpgrades = new NumberValue(null, 0);
      this.minedAutomationUnlocked = new BooleanValue(null, false);
      this.minedAutomationRateUpgrades = new NumberValue(null, 0);
      this.pickAutomationUnlocked = new BooleanValue(null, false);
      this.pickAutomationRateUpgrades = new NumberValue(null, 0);
      this.prestigeAutomationUnlocked = new BooleanValue(null, false);
      this.prestigeAutomationRateUpgrades = new NumberValue(null, 0);
      this.offlineTimeUpgrades = new NumberValue(null, 0);
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.resetForPrestige();
      this.goldOreBonusMultiplier.reset();
      this.skillOreBonusMultiplier.reset();
      this.skillPrestigeBonusMultiplier.reset();
      this.skillRubyBonusMultiplier.reset();
      this.skillBlockBonusMultiplier.reset();
      this.skillDepthBonusMultiplier.reset();
      this.fallSpeedUpgrades.reset();
      this.skillUpgradeAdditiveBonusMultiplier.reset();
      this.skillUpgradeMultiplicativeBonusMultiplier.reset();
      this.skillMinedDamageBonus.reset();
      this.skillMinedOreBonusUpgrades.reset();
      this.minedAutomationUnlocked.reset();
      this.minedAutomationRateUpgrades.reset();
      this.pickAutomationUnlocked.reset();
      this.pickAutomationRateUpgrades.reset();
      this.prestigeAutomationUnlocked.reset();
      this.prestigeAutomationRateUpgrades.reset();
      this.offlineTimeUpgrades.reset();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.baseAdditiveBonusPerTurn.reset();
      this.baseMultiplicativeBonusValue.reset();
      this.minedDamageBonusMultiplier.reset();
      this.minedOreBonus.reset();
      this.bonusOreMultiplier.reset();
      this.bonusUpgradeMultiplier.reset();
      this.bonusGoldIncrement.reset();
    }
  };

  // src/util/ValueCalculator.js
  var ValueCalculator = class {
    constructor() {
    }
    // static testAdditiveUpgrades() {
    //     let row = 1;
    //     let description = getLayerDescriptionForRow(row);
    //     while (description != null) {
    //         this.testCalcAdd(row, description);
    //         row += 25;
    //         if (row > 40000) {
    //             break;
    //         }
    //         description = getLayerDescriptionForRow(row);
    //     }
    // }
    // static testCalcAdd(row, layerDescription) {
    //     const randomFactor = (40 + Rand.randomInt(60)) / 100; // 40%-100%
    //     const additiveBonusFactor = layerDescription.additiveBonusFactor * randomFactor;
    //     console.log('row=' + row 
    //         + ' layerDescription.additiveBonusFactor=' + layerDescription.additiveBonusFactor 
    //         + ' additiveBonusFactor=' + additiveBonusFactor  + ' layer=' + layerDescription.name);
    // }
    /**
     * @param {GridTile} tile 
     * @returns {BigNum}
     */
    static calculateMinedDamageUpgradeValue(tile) {
      const randomFactor = (80 + Rand.randomInt(20)) / 100;
      return new BigNum(tile.tileType.layerDescription.multiplicativeBonusFactor * randomFactor);
    }
    /**
     * @param {NumberValue} damageUpgrades 
     * @returns {number}
     */
    static getDamageMultiplier(damageUpgrades) {
      return 1 + Settings.skill.common.damagePerUpgrade * damageUpgrades.getValue();
    }
    /**
     * @param {NumberValue} damageUpgrades 
     * @returns {number}
     */
    static getDamagePercent(damageUpgrades) {
      return Settings.skill.common.damagePercentPerUpgrade * damageUpgrades.getValue();
    }
    /**
     * @param {NumberValue} durationUpgrades 
     * @returns {number}
     */
    static getSkillActivationTurns(durationUpgrades) {
      return Settings.skill.common.baseActivationTurns + durationUpgrades.getValue() * Settings.skill.common.activationTurnsPerUpgrade;
    }
    /**
     * @param {NumberValue} durationUpgrades 
     * @returns {number}
     */
    static getSkillActivationSeconds(durationUpgrades) {
      return this.getSkillActivationTurns(durationUpgrades) * Settings.time.secondsPerTurn;
    }
    /**
     * @param {NumberValue} coolDownUpgrades 
     * @returns {number}
     */
    static getSkillCoolDownTurns(coolDownUpgrades) {
      const upgradedTurns = coolDownUpgrades.getValue() * Settings.skill.common.coolDownTurnsPerUpgrade;
      return Math.max(8, Settings.skill.common.baseCoolDownTurns - upgradedTurns);
    }
    /**
     * @param {NumberValue} coolDownUpgrades 
     * @returns {number}
     */
    static getSkillCoolDownSeconds(coolDownUpgrades) {
      return this.getSkillCoolDownTurns(coolDownUpgrades) * Settings.time.secondsPerTurn;
    }
    /**
     * @param {NumberValue} missilesUpgrades 
     * @returns {number}
     */
    static getMissileCount(missilesUpgrades) {
      return Settings.skill.missiles.initialMissiles + Settings.skill.missiles.missilesPerUpgrade * missilesUpgrades.getValue();
    }
    /**
     * @param {number} fallSpeedUpgrades 
     * @returns {number}
     */
    static getFallSpeedMultiplier(fallSpeedUpgrades) {
      return 1 + fallSpeedUpgrades * Settings.skill.bonus.fallSpeedMuliplierPerUgrade;
    }
  };

  // src/model/character/PartyCharacter.js
  var PartyCharacter = class extends Character {
    /**
     * @param {CharacterClass} characterClass
     * @param {Values} values
     * @param {number} minerIndex
     */
    constructor(characterClass, values, minerIndex) {
      super();
      this.id = "" + minerIndex;
      this.characterClass = characterClass;
      this.values = values;
      this.minerIndex = minerIndex;
      this.pick = null;
      this.thruster = null;
      this.characterAction = CharacterAction.STAND;
      this.characterActionStart = Date.now();
      this.skillId = null;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isMonster() {
      return false;
    }
    /**
     * @returns {boolean}
     */
    isPartyMember() {
      return true;
    }
    /**
     * Returns -1 if this isn't a miner in the crew.
     * @abstract
     * @returns {number}
     */
    getMinerIndex() {
      return this.minerIndex;
    }
    /**
     * @override
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart
     */
    performFrameActions(frameTimeRatio, turnStart) {
      if (!this.turnAction) {
        this.updateThrusterStatus();
        return;
      }
      this.turnAction.performAction(this, frameTimeRatio, turnStart);
    }
    /**
     * @override
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     */
    followPathPlan(frameTimeRatio, turnStart) {
      if (this.position.pathPlan.length === 0) {
        return;
      }
      const pathPlan = this.position.pathPlan[0];
      if (this.values.fallSpeedBonusActive.isValue()) {
        pathPlan.fallSpeedMultiplier = ValueCalculator.getFallSpeedMultiplier(this.values.fallSpeedUpgrades.getValue());
      } else {
        pathPlan.fallSpeedMultiplier = 1;
      }
      if (pathPlan.executePlan(this, frameTimeRatio, turnStart)) {
        this.position.pathPlan.shift();
        if (this.position.pathPlan.length > 0) {
          const next = this.position.pathPlan[0];
          if (next.isSolidFloorRequiredAtStart()) {
            this.updateThrusterStatus();
          }
        } else {
          this.updateThrusterStatus();
          this.pathCompletedTime = Date.now();
        }
      }
    }
    /**
     * @private
     * Check to see if the tile below the character is open air, and if so, add in a sand block.
     * This should be invoked at the end of a path plan execution, unless it is a 'falling' plan.
     */
    updateThrusterStatus() {
      const tile = this.position.tile;
      const neighbor = tile.getNeighborBottom();
      if (!neighbor || neighbor.isTraversable()) {
        this.thruster.setActive(true);
      } else {
        this.thruster.deactivateNow();
      }
    }
    /**
     * @override
     * @param {number} characterAction  See CharacterAction
     */
    setCharacterAction(characterAction) {
      if (this.characterAction !== characterAction) {
        this.characterAction = characterAction;
        this.characterActionStart = Date.now();
      }
      this.pick.setItemActive(this.characterAction === CharacterAction.MINE);
      if (this.characterAction !== CharacterAction.JUMP && this.characterAction !== CharacterAction.FALL) {
        this.updateThrusterStatus();
      }
    }
    /**
     * @returns {Sprite}
     */
    getCharacterSprite() {
      return this.characterClass.getSprite(this.characterAction, this.characterActionStart);
    }
    /**
     * @returns {Sprite}
     */
    getItemOverlaySprite() {
      if (this.pick) {
        return this.pick.getItemOverlaySprite();
      }
      return null;
    }
    /**
     * @returns {Sprite}
     */
    getThrusterOverlaySprite() {
      return this.thruster.getOverlaySprite();
    }
    /**
     * @override
     * @returns {boolean}
     */
    isThrusterActive() {
      return this.thruster.isActive();
    }
  };

  // src/model/item/ItemTypes.js
  var ItemTypes = {
    pick: new ItemType("1", "Pick", false, false, ItemSpriteIds.pick.icon),
    sword: new ItemType("2", "Sword", false, false, ItemSpriteIds.broadSword.icon)
    // helm?
    // boots/armor/etc?
  };

  // src/model/crew/Crew.js
  var Crew = class extends GameModel {
    /**
     * @param {WorldGrid} worldGrid
     * @param {GameTime} gameTime
     * @param {CharacterSpritesheet} characterSpritesheet
     * @param {ItemOverlaySpritesheet} itemOverlaySpritesheet
     * @param {Values} values
     */
    constructor(worldGrid, gameTime, characterSpritesheet, itemOverlaySpritesheet, values) {
      super();
      this.worldGrid = worldGrid;
      this.gameTime = gameTime;
      this.characterSpritesheet = characterSpritesheet;
      this.values = values;
      this.itemOverlaySpritesheet = itemOverlaySpritesheet;
      this.main = null;
      this.miners = [];
      this.centerTile = null;
      this.workingCenter = new Vector(0, 0);
    }
    resetTargets() {
      for (let i = 0; i < this.miners.length; i++) {
        this.miners[i].target.resetTarget();
      }
    }
    // resetTurnStates() {
    //     for (let i = 0; i < this.miners.length; i++) {
    //         this.miners[i].resetTurnState();
    //     }
    // }
    /**
     * 
     * @param {Character} character 
     * @returns {number}
     */
    findMinerIndex(character) {
      return this.miners.indexOf(character);
    }
    /**
     * @param {Vector} outputVector 
     */
    calculateCrewCenterCoordinate(outputVector) {
      if (this.miners.length === 1) {
        outputVector.copy(this.miners[0].position.worldCoordinateOrigin);
        return;
      }
      let x = 0;
      let y = 0;
      for (let i = 0; i < this.miners.length; i++) {
        const pos = this.miners[i].position.worldCoordinateOrigin;
        x += pos.x;
        y += pos.y;
      }
      x = x / this.miners.length;
      y = y / this.miners.length;
      outputVector.x = x;
      outputVector.y = y;
    }
    /**
     * @returns {GridTile}
     */
    calculateCrewCenterTile() {
      if (this.miners.length === 1) {
        const mainTile = this.miners[0].position.tile;
        if (mainTile) {
          this.centerTile = mainTile;
          return mainTile;
        }
        this.centerTile = this.worldGrid.findGridTile(this.miners[0].position.worldCoordinateOrigin);
        return this.centerTile;
      } else {
        this.calculateCrewCenterCoordinate(this.workingCenter);
        const tile = this.worldGrid.findGridTile(this.workingCenter);
        if (tile) {
          this.centerTile = tile;
          return tile;
        } else {
          console.log("Crew.getCrewCenterTile() failed to find tile: " + this.workingCenter.toString());
        }
        for (let i = 0; i < this.miners.length; i++) {
          const currentTile = this.miners[i].position.tile;
          if (currentTile) {
            this.centerTile = currentTile;
            return this.centerTile;
          }
        }
        return null;
      }
    }
    /**
     * @returns {PartyCharacter}
     */
    createMainMiner() {
      this.main = new PartyCharacter(new CharacterClass(this.characterSpritesheet), this.values, this.miners.length);
      this.initializeCharacter(this.main);
      this.miners.push(this.main);
      return this.main;
    }
    /**
     * @param {string} skillId
     */
    addNewMinerNearMain(skillId) {
      if (!this.main.position.tile) {
        console.log("Crew.addNewMinerNearMain() ERROR main miner does not have a tile.");
        return;
      }
      const nearbyTile = NearbyTileUtil.findAvailableTileNearMainMiner(null, this);
      const character = new PartyCharacter(new CharacterClass(this.characterSpritesheet), this.values, this.miners.length);
      character.skillId = skillId;
      this.initializeCharacter(character);
      this.miners.push(character);
      character.position.setTileAndOriginPosition(nearbyTile, nearbyTile.origin.x, nearbyTile.origin.y);
    }
    /**
     * @returns {PartyCharacter}
     */
    addNewMinerForSaveLoad() {
      const character = new PartyCharacter(new CharacterClass(this.characterSpritesheet), this.values, this.miners.length);
      this.initializeCharacter(character);
      this.miners.push(character);
      return character;
    }
    /**
     * @param {PartyCharacter} character 
     */
    initializeCharacter(character) {
      if (!this.itemOverlaySpritesheet.loaded) {
        console.log("Crew.initializeCharacter() itemOverlaySpritesheet not loaded yet");
      }
      const pickStaticAnimation = this.itemOverlaySpritesheet.getSpriteAnimation(ItemSpriteIds.pick.staticOverlay);
      const pickActiveAnimation = this.itemOverlaySpritesheet.getSpriteAnimation(ItemSpriteIds.pick.activeOverlay);
      const thrusterAnimation = this.itemOverlaySpritesheet.getSpriteAnimation(ItemSpriteIds.thruster.activeOverlay);
      character.pick = new Item(ItemTypes.pick, null, pickStaticAnimation, pickActiveAnimation);
      character.thruster = new Thruster(thrusterAnimation, this.gameTime);
    }
    /**
     * @param {Grid} grid 
     */
    onGridUnload(grid) {
      for (let i = 0; i < this.miners.length; i++) {
        const miner = this.miners[i];
        miner.target.onGridUnload(grid);
      }
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.miners.length = 0;
      this.main = null;
      this.centerTile = null;
    }
    /**
     * @override
     */
    resetForPrestige() {
      for (let i = 0; i < this.miners.length; i++) {
        const miner = this.miners[i];
        miner.resetGameModel();
        this.setInitialMinerPosition(miner, i);
      }
      this.centerTile = null;
    }
    /**
     * @private
     * @param {PartyCharacter} miner
     * @param {number} minerIndex 
     */
    setInitialMinerPosition(miner, minerIndex) {
      switch (minerIndex) {
        case 0:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX, Settings.start.startY);
          break;
        case 1:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX - Settings.tile.size * 2, Settings.start.startY);
          break;
        case 2:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX + Settings.tile.size * 2, Settings.start.startY);
          break;
        case 3:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX - Settings.tile.size * 4, Settings.start.startY);
          break;
        case 4:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX + Settings.tile.size * 4, Settings.start.startY);
          break;
        case 5:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX - Settings.tile.size * 6, Settings.start.startY);
          break;
        case 6:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX + Settings.tile.size * 6, Settings.start.startY);
          break;
        case 7:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX - Settings.tile.size * 8, Settings.start.startY);
          break;
        case 8:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX + Settings.tile.size * 8, Settings.start.startY);
          break;
        case 9:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX - Settings.tile.size * 10, Settings.start.startY);
          break;
        case 10:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX + Settings.tile.size * 10, Settings.start.startY);
          break;
        case 11:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX, Settings.start.startY + Settings.tile.size * 2);
          break;
        case 12:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX - Settings.tile.size * 2, Settings.start.startY + Settings.tile.size * 2);
          break;
        case 13:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX + Settings.tile.size * 2, Settings.start.startY + Settings.tile.size * 2);
          break;
        case 14:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX - Settings.tile.size * 4, Settings.start.startY + Settings.tile.size * 2);
          break;
        case 15:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX + Settings.tile.size * 4, Settings.start.startY + Settings.tile.size * 2);
          break;
        case 16:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX - Settings.tile.size * 6, Settings.start.startY + Settings.tile.size * 2);
          break;
        case 17:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX + Settings.tile.size * 6, Settings.start.startY + Settings.tile.size * 2);
          break;
        case 18:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX - Settings.tile.size * 8, Settings.start.startY + Settings.tile.size * 2);
          break;
        case 19:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX + Settings.tile.size * 8, Settings.start.startY + Settings.tile.size * 2);
          break;
        case 20:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX - Settings.tile.size * 10, Settings.start.startY + Settings.tile.size * 2);
          break;
        case 21:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX + Settings.tile.size * 10, Settings.start.startY + Settings.tile.size * 2);
          break;
        default:
          miner.position.setWorldCoordinateOriginXY(Settings.start.startX, Settings.start.startY);
          break;
      }
    }
  };

  // src/model/crew/Damage.js
  var Damage = class extends GameModel {
    constructor() {
      super();
      this.basePickDamagePerTurn = new BigNum(Settings.damage.baseDamagePerTurn);
      this.totalPickDamagePerTurn = new BigNum(Settings.damage.baseDamagePerTurn);
      this.minedDamageMultiplier = new BigNum(1);
      this.prestigeDamageMultiplier = new BigNum(1);
      this.goldDamageMultiplier = new BigNum(1);
      this.depthDamageMultiplier = new BigNum(1);
      this.rubyDamageMultiplier = new BigNum(1);
      this.blockDamageMultiplier = new BigNum(1);
      this.totalPickDamagePerFrame = new BigNum(1);
      this.totalPickDamagePerFrame.copy(this.totalPickDamagePerTurn);
      this.totalPickDamagePerFrame.divNumber(Settings.time.turnFrames);
      this.working = new BigNum(0);
    }
    /**
     * Given the max number of seconds we want to spend mining a tile, calculate
     * the max health of the tile.
     * @param {number} maxMiningSeconds 
     * @param {BigNum} maxBrickHealthOutput The output param.
     */
    calculateMaxBrickHealth(maxMiningSeconds, maxBrickHealthOutput) {
      const maxMiningTurns = maxMiningSeconds * Settings.time.turnsPerSecond;
      maxBrickHealthOutput.copy(this.totalPickDamagePerTurn);
      maxBrickHealthOutput.mulNumber(maxMiningTurns);
    }
    /**
     * Given the health of a brick, how long would it take to mine?
     * @param {BigNum} brickHealth 
     * @returns {number}
     */
    calculateMineSeconds(brickHealth) {
      this.working.copy(brickHealth);
      this.working.div(this.totalPickDamagePerTurn);
      this.working.mulNumber(Settings.time.secondsPerTurn);
      return this.working.toNumber();
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.resetForPrestige();
      this.minedDamageMultiplier.setValue(1);
      this.prestigeDamageMultiplier.setValue(1);
      this.goldDamageMultiplier.setValue(1);
      this.depthDamageMultiplier.setValue(1);
      this.rubyDamageMultiplier.setValue(1);
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.basePickDamagePerTurn.setValue(Settings.damage.baseDamagePerTurn);
      this.totalPickDamagePerTurn.setValue(Settings.damage.baseDamagePerTurn);
      this.totalPickDamagePerFrame.setValue(1);
    }
  };

  // src/model/crew/ValuePerTurnCalculator.js
  var ValuePerTurnCalculator = class extends GameModel {
    /**
     * 
     * @param {GameTime} gameTime 
     * @param {number} batchSeconds
     * @param {number} penaltyFactor
     */
    constructor(gameTime, batchSeconds, penaltyFactor) {
      super();
      this.gameTime = gameTime;
      this.batchTurnSize = batchSeconds * Settings.time.turnsPerSecond;
      this.penaltyFactor = new BigNum(penaltyFactor);
      this.sum = new BigNum(0);
      this.startTurn = gameTime.turnNumber;
      this.valuePerTurn = new BigNum(0);
      this.rates = [];
      this.rateIndex = 0;
    }
    /**
     * @param {BigNum} value 
     * @param {BigNum} valuePerTurnOut
     * @returns {BigNum}
     */
    add(value2, valuePerTurnOut) {
      this.sum.add(value2);
      const elapsed = this.gameTime.turnNumber - this.startTurn;
      if (elapsed > this.batchTurnSize) {
        this.sum.divNumber(elapsed);
        this.addToRollingAverage(this.sum);
        this.calculateValuePerTurn();
        this.startTurn = this.gameTime.turnNumber;
        this.sum.setZero();
      }
      valuePerTurnOut.copy(this.valuePerTurn);
    }
    /**
     * @private
     * @param {BigNum} valuePerTurn 
     */
    addToRollingAverage(valuePerTurn) {
      if (this.rates.length < 10) {
        const rate = new BigNum(0);
        rate.copy(valuePerTurn);
        this.rates.push(rate);
      } else {
        this.rates[this.rateIndex].copy(valuePerTurn);
        this.rateIndex++;
        if (this.rateIndex >= this.rates.length) {
          this.rateIndex = 0;
        }
      }
    }
    /**
     * @private
     */
    calculateValuePerTurn() {
      this.valuePerTurn.setZero();
      if (this.rates.length > 0) {
        for (let i = 0; i < this.rates.length; i++) {
          this.valuePerTurn.add(this.rates[i]);
        }
        this.valuePerTurn.divNumber(this.rates.length);
        this.valuePerTurn.mul(this.penaltyFactor);
      }
    }
    /**
     * @override
     */
    resetFull() {
      this.sum.setZero();
      this.startTurn = this.gameTime.turnNumber;
      this.rates.length = 0;
      this.rateIndex = 0;
      this.valuePerTurn.setZero();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.startTurn = this.gameTime.turnNumber;
    }
  };

  // src/model/crew/Totals.js
  var Totals = class extends GameModel {
    /**
     * 
     * @param {GameTime} gameTime
     */
    constructor(gameTime) {
      super();
      this.oreRatePerTurnCalculator = new ValuePerTurnCalculator(gameTime, 20, 0.5);
      this.goldRatePerTurnCalculator = new ValuePerTurnCalculator(gameTime, 20, 0.5);
      this.prestigeRatePerTurnCalculator = new ValuePerTurnCalculator(gameTime, 20, 0.5);
      this.rubyRatePerTurnCalculator = new ValuePerTurnCalculator(gameTime, 20, 0.5);
      this.ore = new BigNum(0);
      this.gold = new BigNum(0);
      this.ruby = new BigNum(0);
      this.prestige = new BigNum(0);
      this.prestigePointsSum = new BigNum(0);
      this.unclaimedPrestige = new BigNum(0);
      this.working = new BigNum(0);
      this.prestigePerTurn = new BigNum(0);
      this.goldPerTurn = new BigNum(0);
      this.orePerTurn = new BigNum(0);
      this.rubyPerTurn = new BigNum(0);
      this.offlinePrestige = new BigNum(0);
      this.offlineGold = new BigNum(0);
      this.offlineOre = new BigNum(0);
      this.offlineRuby = new BigNum(0);
      this.offlineSeconds = 0;
      this.countedOfflineSeconds = 0;
      this.one = new BigNum(1);
    }
    /**
     * @param {BigNum} ore 
     */
    incrementOre(ore) {
      this.ore.add(ore);
      this.oreRatePerTurnCalculator.add(ore, this.orePerTurn);
    }
    /**
     * @param {BigNum} ore 
     */
    decrementOre(ore) {
      this.ore.sub(ore);
      if (this.ore.lessThanZero()) {
        this.ore.setZero();
      }
    }
    /**
     * @param {BigNum} gold 
     */
    incrementGold(gold) {
      this.gold.add(gold);
      this.goldRatePerTurnCalculator.add(gold, this.goldPerTurn);
    }
    /**
     * @param {BigNum} gold 
     */
    decrementGold(gold) {
      this.gold.sub(gold);
      if (this.gold.lessThanZero()) {
        this.gold.setZero();
      }
    }
    /**
     * @param {BigNum} ruby 
     */
    incrementRuby(ruby) {
      this.ruby.add(ruby);
      this.rubyRatePerTurnCalculator.add(ruby, this.rubyPerTurn);
    }
    /**
     * @param {BigNum} prestige 
     */
    decrementPrestige(prestige) {
      this.prestige.sub(prestige);
      if (this.prestige.lessThanZero()) {
        this.prestige.setZero();
      }
    }
    onTerrainLayerUnlocked() {
      this.unclaimedPrestige.add(this.one);
    }
    /**
     * @param {BigNum} prestige 
     */
    incrementOfflinePrestige(prestige) {
      this.offlinePrestige.add(prestige);
    }
    /**
     * @param {BigNum} gold 
     */
    incrementOfflineGold(gold) {
      this.offlineGold.add(gold);
    }
    /**
     * @param {BigNum} ore 
     */
    incrementOfflineOre(ore) {
      this.offlineOre.add(ore);
    }
    /**
     * @param {BigNum} ruby 
     */
    incrementOfflineRuby(ruby) {
      this.offlineRuby.add(ruby);
    }
    claimOfflineEarnings() {
      this.countedOfflineSeconds = 0;
      this.prestige.add(this.offlinePrestige);
      this.prestigePointsSum.add(this.offlinePrestige);
      this.offlinePrestige.setZero();
      this.gold.add(this.offlineGold);
      this.offlineGold.setZero();
      this.ore.add(this.offlineOre);
      this.offlineOre.setZero();
      this.ruby.add(this.offlineRuby);
      this.offlineRuby.setZero();
    }
    onPrestige() {
      this.prestigeRatePerTurnCalculator.add(this.unclaimedPrestige, this.prestigePerTurn);
      this.prestige.add(this.unclaimedPrestige);
      this.prestigePointsSum.add(this.unclaimedPrestige);
      this.unclaimedPrestige.setZero();
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.prestige.setZero();
      this.prestigePointsSum.setZero();
      this.unclaimedPrestige.setZero();
      this.gold.setZero();
      this.ruby.setZero();
      this.orePerTurn.setZero();
      this.prestigePerTurn.setZero();
      this.goldPerTurn.setZero();
      this.rubyPerTurn.setZero();
      this.offlinePrestige.setZero();
      this.offlineGold.setZero();
      this.offlineOre.setZero();
      this.offlineRuby.setZero();
      this.oreRatePerTurnCalculator.resetFull();
      this.goldRatePerTurnCalculator.resetFull();
      this.prestigeRatePerTurnCalculator.resetFull();
      this.rubyRatePerTurnCalculator.resetFull();
      this.resetForPrestige();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.ore.setZero();
      this.oreRatePerTurnCalculator.resetForPrestige();
      this.goldRatePerTurnCalculator.resetForPrestige();
      this.prestigeRatePerTurnCalculator.resetForPrestige();
      this.rubyRatePerTurnCalculator.resetForPrestige();
    }
  };

  // src/model/sprite/SpriteDirection.js
  var SpriteDirection = {
    NORTH: 0,
    NORTH_EAST: 1,
    EAST: 2,
    SOUTH_EAST: 3,
    SOUTH: 4,
    SOUTH_WEST: 5,
    WEST: 6,
    NORTH_WEST: 7
  };

  // src/model/effect/EffectStatus.js
  var EffectStatus = {
    /**
     * @constant
     * @type {number}
     */
    FINISHED_AND_AVAILABLE_FOR_CACHE: 1,
    /**
     * @constant
     * @type {number}
     */
    FINISHED_BUT_IN_USE: 2,
    /**
     * @constant
     * @type {number}
     */
    NOT_STARTED: 3,
    /**
     * @constant
     * @type {number}
     */
    STARTED_NOT_FINISHED: 4
  };

  // src/model/effect/EffectType.js
  var EffectType = {
    /**
     * @constant
     * @type {number}
     */
    SPRITE_EFFECT: 0,
    /**
     * @constant
     * @type {number}
     */
    LIGHTNING_EFFECT: 1,
    /**
     * @constant
     * @type {number}
     */
    AREA_EFFECT: 2
    // /**
    //  * @constant
    //  * @type {number}
    //  */
    // PATH_EFFECT: 3
  };

  // src/model/effect/Effect.js
  var Effect = class extends CachedInstance {
    constructor() {
      super();
      this.effectOwner = null;
      this.effectStatus = EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE;
      this.startTime = 0;
    }
    /**
     * @param {Character} effectOwner
     */
    set(effectOwner) {
      this.effectOwner = effectOwner;
      this.effectStatus = EffectStatus.NOT_STARTED;
      this.startTime = Date.now();
    }
    // /**
    //  * @param {Character} effectOwner
    //  * @param {SpriteAnimation} spriteAnimation
    //  * @param {SoundEffect} soundEffect
    //  * @param {LightSource} lightSource 
    //  */
    // set(effectOwner, spriteAnimation, soundEvent, lightSource) {
    //     this.effectOwner = effectOwner;
    //     this.soundEffect = soundEvent;
    //     this.lightSource = lightSource;
    //     this.spriteAnimation = spriteAnimation;
    //     this.effectStatus = EffectStatus.NOT_STARTED;
    //     this.startTime = Date.now();
    // }
    // /**
    //  * @returns {boolean}
    //  */
    // isTravelEffect() {
    //     return false;
    // }
    /**
     * Returns the sprite direction (see the SpriteDirection enum)
     * @returns {number}
     */
    getSpriteDirection() {
      return SpriteDirection.NORTH;
    }
    // /**
    //  * @returns {SoundEffect}
    //  */
    // getSoundEffect() {
    //     return this.soundEffect;
    // }
    // /**
    //  * @returns {LightSource}
    //  */
    // getLightSource() {
    //     return this.lightSource;
    // }
    /**
     * @returns {number}
     */
    getEffectType() {
      return EffectType.SPRITE_EFFECT;
    }
    /**
     * @returns {Character}
     */
    getEffectOwner() {
      return this.effectOwner;
    }
    /**
     * @returns {Sprite}
     */
    getSprite() {
      return null;
    }
    /**
     * @abstract
     * @returns {Vector}
     */
    getPosition() {
      return null;
    }
    /**
     * @returns {boolean}
     */
    isEffectStarted() {
      return this.effectStatus === EffectStatus.STARTED_NOT_FINISHED;
    }
    /**
     * @returns {boolean}
     */
    isNotStarted() {
      return this.effectStatus === EffectStatus.NOT_STARTED;
    }
    /**
     * @returns {boolean}
     */
    isEffectFinished() {
      return this.effectStatus === EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE || this.effectStatus === EffectStatus.FINISHED_BUT_IN_USE;
    }
    markEffectAsFinishedButInUse() {
      if (this.effectStatus === EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE) {
        return;
      }
      this.effectStatus = EffectStatus.FINISHED_BUT_IN_USE;
    }
    /**
     * @param {number} frameTimeRatio 
     */
    updateEffectForFrame(frameTimeRatio) {
      if (this.isEffectFinished()) {
        return;
      }
      if (this.effectStatus === EffectStatus.NOT_STARTED) {
        this.startTime = Date.now();
      }
      this.effectStatus = EffectStatus.STARTED_NOT_FINISHED;
      this.updateEffectForFrameInternal(frameTimeRatio);
    }
    // /**
    //  * @private
    //  * @param {LightingCalculator} lightingCalculator 
    //  */
    // removeDynamicLightSourceOnFinish(lightingCalculator) {
    //     if (this.isEffectFinished() && this.lightSource != null) {
    //         this.lightSource.reset(true);
    //         lightingCalculator.removeDynamicLightSource(this.lightSource);
    //         this.lightSource = null;
    //     }
    // }
    /**
     * @param {number} frameTimeRatio 
     */
    updateEffectForFrameInternal(frameTimeRatio) {
    }
    /**
     * @returns {number}
     */
    getStartTime() {
      return this.startTime;
    }
    /**
     * @returns {number}
     */
    getEffectStatus() {
      return this.effectStatus;
    }
    /**
     * @param {number} frameTime 
     */
    refreshStartTime(frameTime) {
      this.startTime = frameTime;
    }
    /////////////////////////////////////
    // CachedInstance
    /////////////////////////////////////
    /**
     * @override
     */
    isFinishedAndAvailable() {
      return this.effectStatus == EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE;
    }
    /**
     * @override
     * @param {boolean} finishedAndAvailable 
     */
    reset(finishedAndAvailable) {
      const currentlyFinished = this.effectStatus == EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE;
      if (currentlyFinished != finishedAndAvailable) {
        if (finishedAndAvailable) {
          this.spriteAnimation = null;
        }
        this.effectStatus = finishedAndAvailable ? EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE : EffectStatus.NOT_STARTED;
        this.startTime = 0;
        this.listener.onAvailabilityChanged(finishedAndAvailable);
      }
    }
  };

  // src/model/effect/EffectCreator.js
  var EffectCreator = class {
    constructor() {
    }
    /**
     * @abstract
     * @param {Character} effectOwner 
     * @param {Vector} effectPosition 
     * @returns {Effect}
     */
    createEffect(effectOwner, effectPosition) {
      return null;
    }
    /**
     * @abstract
     * @param {Character} effectOwner 
     * @param {GridTile} tile
     * @returns {Effect}
     */
    createEffectAtTile(effectOwner, tile) {
      return null;
    }
    /**
     * @abstract
     * @param {Character} effectOwner 
     * @param {Vector} position The origin position (top left)
     * @returns {Effect}
     */
    createEffectAtPosition(effectOwner, position) {
      return null;
    }
    /**
     * @abstract
     * @returns {SpriteAnimation}
     */
    getSpriteAnimation() {
      return null;
    }
  };

  // src/model/color/DawnBringerPalette.js
  var DawnBringerPalette = {
    BLACK_OPACITY: Color.createColor(336338048),
    // 80 alpha instead of FF
    RED_OPACITY: Color.createColor(3494267008),
    DARK_GRAY_OPACITY: Color.createColor(1313492864),
    DARK_RED_OPACITY: Color.createColor(1143223424),
    BLACK: Color.createColor(336338175),
    DARK_RED: Color.createColor(1143223551),
    DARK_BLUE: Color.createColor(808742399),
    DARK_GRAY: Color.createColor(1313492991),
    BROWN: Color.createColor(2236363007),
    DARK_GREEN: Color.createColor(879043839),
    RED: Color.createColor(3494267135),
    LIGHT_GRAY: Color.createColor(1970364927),
    LIGHT_BLUE: Color.createColor(1501417215),
    ORANGE: Color.createColor(3531418879),
    BLUE_GRAY: Color.createColor(2241176063),
    LIGHT_GREEN: Color.createColor(1839869183),
    PEACH: Color.createColor(3534395903),
    CYAN: Color.createColor(1841482495),
    YELLOW: Color.createColor(3671351039),
    WHITE: Color.createColor(3740194559)
  };

  // src/model/lighting/FlickeringLightSource.js
  var FlickeringLightSource = class extends LightSource {
    constructor() {
      super();
      this.flickerColor = new Color(1, 1, 1, 1);
    }
    /**
     * @override
     * @returns {Color}
     */
    getColor() {
      this.flickerColor.set(this.color);
      const s = -0.05 + 0.1 * Math.random();
      this.flickerColor.add(s, s, s, 0);
      return this.flickerColor;
    }
    /**
     * @override
     * @returns {number}
     */
    getTileRadius() {
      return this.radius + (Math.random() < 0.15 ? 1 : 0);
    }
  };

  // src/model/lighting/LightSourceCache.js
  var LightSourceCache = class extends CyclingCache {
    constructor() {
      super();
    }
    /**
     * @returns {number}
     */
    getGrowAmount() {
      return 5;
    }
    /**
     * @returns {number}
     */
    getInitialSize() {
      return 5;
    }
    /**
     * @override
     * @returns {LightSource}
     */
    createInstance() {
      return new LightSource();
    }
  };

  // src/model/lighting/FlickeringLightSourceCache.js
  var FlickeringLightSourceCache = class extends LightSourceCache {
    constructor() {
      super();
    }
    /**
     * @override
     * @returns {LightSource}
     */
    createInstance() {
      return new FlickeringLightSource();
    }
  };

  // src/model/lighting/LightSourceCreator.js
  var LightSourceCreator = class {
    /**
     * @param {Color} color 
     * @param {number} radius 
     * @param {LightSourceCache} lightSourceCache 
     */
    constructor(color, radius, lightSourceCache) {
      this.color = color;
      this.radius = radius;
      this.lightSourceCache = lightSourceCache;
    }
    /**
     * @param {GridTile} tile
     * @returns {LightSource}
     */
    createLightSource(tile) {
      const lightSource = this.lightSourceCache.get();
      lightSource.set(tile, this.color, this.radius);
      return lightSource;
    }
  };

  // src/model/lighting/LightSourceCreators.js
  var LightSourceCreators = class extends GameModel {
    constructor() {
      super();
      const radius = Settings.lighting.lightSourceRadius;
      this.lightSourceCache = new LightSourceCache();
      this.flickeringLightSourceCache = new FlickeringLightSourceCache();
      this.lightGreenFlickering = new LightSourceCreator(DawnBringerPalette.LIGHT_GREEN, radius, this.flickeringLightSourceCache);
      this.darkGreenFlickering = new LightSourceCreator(DawnBringerPalette.DARK_GREEN, radius, this.flickeringLightSourceCache);
      this.cyanFlickering = new LightSourceCreator(DawnBringerPalette.CYAN, radius, this.flickeringLightSourceCache);
      this.orangeFlickering = new LightSourceCreator(DawnBringerPalette.ORANGE, radius, this.flickeringLightSourceCache);
      this.yellowFlickering = new LightSourceCreator(DawnBringerPalette.YELLOW, radius, this.flickeringLightSourceCache);
      this.peachFlickering = new LightSourceCreator(DawnBringerPalette.PEACH, radius, this.flickeringLightSourceCache);
      this.lightBlueFlickering = new LightSourceCreator(DawnBringerPalette.LIGHT_BLUE, radius, this.flickeringLightSourceCache);
      this.darkBlueFlickering = new LightSourceCreator(DawnBringerPalette.DARK_BLUE, radius, this.flickeringLightSourceCache);
      this.whiteFlickering = new LightSourceCreator(DawnBringerPalette.WHITE, radius, this.flickeringLightSourceCache);
      this.redFlickering = new LightSourceCreator(DawnBringerPalette.RED, radius, this.flickeringLightSourceCache);
      this.darkRedFlickering = new LightSourceCreator(DawnBringerPalette.DARK_RED, radius, this.flickeringLightSourceCache);
      this.lightGrayFlickering = new LightSourceCreator(DawnBringerPalette.LIGHT_GRAY, radius, this.flickeringLightSourceCache);
      this.lightGreen = new LightSourceCreator(DawnBringerPalette.LIGHT_GREEN, radius, this.lightSourceCache);
      this.darkGreen = new LightSourceCreator(DawnBringerPalette.DARK_GREEN, radius, this.lightSourceCache);
      this.cyan = new LightSourceCreator(DawnBringerPalette.CYAN, radius, this.lightSourceCache);
      this.orange = new LightSourceCreator(DawnBringerPalette.ORANGE, radius, this.lightSourceCache);
      this.yellow = new LightSourceCreator(DawnBringerPalette.YELLOW, radius, this.lightSourceCache);
      this.peach = new LightSourceCreator(DawnBringerPalette.PEACH, radius, this.lightSourceCache);
      this.lightBlue = new LightSourceCreator(DawnBringerPalette.LIGHT_BLUE, radius, this.lightSourceCache);
      this.darkBlue = new LightSourceCreator(DawnBringerPalette.DARK_BLUE, radius, this.lightSourceCache);
      this.white = new LightSourceCreator(DawnBringerPalette.WHITE, radius, this.lightSourceCache);
      this.red = new LightSourceCreator(DawnBringerPalette.RED, radius, this.lightSourceCache);
      this.darkRed = new LightSourceCreator(DawnBringerPalette.DARK_RED, radius, this.lightSourceCache);
      this.lightGray = new LightSourceCreator(DawnBringerPalette.LIGHT_GRAY, radius, this.lightSourceCache);
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.lightSourceCache.resetCache();
      this.flickeringLightSourceCache.resetCache();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/sound/SoundEffect.js
  var SoundEffect = class {
    /**
     * 
     * @param {number} volume 
     * @param {Array.<string>} soundPaths 
     */
    constructor(volume, soundPaths) {
      this.volume = volume;
      this.soundPaths = soundPaths;
    }
    getVolume() {
      return this.volume;
    }
    getSoundPaths() {
      return this.soundPaths;
    }
    /**
     * @returns {string}
     */
    getRandomSoundPath() {
      if (!this.soundPaths) {
        return null;
      }
      if (this.soundPaths.length == 0) {
        return null;
      }
      if (this.soundPaths.length == 1) {
        return this.soundPaths[0];
      } else {
        return this.soundPaths[Rand.randomInt(this.soundPaths.length)];
      }
    }
  };

  // src/model/sound/SoundEffects.js
  var SoundEffects = {
    /**
     * @constant
     * @type {SoundEffect}
     */
    buttonClick: new SoundEffect(1, "sound/effects/ui/Snd_click.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    coins: new SoundEffect(
      0.5,
      "sound/effects/coins/handleCoins.mp3",
      "sound/effects/coins/handleCoins2.mp3"
    ),
    /**
     * @constant
     * @type {SoundEffect}
     */
    tab: new SoundEffect(1, "sound/effects/ui/metalLatch.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    minionDeath: new SoundEffect(1, "sound/effects/deathMinion/bite-small.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    travelEffect: new SoundEffect(1, "sound/effects/travelEffect/dropLeather.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    deathBell: new SoundEffect(1, "sound/effects/deathBell/churchbell.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    deathScream: new SoundEffect(
      1,
      "sound/effects/deathScream/death_01.mp3",
      "sound/effects/deathScream/death_02.mp3",
      "sound/effects/deathScream/death_04.mp3",
      "sound/effects/deathScream/death_05.mp3",
      "sound/effects/deathScream/death_06.mp3",
      "sound/effects/deathScream/death_07.mp3"
    ),
    /**
     * @constant
     * @type {SoundEffect}
     */
    resurrection: new SoundEffect(1, "sound/effects/resurrection/JRPG_characterRevived.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    questCompletion: new SoundEffect(1, "sound/effects/questCompleted/Jingle_Achievement_00_128.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    collectibleFound: new SoundEffect(1, "sound/effects/collectibleFound/teleport_02.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    achievement: new SoundEffect(1, "sound/effects/achievement/cursespell.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    partyRankEarned: new SoundEffect(1, "sound/effects/partyRank/retro_beep_04.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    spellBlastEffect: new SoundEffect(
      1,
      "sound/effects/spellBlastArea/sfx_exp_cluster2.mp3",
      "sound/effects/spellBlastArea/sfx_exp_short_hard2.mp3",
      "sound/effects/spellBlastArea/sfx_exp_short_hard3.mp3",
      "sound/effects/spellBlastArea/sfx_exp_short_hard6.mp3",
      "sound/effects/spellBlastArea/sfx_exp_short_hard10.mp3",
      "sound/effects/spellBlastArea/sfx_exp_short_hard12.mp3",
      "sound/effects/spellBlastArea/sfx_exp_short_hard13.mp3",
      "sound/effects/spellBlastArea/missile_explosion.mp3"
    ),
    /**
     * @constant
     * @type {SoundEffect}
     */
    damage: new SoundEffect(
      1,
      "sound/effects/damage/sfx_exp_shortest_hard6.mp3",
      "sound/effects/damage/sfx_exp_shortest_soft1.mp3",
      "sound/effects/damage/sfx_exp_shortest_soft2.mp3",
      "sound/effects/damage/sfx_exp_shortest_soft6.mp3",
      "sound/effects/damage/sfx_exp_shortest_soft7.mp3",
      "sound/effects/damage/sfx_exp_shortest_soft8.mp3",
      "sound/effects/damage/sfx_exp_shortest_soft9.mp3"
    ),
    /**
     * @constant
     * @type {SoundEffect}
     */
    doorOpenEffect: new SoundEffect(
      1,
      "sound/effects/doorOpen/sfx_movement_dooropen1.mp3",
      "sound/effects/doorOpen/doorOpen_1.mp3",
      "sound/effects/doorOpen/doorOpen_2.mp3"
    ),
    /**
     * @constant
     * @type {SoundEffect}
     */
    barrelOpen: new SoundEffect(1, "sound/effects/open/boots-leather-step-01.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    itemDrop: new SoundEffect(1, "sound/effects/itemDrop/water-drop-02.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    potBroken: new SoundEffect(1, "sound/effects/breakPot/wood-bowl-spoon-04.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    sackLooted: new SoundEffect(1, "sound/effects/sackLooted/knife-sheathe-01.mp3"),
    /**
     * @constant
     * @type {SoundEffect}
     */
    chestOpen: new SoundEffect(
      1,
      "sound/effects/chestOpen/match-light-01.mp3",
      "sound/effects/chestOpen/quiver-leather-squeeze-01.mp3"
    ),
    /**
     * @constant
     * @type {SoundEffect}
     */
    fixtureBreak: new SoundEffect(
      1,
      "sound/effects/fixtureBreak/item_wood_02.mp3",
      "sound/effects/fixtureBreak/misc_03.mp3",
      "sound/effects/fixtureBreak/wood_01.mp3",
      "sound/effects/fixtureBreak/wood_04.mp3"
    ),
    /**
     * @constant
     * @type {SoundEffect}
     */
    rareWeaponFound: new SoundEffect(1, "sound/effects/foundRare/levelup.mp3")
  };

  // src/model/sprite/GervaisSpriteNames.js
  var GervaisSpriteNames = {
    ///////////////////////////////////////////////////////
    // Damage Effects
    ///////////////////////////////////////////////////////
    DAMAGE_EFFECT_NAME_RED_SPLAT: "Red Splat",
    DAMAGE_EFFECT_NAME_RED_DAMAGE: "Red Damage",
    DAMAGE_EFFECT_NAME_WHITE_DAMAGE: "White Damage",
    DAMAGE_EFFECT_NAME_BLUE_DAMAGE: "Blue Damage",
    DAMAGE_EFFECT_NAME_GREEN_DAMAGE: "Green Damage",
    DAMAGE_EFFECT_NAME_SHOCK_DAMAGE: "Electric Damage",
    DAMAGE_EFFECT_NAME_FIRE_DAMAGE: "Fire Damage",
    DAMAGE_EFFECT_NAME_POISON_DAMAGE: "Poison Damage",
    DAMAGE_EFFECT_NAME_SONIC_DAMAGE: "Sonic Damage",
    DAMAGE_EFFECT_NAME_PINK_DAMAGE: "Pink Damage",
    ///////////////////////////////////////////////////////
    // Missiles
    ///////////////////////////////////////////////////////
    MISSILE_EFFECT_NAME_ARROW: "Red Arrow",
    MISSILE_EFFECT_NAME_FAT_ARROW: "Fat Red Arrow",
    MISSILE_EFFECT_NAME_GREEN_ARROW: "Green Arrow",
    MISSILE_EFFECT_NAME_PINK_ARROW: "Pink Arrow",
    MISSILE_EFFECT_NAME_ARROW_WALL: "Wall Arrow",
    MISSILE_EFFECT_NAME_SPEAR: "Spear",
    MISSILE_EFFECT_NAME_PINK_LIGHTNING: "Pink Lightning",
    MISSILE_EFFECT_NAME_GREEN_PROJECTILE: "Green Projectile",
    MISSILE_EFFECT_NAME_SMALL_GREEN_PROJECTILE: "Small Green Projectiles",
    MISSILE_EFFECT_NAME_FIRE_PROJECTILE: "Fire Projectile",
    MISSILE_EFFECT_NAME_FIRE_ARROW: "Fire Arrow",
    MISSILE_EFFECT_NAME_ICE_PROJECTILE: "Ice Projectile",
    MISSILE_EFFECT_NAME_ICE_ARROW: "Ice Arrow",
    MISSILE_EFFECT_NAME_LIGHTNING: "Lightning",
    MISSILE_EFFECT_NAME_LIGHTNING_ARROW: "Lightning Arrow",
    MISSILE_EFFECT_NAME_GREY_BULLET: "Grey Bullet",
    MISSILE_EFFECT_NAME_YELLOW_BULLET: "Yellow Bullet",
    MISSILE_EFFECT_NAME_NINJA_STAR: "Ninja Star",
    MISSILE_EFFECT_NAME_WEB: "Web",
    MISSILE_EFFECT_NAME_PINK_STAR_PROJECTILE: "Pink Star Projectile",
    MISSILE_EFFECT_NAME_PINK_BALL_PROJECTILE: "Pink Ball Projectile",
    MISSILE_EFFECT_NAME_YELLOW_STAR_PROJECTILE: "Yellow Star Projectile",
    ///////////////////////////////////////////////////////
    // Spell Effects: SpellFXAnim1
    ///////////////////////////////////////////////////////
    EFFECT_NAME_SPARKLE_GOLD: "Gold Sparkles",
    EFFECT_NAME_SPARKLE_GREEN: "Green Sparkles",
    EFFECT_NAME_SPARKLE_BLUE: "Blue Sparkles",
    EFFECT_NAME_SPARKLE_ORANGE: "Orange Sparkles",
    EFFECT_NAME_SPARKLE_PINK: "Pink Sparkles",
    EFFECT_NAME_SPARKLE_RED: "Red Sparkles",
    EFFECT_NAME_GREEN_SKULL: "Green Skull",
    EFFECT_NAME_YELLOW_KEY: "Yellow Key",
    EFFECT_NAME_SKULL_CROSS: "Skull Cross",
    EFFECT_NAME_SHIELDS: "Shields",
    EFFECT_NAME_RED_CROSSES: "Red Crosses",
    EFFECT_NAME_FIRE_RING: "Fire Ring",
    EFFECT_NAME_ICE_RING: "Ice Ring",
    EFFECT_NAME_GREEN_RING: "Green Ring",
    EFFECT_NAME_PINK_RING: "Pink Ring",
    EFFECT_NAME_YELLOW_STAR: "Yellow Star",
    EFFECT_NAME_BLUE_STAR: "Blue Star",
    EFFECT_NAME_GREEN_STAR: "Green Star",
    EFFECT_NAME_WEB: "Spider Web",
    EFFECT_NAME_WHITE_CROSSES: "White Crosses",
    EFFECT_NAME_TORCH: "Torch",
    ///////////////////////////////////////////////////////
    // Spell Effects: SpellFXAnim2
    ///////////////////////////////////////////////////////
    EFFECT_NAME_FROST: "Frost",
    EFFECT_NAME_YELLOW_STAR_CIRCLE: "Yellow Star Circle",
    EFFECT_NAME_CIRCLES: "Circles",
    EFFECT_NAME_GOLD_SHIELD_SPIRAL: "Gold Shield Spiral",
    EFFECT_NAME_GREEN_SHIELD_SPIRAL: "Green Shield Spiral",
    EFFECT_NAME_BLUE_SHIELD_SPIRAL: "Blue Shield Spiral",
    EFFECT_NAME_PINK_SHIELD_SPIRAL: "Pink Shield Spiral",
    EFFECT_NAME_BLUE_FIREWORK: "Blue Firework",
    EFFECT_NAME_RED_FIREWORK: "Red Firework",
    EFFECT_NAME_BUBBLES: "Bubbles",
    ///////////////////////////////////////////////////////
    // Spell Effects: SpellFXAnim3
    ///////////////////////////////////////////////////////
    EFFECT_NAME_SHIELD: "Shield",
    EFFECT_NAME_COLOR_SPIRAL: "Color Spiral",
    EFFECT_NAME_ARM_FLEX: "Arm Flex",
    EFFECT_NAME_SUPER_SPEED: "Super Speed",
    EFFECT_NAME_TARGET: "Target",
    EFFECT_NAME_YELLOW_SHIELD_SPIRAL: "Yellow Shield Spiral",
    EFFECT_NAME_PINK_STAR_CIRCLE: "Pink Star Circle",
    EFFECT_NAME_BLUE_STAR_CIRCLE: "Blue Star Circle",
    EFFECT_NAME_GREEN_STAR_CIRCLE: "Green Star Circle",
    EFFECT_NAME_GOLD_STAR_CIRCLE: "Gold Star Circle",
    EFFECT_NAME_BREAD: "Bread",
    ///////////////////////////////////////////////////////
    // Spell Effects: SpellFXAnim4
    ///////////////////////////////////////////////////////
    EFFECT_NAME_YELLOW_FIRE_RING: "Yellow Fire Ring",
    EFFECT_NAME_TOTEMS: "Totems",
    EFFECT_NAME_EYE_BLINK: "Eye Blink",
    EFFECT_NAME_PINK_STAR: "Pink Star",
    EFFECT_NAME_ORANGE_STAR: "Orange Star",
    EFFECT_NAME_RED_EYE_BLINK: "Red Eye Blink",
    EFFECT_NAME_EAGLE: "Eagle",
    EFFECT_NAME_SLEEP: "Sleep",
    EFFECT_NAME_ARMOR: "Armor",
    EFFECT_NAME_BLIND_EYE_BLINK: "Blind Eye Blink",
    EFFECT_NAME_FIRE_RAIN: "Fire Rain",
    EFFECT_NAME_BLUE_RAIN: "Blue Rain",
    EFFECT_NAME_GREEN_RAIN: "Green Rain",
    ///////////////////////////////////////////////////////
    // Spell Effects: SpellFXAnim5
    ///////////////////////////////////////////////////////
    EFFECT_NAME_LIGHTNING_RAIN: "Lightning Rain",
    EFFECT_NAME_PINK_RAIN: "Pink Rain",
    EFFECT_NAME_RAINBOW_RAIN: "Rainbow Rain"
  };

  // src/model/effect/SpriteEffect.js
  var SpriteEffect = class extends Effect {
    constructor() {
      super();
      this.spriteAnimation = null;
    }
    /**
     * @param {Character} effectOwner
     * @param {SpriteAnimation} spriteAnimation
     */
    set(effectOwner, spriteAnimation) {
      super.set(effectOwner);
      this.spriteAnimation = spriteAnimation;
    }
    // /**
    //  * @returns {LightSource}
    //  */
    // getLightSource() {
    //     return this.lightSource;
    // }
    /**
     * @returns {number}
     */
    getEffectType() {
      return EffectType.SPRITE_EFFECT;
    }
    // /**
    //  * @returns {Character}
    //  */
    // getEffectOwner() {
    //     return this.effectOwner;
    // }
    /**
     * @override
     * @returns {Sprite}
     */
    getSprite() {
      return this.spriteAnimation.getSpriteAsOf(Date.now(), this.startTime);
    }
    // /**
    //  * @abstract
    //  * @returns {Vector}
    //  */
    // getPosition() {
    //     return null;
    // }
    // /**
    //  * @returns {boolean}
    //  */
    // isEffectStarted() {
    //     return this.effectStatus === EffectStatus.STARTED_NOT_FINISHED;
    // }
    // /**
    //  * @returns {boolean}
    //  */
    // isNotStarted() {
    //     return this.effectStatus === EffectStatus.NOT_STARTED;
    // }
    // /**
    //  * @returns {boolean}
    //  */
    // isEffectFinished() {
    //     return this.effectStatus === EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE
    //             || this.effectStatus === EffectStatus.FINISHED_BUT_IN_USE;
    // }
    // markEffectAsFinishedButInUse() {
    //     // If we are already 'finished and available', don't downgrade to 'finished but in use'
    //     if (this.effectStatus === EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE) {
    //         return;
    //     }
    //     this.effectStatus = EffectStatus.FINISHED_BUT_IN_USE;
    //     // We are done with the light source by this point.
    //     if (this.lightSource != null) {
    //         this.lightSource.reset(true);
    //         this.lightSource = null;
    //     }
    // }
    // /**
    //  * @param {number} frameTimeRatio 
    //  */
    // updateEffectForFrame(frameTimeRatio) {
    //     // If we are done, then cleanup.
    //     if (this.isEffectFinished()) {
    //         //this.removeDynamicLightSourceOnFinish(lightingCalculator);
    //         return;
    //     }
    //     // See if we need to update the light source tile.
    //     // if (this.lightSource) {
    //     //     const tile = this.lightSource.getTile();
    //     //     const position = this.getPosition();
    //     //     if (tile && !tile.contains(position)) {
    //     //         this.lightSource.setTile(tile.getNeighbor(position));
    //     //     }
    //     // }
    //     // See if we are just starting the effect.
    //     if (this.effectStatus === EffectStatus.NOT_STARTED) {
    //         this.startTime = Date.now();
    //         // if (this.lightSource) {
    //         //     lightingCalculator.addDynamicLightSource(this.lightSource);
    //         // }
    //     }
    //     this.effectStatus = EffectStatus.STARTED_NOT_FINISHED;
    //     this.updateEffectForFrameInternal(frameTimeRatio);
    // }
    // /**
    //  * @private
    //  * @param {LightingCalculator} lightingCalculator 
    //  */
    // removeDynamicLightSourceOnFinish(lightingCalculator) {
    //     if (this.isEffectFinished() && this.lightSource != null) {
    //         this.lightSource.reset(true);
    //         lightingCalculator.removeDynamicLightSource(this.lightSource);
    //         this.lightSource = null;
    //     }
    // }
    // /**
    //  * @param {number} frameTimeRatio 
    //  */
    // updateEffectForFrameInternal(frameTimeRatio) {        
    // }
    // /**
    //  * @returns {number}
    //  */
    // getStartTime() {
    //     return this.startTime;
    // }
    // /**
    //  * @returns {number}
    //  */
    // getEffectStatus() {
    //     return this.effectStatus;
    // }
    // /**
    //  * @param {number} frameTime 
    //  */
    // refreshStartTime(frameTime) {
    //     this.startTime = frameTime;
    // }
    /////////////////////////////////////
    // CachedInstance
    /////////////////////////////////////
    // /**
    //  * @override
    //  */
    // isFinishedAndAvailable() {
    //     return this.effectStatus == EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE;
    // }
    // /**
    //  * @override
    //  * @param {boolean} finishedAndAvailable 
    //  */
    // reset(finishedAndAvailable) {
    //     const currentlyFinished = this.effectStatus == EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE;
    //     if (currentlyFinished != finishedAndAvailable) {
    //         // if (this.lightSource != null) {
    //         //     // End the light source by resetting it.
    //         //     this.lightSource.reset(true);
    //         //     this.lightSource = null;
    //         // }
    //         if (finishedAndAvailable) {
    //             this.spriteAnimation = null;
    //         }
    //         this.effectStatus = finishedAndAvailable ? EffectStatus.FINISHED_AND_AVAILABLE_FOR_CACHE : EffectStatus.NOT_STARTED;
    //         this.startTime = 0;
    //         this.listener.onAvailabilityChanged(finishedAndAvailable);
    //     }
    // }
  };

  // src/model/effect/BasicSpriteEffect.js
  var BasicSpriteEffect = class extends SpriteEffect {
    constructor() {
      super();
      this.effectPosition = new Vector(0, 0);
    }
    /**
     * @param {Character} effectOwner
     * @param {SpriteAnimation} spriteAnimation
     * @param {Vector} effectPosition 
     */
    set(effectOwner, spriteAnimation, effectPosition) {
      super.set(effectOwner, spriteAnimation);
      this.effectPosition.copy(effectPosition);
    }
    /**
     * @override
     * @param {number} frameTimeRatio 
     */
    updateEffectForFrameInternal(frameTimeRatio) {
      const animationLoopCompleted = this.spriteAnimation.isAnimationLoopCompleted(this.getStartTime());
      if (animationLoopCompleted && !this.isFinishedAndAvailable()) {
        this.markEffectAsFinishedButInUse();
      }
    }
    /**
     * @override
     * @returns {Vector}
     */
    getPosition() {
      return this.effectPosition;
    }
  };

  // src/model/effect/EffectCache.js
  var EffectCache = class extends CyclingCache {
    constructor() {
      super();
      this.initialCacheSize = 20;
      this.growAmount = 10;
    }
    /**
     * @override
     * @returns {number}
     */
    getGrowAmount() {
      return this.growAmount;
    }
    /**
     * @override
     * @returns {number}
     */
    getInitialSize() {
      return this.initialCacheSize;
    }
  };

  // src/model/effect/BasicSpriteEffectCache.js
  var BasicSpriteEffectCache = class extends EffectCache {
    constructor() {
      super();
    }
    /**
     * @override
     * @returns {BasicSpriteEffect}
     */
    createInstance() {
      return new BasicSpriteEffect();
    }
  };

  // src/model/effect/BasicSpriteEffectCreator.js
  var BasicSpriteEffectCreator = class extends EffectCreator {
    /**
     * 
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet
     * @param {string} spriteName
     * @param {SoundEffect} soundEffect
     * @param {LightSourceCreator} lightSourceCreator
     * @param {BasicSpriteEffectCache} basicSpriteEffectCache
     */
    constructor(spellFxSpritesheet, spriteName, soundEffect, lightSourceCreator, basicSpriteEffectCache) {
      super();
      this.spellFxSpritesheet = spellFxSpritesheet;
      this.spriteName = spriteName;
      this.spriteAnimation = null;
      this.soundEffect = soundEffect;
      this.lightSourceCreator = lightSourceCreator;
      this.basicSpriteEffectCache = basicSpriteEffectCache;
    }
    /**
     * @override
     * @param {Character} effectOwner 
     * @param {Vector} effectPosition 
     * @returns {Effect}
     */
    createEffect(effectOwner, effectPosition) {
      if (!this.spriteAnimation && this.spellFxSpritesheet) {
        this.spriteAnimation = this.spellFxSpritesheet.getSpriteAnimation(this.spriteName);
      }
      const effect = this.basicSpriteEffectCache.get();
      effect.set(effectOwner, this.spriteAnimation, effectPosition);
      return effect;
    }
    /**
     * @override
     * @param {Character} effectOwner 
     * @param {GridTile} tile
     * @returns {Effect}
     */
    createEffectAtTile(effectOwner, tile) {
      if (!this.spriteAnimation && this.spellFxSpritesheet) {
        this.spriteAnimation = this.spellFxSpritesheet.getSpriteAnimation(this.spriteName);
      }
      const effect = this.basicSpriteEffectCache.get();
      effect.set(effectOwner, this.spriteAnimation, tile.origin);
      return effect;
    }
    /**
     * @override
     * @param {Character} effectOwner 
     * @param {Vector} position The origin position (top left)
     * @returns {Effect}
     */
    createEffectAtPosition(effectOwner, position) {
      if (!this.spriteAnimation && this.spellFxSpritesheet) {
        this.spriteAnimation = this.spellFxSpritesheet.getSpriteAnimation(this.spriteName);
      }
      const effect = this.basicSpriteEffectCache.get();
      effect.set(effectOwner, this.spriteAnimation, position);
      return effect;
    }
    // /**
    //  * @private
    //  * @param {Character} effectOwner 
    //  * @param {Vector} effectPosition 
    //  * @returns {GridTile}
    //  */
    // findLightSourceTile(effectOwner, effectPosition) {
    //     return effectOwner.position.tile.getNeighbor(effectPosition);
    // }
    /**
     * @override
     * @returns {SpriteAnimation}
     */
    getSpriteAnimation() {
      return this.spriteAnimation;
    }
  };

  // src/model/effect/EffectCreators.js
  var EffectCreators = class extends GameModel {
    /**
     * @param {LightSourceCreators} lightSourceCreators 
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet
     */
    constructor(lightSourceCreators, spellFxSpritesheet) {
      super();
      this.basicSpriteEffectCache = new BasicSpriteEffectCache();
      this.effectGreenSkull = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_GREEN_SKULL,
        SoundEffects.damage,
        lightSourceCreators.darkGreenFlickering,
        this.basicSpriteEffectCache
      );
      this.damageEffectBloodSplatter = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.DAMAGE_EFFECT_NAME_RED_SPLAT,
        SoundEffects.damage,
        null,
        this.basicSpriteEffectCache
      );
      this.damageEffectRedDamage = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.DAMAGE_EFFECT_NAME_RED_DAMAGE,
        SoundEffects.damage,
        lightSourceCreators.red,
        this.basicSpriteEffectCache
      );
      this.damageEffectWhiteDamage = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.DAMAGE_EFFECT_NAME_WHITE_DAMAGE,
        SoundEffects.damage,
        lightSourceCreators.white,
        this.basicSpriteEffectCache
      );
      this.damageEffectBlueDamage = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.DAMAGE_EFFECT_NAME_BLUE_DAMAGE,
        SoundEffects.damage,
        lightSourceCreators.darkBlue,
        this.basicSpriteEffectCache
      );
      this.damageEffectGreenDamage = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.DAMAGE_EFFECT_NAME_GREEN_DAMAGE,
        SoundEffects.damage,
        lightSourceCreators.lightGreen,
        this.basicSpriteEffectCache
      );
      this.damageEffectShockDamage = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.DAMAGE_EFFECT_NAME_SHOCK_DAMAGE,
        SoundEffects.damage,
        lightSourceCreators.lightBlueFlickering,
        this.basicSpriteEffectCache
      );
      this.damageEffectFireDamage = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.DAMAGE_EFFECT_NAME_FIRE_DAMAGE,
        SoundEffects.damage,
        lightSourceCreators.orange,
        this.basicSpriteEffectCache
      );
      this.damageEffectPoisonDamage = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.DAMAGE_EFFECT_NAME_POISON_DAMAGE,
        SoundEffects.damage,
        lightSourceCreators.darkGreen,
        this.basicSpriteEffectCache
      );
      this.damageEffectSonicDamage = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.DAMAGE_EFFECT_NAME_SONIC_DAMAGE,
        SoundEffects.damage,
        lightSourceCreators.peach,
        this.basicSpriteEffectCache
      );
      this.damageEffectPinkDamage = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.DAMAGE_EFFECT_NAME_PINK_DAMAGE,
        SoundEffects.damage,
        null,
        this.basicSpriteEffectCache
      );
      this.effectSparkleGold = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SPARKLE_GOLD,
        SoundEffects.damage,
        lightSourceCreators.yellowFlickering,
        this.basicSpriteEffectCache
      );
      this.effectSparkleGreen = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SPARKLE_GREEN,
        SoundEffects.damage,
        lightSourceCreators.darkGreenFlickering,
        this.basicSpriteEffectCache
      );
      this.effectSparkleBlue = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SPARKLE_BLUE,
        SoundEffects.damage,
        lightSourceCreators.lightBlueFlickering,
        this.basicSpriteEffectCache
      );
      this.effectSparklePink = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SPARKLE_PINK,
        SoundEffects.damage,
        lightSourceCreators.peachFlickering,
        this.basicSpriteEffectCache
      );
      this.effectSparkleOrange = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SPARKLE_ORANGE,
        SoundEffects.damage,
        lightSourceCreators.redFlickering,
        this.basicSpriteEffectCache
      );
      this.effectSparkleRed = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SPARKLE_RED,
        SoundEffects.damage,
        null,
        this.basicSpriteEffectCache
      );
      this.effectGreenSkull = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_GREEN_SKULL,
        SoundEffects.damage,
        lightSourceCreators.darkGreenFlickering,
        this.basicSpriteEffectCache
      );
      this.effectYellowKey = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_YELLOW_KEY,
        SoundEffects.damage,
        lightSourceCreators.peachFlickering,
        this.basicSpriteEffectCache
      );
      this.effectSkullCross = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SKULL_CROSS,
        SoundEffects.damage,
        lightSourceCreators.darkRed,
        this.basicSpriteEffectCache
      );
      this.effectShields = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SHIELDS,
        SoundEffects.damage,
        lightSourceCreators.darkBlue,
        this.basicSpriteEffectCache
      );
      this.effectRedCrosses = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_RED_CROSSES,
        SoundEffects.damage,
        lightSourceCreators.yellow,
        this.basicSpriteEffectCache
      );
      this.effectFireRing = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_FIRE_RING,
        SoundEffects.damage,
        lightSourceCreators.orange,
        this.basicSpriteEffectCache
      );
      this.effectIceRing = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_ICE_RING,
        SoundEffects.damage,
        lightSourceCreators.lightBlue,
        this.basicSpriteEffectCache
      );
      this.effectGreenRing = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_GREEN_RING,
        SoundEffects.damage,
        lightSourceCreators.lightGreen,
        this.basicSpriteEffectCache
      );
      this.effectPinkRing = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_PINK_RING,
        SoundEffects.damage,
        lightSourceCreators.peach,
        this.basicSpriteEffectCache
      );
      this.effectYellowStar = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_YELLOW_STAR,
        SoundEffects.damage,
        null,
        this.basicSpriteEffectCache
      );
      this.effectBlueStar = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_BLUE_STAR,
        SoundEffects.damage,
        lightSourceCreators.lightBlueFlickering,
        this.basicSpriteEffectCache
      );
      this.effectGreenStar = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_GREEN_STAR,
        SoundEffects.damage,
        lightSourceCreators.lightGreenFlickering,
        this.basicSpriteEffectCache
      );
      this.effectWhiteCrosses = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_WHITE_CROSSES,
        SoundEffects.damage,
        lightSourceCreators.cyan,
        this.basicSpriteEffectCache
      );
      this.effectWeb = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_WEB,
        SoundEffects.damage,
        null,
        this.basicSpriteEffectCache
      );
      this.effectTorch = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_TORCH,
        SoundEffects.damage,
        lightSourceCreators.orange,
        this.basicSpriteEffectCache
      );
      this.effectFrost = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_FROST,
        SoundEffects.damage,
        lightSourceCreators.white,
        this.basicSpriteEffectCache
      );
      this.effectYellowStarCircle = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_YELLOW_STAR_CIRCLE,
        SoundEffects.damage,
        null,
        this.basicSpriteEffectCache
      );
      this.effectCircles = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_CIRCLES,
        SoundEffects.damage,
        lightSourceCreators.peach,
        this.basicSpriteEffectCache
      );
      this.effectGoldShieldSpiral = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_GOLD_SHIELD_SPIRAL,
        SoundEffects.damage,
        lightSourceCreators.yellow,
        this.basicSpriteEffectCache
      );
      this.effectGreenShieldSpiral = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_GREEN_SHIELD_SPIRAL,
        SoundEffects.damage,
        lightSourceCreators.lightGreen,
        this.basicSpriteEffectCache
      );
      this.effectBlueShieldSpiral = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_BLUE_SHIELD_SPIRAL,
        null,
        lightSourceCreators.lightBlue,
        this.basicSpriteEffectCache
      );
      this.effectPinkShieldSpiral = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_PINK_SHIELD_SPIRAL,
        SoundEffects.damage,
        lightSourceCreators.peach,
        this.basicSpriteEffectCache
      );
      this.effectBlueFirework = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_BLUE_FIREWORK,
        SoundEffects.damage,
        lightSourceCreators.lightBlue,
        this.basicSpriteEffectCache
      );
      this.effectRedFirework = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_RED_FIREWORK,
        SoundEffects.damage,
        lightSourceCreators.red,
        this.basicSpriteEffectCache
      );
      this.effectStun = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_BUBBLES,
        SoundEffects.damage,
        lightSourceCreators.peachFlickering,
        this.basicSpriteEffectCache
      );
      this.effectShield = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SHIELD,
        SoundEffects.damage,
        lightSourceCreators.lightGray,
        this.basicSpriteEffectCache
      );
      this.colorSpiralEffect = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_COLOR_SPIRAL,
        SoundEffects.damage,
        lightSourceCreators.white,
        this.basicSpriteEffectCache
      );
      this.effectArmFlex = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_ARM_FLEX,
        SoundEffects.damage,
        lightSourceCreators.lightBlue,
        this.basicSpriteEffectCache
      );
      this.effectSuperSpeed = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SUPER_SPEED,
        SoundEffects.damage,
        lightSourceCreators.yellow,
        this.basicSpriteEffectCache
      );
      this.effectTarget = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_TARGET,
        SoundEffects.damage,
        lightSourceCreators.red,
        this.basicSpriteEffectCache
      );
      this.effectYellowShieldSpiral = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_YELLOW_SHIELD_SPIRAL,
        SoundEffects.damage,
        lightSourceCreators.yellow,
        this.basicSpriteEffectCache
      );
      this.effectPinkStarCircle = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_PINK_STAR_CIRCLE,
        SoundEffects.damage,
        lightSourceCreators.peach,
        this.basicSpriteEffectCache
      );
      this.effectBlueStarCircle = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_BLUE_STAR_CIRCLE,
        SoundEffects.damage,
        lightSourceCreators.lightBlue,
        this.basicSpriteEffectCache
      );
      this.effectGreenStarCircle = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_GREEN_STAR_CIRCLE,
        SoundEffects.damage,
        lightSourceCreators.lightGreen,
        this.basicSpriteEffectCache
      );
      this.effectGoldStarCircle = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_GOLD_STAR_CIRCLE,
        SoundEffects.damage,
        lightSourceCreators.yellow,
        this.basicSpriteEffectCache
      );
      this.effectBread = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_BREAD,
        SoundEffects.damage,
        lightSourceCreators.peach,
        this.basicSpriteEffectCache
      );
      this.effectYellowFireFing = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_YELLOW_FIRE_RING,
        SoundEffects.damage,
        lightSourceCreators.yellow,
        this.basicSpriteEffectCache
      );
      this.effectTotems = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_TOTEMS,
        SoundEffects.damage,
        lightSourceCreators.peach,
        this.basicSpriteEffectCache
      );
      this.effectEyeBlink = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_EYE_BLINK,
        SoundEffects.damage,
        lightSourceCreators.orange,
        this.basicSpriteEffectCache
      );
      this.effectPinkStar = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_PINK_STAR,
        SoundEffects.damage,
        lightSourceCreators.peachFlickering,
        this.basicSpriteEffectCache
      );
      this.effectOrangeStar = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_ORANGE_STAR,
        SoundEffects.damage,
        lightSourceCreators.yellowFlickering,
        this.basicSpriteEffectCache
      );
      this.effectRedEyeBlink = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_RED_EYE_BLINK,
        SoundEffects.damage,
        lightSourceCreators.red,
        this.basicSpriteEffectCache
      );
      this.effectEagle = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_EAGLE,
        SoundEffects.damage,
        lightSourceCreators.lightBlue,
        this.basicSpriteEffectCache
      );
      this.effectSleep = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_SLEEP,
        null,
        lightSourceCreators.orange,
        this.basicSpriteEffectCache
      );
      this.effectArmor = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_ARMOR,
        SoundEffects.damage,
        lightSourceCreators.red,
        this.basicSpriteEffectCache
      );
      this.effectBlindEyeBlink = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_BLIND_EYE_BLINK,
        SoundEffects.damage,
        lightSourceCreators.lightBlue,
        this.basicSpriteEffectCache
      );
      this.effectFireRain = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_FIRE_RAIN,
        SoundEffects.damage,
        lightSourceCreators.yellowFlickering,
        this.basicSpriteEffectCache
      );
      this.effectBlueRain = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_BLUE_RAIN,
        SoundEffects.damage,
        lightSourceCreators.lightBlueFlickering,
        this.basicSpriteEffectCache
      );
      this.effectGreenRain = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_GREEN_RAIN,
        SoundEffects.damage,
        lightSourceCreators.lightGreenFlickering,
        this.basicSpriteEffectCache
      );
      this.effectLightningRain = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_LIGHTNING_RAIN,
        SoundEffects.damage,
        lightSourceCreators.yellowFlickering,
        this.basicSpriteEffectCache
      );
      this.effectPinkRain = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_PINK_RAIN,
        SoundEffects.damage,
        lightSourceCreators.peachFlickering,
        this.basicSpriteEffectCache
      );
      this.effectRainbowRain = new BasicSpriteEffectCreator(
        spellFxSpritesheet,
        GervaisSpriteNames.EFFECT_NAME_RAINBOW_RAIN,
        SoundEffects.damage,
        lightSourceCreators.yellowFlickering,
        this.basicSpriteEffectCache
      );
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.basicSpriteEffectCache.resetCache();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/effect/EffectManager.js
  var EffectManager = class extends GameModel {
    /**
     * @param {Projection} projection 
     */
    constructor(projection) {
      super();
      this.projection = projection;
      this.spriteEffects = [];
    }
    /**
     * @private
     * @param {Array.<Effect>} effectList 
     */
    resetEffectList(effectList) {
      if (effectList.length > 0) {
        for (let i = 0; i < effectList.length; i++) {
          effectList[i].reset(true);
        }
        effectList.length = 0;
      }
    }
    // updateEffectsForTurn() {
    //     if (this.areaEffects.length === 0) {
    //         return;
    //     }
    //     // // Apply physics to the area surrounding the visible part of the world.
    //     // const nearbyRadius = Settings.grid.regionPixelWidth + (this.projection.visibleHalfWidthWorld + this.projection.visibleHalfHeightWorld) / 2;
    //     // GridInversionOfControl.allNearbyRegions(this.worldGrid, this.projection, this.processAreaEffectsRegionCallback, 
    //     //     this.projection.gridCenter, nearbyRadius);
    // }
    /**
     * @param {number} frameTimeRatio 
     */
    updateEffectsForFrame(frameTimeRatio) {
      this.updateEffectListForFrame(this.spriteEffects, frameTimeRatio, true);
    }
    /**
     * @param {Array.<Effect>} effectList
     * @param {number} frameTimeRatio
     * @param {boolean} resetFinishedEffects
     * @returns {boolean} True if an effect was removed.
     */
    updateEffectListForFrame(effectList, frameTimeRatio, resetFinishedEffects) {
      let removed = false;
      for (let i = effectList.length - 1; i >= 0; i--) {
        const effect = effectList[i];
        if (!effect || effect.isFinishedAndAvailable()) {
          effectList.splice(i, 1);
          removed = true;
          continue;
        }
        effect.updateEffectForFrame(frameTimeRatio);
        if (effect.isEffectFinished()) {
          if (resetFinishedEffects && !effect.isFinishedAndAvailable()) {
            effect.reset(true);
          }
          effectList.splice(i, 1);
          removed = true;
        }
      }
      return removed;
    }
    /**
     * @param {Effect} effect
     */
    addEffect(effect) {
      this.addEffectWithSoundFlag(effect, true);
    }
    /**
     * @param {Effect} effect
     * @param {boolean} soundEnabled
     */
    addEffectWithSoundFlag(effect, soundEnabled) {
      if (!effect || effect.isFinishedAndAvailable()) {
        return;
      }
      let effectList = this.spriteEffects;
      effectList.push(effect);
    }
    // resetModel() {
    //     this.resetEffectManager();       
    // }
    resetEffectManager() {
      this.resetEffectList(this.spriteEffects);
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.resetEffectManager();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetEffectManager();
    }
  };

  // src/model/info/InfoText.js
  var InfoText = class extends CachedInstance {
    constructor() {
      super();
      this.text = "";
      this.textX = 0;
      this.textY = 0;
      this.frameCount = 0;
      this.incrementX = 0;
      this.incrementY = 0;
      this.frameToggle = false;
    }
    /**
     * @param {string} text 
     */
    set(text) {
      this.text = text;
      this.incrementX = this.calculateTextMotion();
      this.incrementY = 1 + (Math.random() > 0.5 ? 1 : 0);
      this.frameToggle = true;
      this.frameCount = 0;
    }
    // /**
    //  * @param {string} text 
    //  * @param {Color} textColor 
    //  */
    // set(text, textColor) {
    //     this.text = text;
    //     this.textColor = textColor;
    //     this.incrementX = this.calculateTextMotion();
    //     this.incrementY = -1 - (Math.random() > 0.5 ? 1 : 0);
    //     this.frameToggle = true;
    //     this.frameCount = 0;
    // }
    calculateTextMotion() {
      const motion = 1 + (Math.random() > 0.5 ? 1 : 0);
      if (Math.random() < 0.5) {
        return -motion;
      } else {
        return motion;
      }
    }
    /**
     * @returns {boolean}
     */
    isTextFinished() {
      return this.frameCount >= Settings.text.textFrameDuration;
    }
    /**
     * @param {number} frameTimeRatio The number of frames passed.
     * @return {boolean} true if the text is finished.
     */
    updateTextForFrame(frameTimeRatio) {
      if (this.frameToggle) {
        if (Math.random() < 0.5) {
          this.textX += this.incrementX;
        }
        this.textY -= this.incrementY;
      }
      this.frameToggle = !this.frameToggle;
      this.frameCount += frameTimeRatio;
      return this.textY <= 0 || this.isTextFinished();
    }
  };

  // src/model/info/InfoTextCache.js
  var InfoTextCache = class extends CyclingCache {
    constructor() {
      super();
    }
    /**
     * @override
     * @returns {number}
     */
    getGrowAmount() {
      return 10;
    }
    /**
     * @override
     * @returns {number}
     */
    getInitialSize() {
      return 10;
    }
    /**
     * @returns {InfoText}
     */
    createInstance() {
      return new InfoText();
    }
  };

  // src/model/info/InfoTextProcessor.js
  var InfoTextProcessor = class extends GameModel {
    /**
     * @param {Projection} projection 
     */
    constructor(projection) {
      super();
      this.projection = projection;
      this.infoTextCache = new InfoTextCache();
      this.infoTextArray = [];
      this.workingVector = new Vector();
    }
    /**
     * @param {GridTile} tile 
     * @param {BigNum} ore 
     */
    addOreText(tile, ore) {
      if (!this.projection.isVisibleGridBox(tile)) {
        return;
      }
      const text = NumberFormatter.formatBigNum(ore);
      this.addCurrencyInternal(tile, text);
    }
    /**
     * @param {GridTile} tile 
     * @param {BigNum} gold 
     */
    addGoldText(tile, gold) {
      if (!this.projection.isVisibleGridBox(tile)) {
        return;
      }
      const text = NumberFormatter.formatBigNum(gold) + " Gold!";
      this.addCurrencyInternal(tile, text);
    }
    /**
     * @param {GridTile} tile 
     * @param {BigNum} ruby 
     */
    addRubyText(tile, ruby) {
      if (!this.projection.isVisibleGridBox(tile)) {
        return;
      }
      const text = NumberFormatter.formatBigNum(ruby) + " Ruby!";
      this.addCurrencyInternal(tile, text);
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @param {string} text 
     */
    addCurrencyInternal(tile, text) {
      if (!this.projection.isVisibleGridBox(tile)) {
        return;
      }
      while (this.infoTextArray.length >= Settings.text.maxInfoTextCount) {
        this.infoTextArray[0].reset(true);
        this.infoTextArray.splice(0, 1);
      }
      const infoText = this.infoTextCache.get();
      infoText.set(text);
      this.setTextPosition(infoText, tile.origin);
      this.infoTextArray.push(infoText);
    }
    /**
     * @private
     * @param {InfoText} infoText 
     * @param {Vector} position 
     */
    setTextPosition(infoText, position) {
      this.projection.worldToScreen(position, this.workingVector);
      infoText.textX = this.workingVector.x + Settings.tile.halfSize;
      infoText.textY = this.workingVector.y;
    }
    /**
     * @param {number} frameTimeRatio 
     */
    updateTextForFrame(frameTimeRatio) {
      for (let i = this.infoTextArray.length - 1; i >= 0; i--) {
        const infoText = this.infoTextArray[i];
        if (infoText.updateTextForFrame(frameTimeRatio)) {
          infoText.reset(true);
          this.infoTextArray.splice(i, 1);
        }
      }
    }
    clearInfoText() {
      if (this.infoTextArray.length > 0) {
        this.resetInfoTextList(this.infoTextArray);
        this.infoTextArray.length = 0;
      }
    }
    /**
     * @private
     * @param {Array.<InfoText>} infoTextList 
     */
    resetInfoTextList(infoTextList) {
      for (let i = 0; i < infoTextList.length; i++) {
        infoTextList[i].reset(true);
      }
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.infoTextArray.length = 0;
      this.infoTextCache.resetCache();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/statistics/Statistics.js
  var Statistics = class extends GameModel {
    constructor() {
      super();
      this.totalOre = new BigNum(0);
      this.totalGold = new BigNum(0);
      this.totalRuby = new BigNum(0);
      this.totalPrestigePoints = new BigNum(0);
      this.maxDepth = 0;
      this.upgradeOre = new BigNum(0);
      this.totalTurns = 0;
      this.tilesMined = new BigNum(0);
      this.tilesMinedCommon = new BigNum(0);
      this.tilesMinedOre = new BigNum(0);
      this.tilesMinedGold = new BigNum(0);
      this.tilesMinedRuby = new BigNum(0);
      this.tilesMinedUpgrade = new BigNum(0);
      this.tilesMinedLaser = new BigNum(0);
      this.tilesMinedDrill = new BigNum(0);
      this.tilesMinedOrbit = new BigNum(0);
      this.tilesMinedFissure = new BigNum(0);
      this.tilesMinedLightning = new BigNum(0);
      this.tilesMinedMissile = new BigNum(0);
      this.one = new BigNum(1);
    }
    /**
     * @param {number} depth 
     */
    tileDepth(depth) {
      if (depth > this.maxDepth) {
        this.maxDepth = depth;
      }
    }
    /**
     * @param {GridTile} tile 
     */
    onTileMined(tile) {
      this.tilesMined.add(this.one);
      const tileTypeRarity = tile.tileType.rarityModifier;
      switch (tileTypeRarity) {
        case TileTypeRarity.COMMON:
          this.tilesMinedCommon.add(this.one);
          break;
        case TileTypeRarity.ORE:
          this.tilesMinedOre.add(this.one);
          break;
        case TileTypeRarity.GOLD:
          this.tilesMinedGold.add(this.one);
          break;
        case TileTypeRarity.RUBY:
          this.tilesMinedRuby.add(this.one);
          break;
        case TileTypeRarity.UPGRADE:
          this.tilesMinedUpgrade.add(this.one);
          break;
      }
    }
    /**
     * @param {number} turns 
     */
    incrementTurns(turns) {
      this.totalTurns += turns;
    }
    /**
     * @param {BigNum} ore 
     */
    incrementOre(ore) {
      this.totalOre.add(ore);
    }
    /**
     * @param {BigNum} ore 
     */
    incrementUpgradeOre(ore) {
      this.upgradeOre.add(ore);
    }
    /**
     * @param {BigNum} gold 
     */
    incrementGold(gold) {
      this.totalGold.add(gold);
    }
    /**
     * @param {BigNum} ruby 
     */
    incrementRuby(ruby) {
      this.totalRuby.add(ruby);
    }
    /**
     * @param {BigNum} prestigePoints 
     */
    incrementPrestigePoints(prestigePoints) {
      this.totalPrestigePoints.add(prestigePoints);
    }
    incrementMinedByLaser() {
      this.tilesMinedLaser.add(this.one);
    }
    incrementMinedByDrill() {
      this.tilesMinedDrill.add(this.one);
    }
    incrementMinedByOrbit() {
      this.tilesMinedOrbit.add(this.one);
    }
    incrementMinedByFissure() {
      this.tilesMinedFissure.add(this.one);
    }
    incrementMinedByLightning() {
      this.tilesMinedLightning.add(this.one);
    }
    incrementMinedByMissile() {
      this.tilesMinedMissile.add(this.one);
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.totalOre.setZero();
      this.totalGold.setZero();
      this.totalRuby.setZero();
      this.totalPrestigePoints.setZero();
      this.upgradeOre.setZero();
      this.maxDepth = 0;
      this.totalTurns = 0;
      this.tilesMined.setZero();
      this.tilesMinedCommon.setZero();
      this.tilesMinedOre.setZero();
      this.tilesMinedGold.setZero();
      this.tilesMinedRuby.setZero();
      this.tilesMinedUpgrade.setZero();
      this.tilesMinedLaser.setZero();
      this.tilesMinedDrill.setZero();
      this.tilesMinedOrbit.setZero();
      this.tilesMinedFissure.setZero();
      this.tilesMinedLightning.setZero();
      this.tilesMinedMissile.setZero();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/statistics/StatisticsIncrementor.js
  var StatisticsIncrementor = class {
    /**
     * @param {Statistics} globalStatitics 
     * @param {Statistics} runStatistics 
     */
    constructor(globalStatitics, runStatistics) {
      this.globalStatitics = globalStatitics;
      this.runStatistics = runStatistics;
    }
    /**
     * @param {number} turns 
     */
    incrementTurns(turns) {
      this.globalStatitics.incrementTurns(turns);
      this.runStatistics.incrementTurns(turns);
    }
    /**
     * @param {number} depth 
     */
    tileDepth(depth) {
      this.globalStatitics.tileDepth(depth);
      this.runStatistics.tileDepth(depth);
    }
    /**
     * @param {GridTile} tile 
     */
    onTileMined(tile) {
      this.globalStatitics.onTileMined(tile);
      this.runStatistics.onTileMined(tile);
    }
    /**
     * @param {BigNum} ore 
     */
    incrementOre(ore) {
      this.globalStatitics.incrementOre(ore);
      this.runStatistics.incrementOre(ore);
    }
    /**
     * @param {BigNum} ore 
     */
    incrementUpgradeOre(ore) {
      this.globalStatitics.incrementUpgradeOre(ore);
      this.runStatistics.incrementUpgradeOre(ore);
    }
    /**
     * @param {BigNum} gold 
     */
    incrementGold(gold) {
      this.globalStatitics.incrementGold(gold);
      this.runStatistics.incrementGold(gold);
    }
    /**
     * @param {BigNum} ruby 
     */
    incrementRuby(ruby) {
      this.globalStatitics.incrementRuby(ruby);
      this.runStatistics.incrementRuby(ruby);
    }
    /**
     * @param {BigNum} prestigePoints 
     */
    incrementPrestigePoints(prestigePoints) {
      this.globalStatitics.incrementPrestigePoints(prestigePoints);
      this.runStatistics.incrementPrestigePoints(prestigePoints);
    }
    incrementMinedByLaser() {
      this.globalStatitics.incrementMinedByLaser();
      this.runStatistics.incrementMinedByLaser();
    }
    incrementMinedByDrill() {
      this.globalStatitics.incrementMinedByDrill();
      this.runStatistics.incrementMinedByDrill();
    }
    incrementMinedByOrbit() {
      this.globalStatitics.incrementMinedByOrbit();
      this.runStatistics.incrementMinedByOrbit();
    }
    incrementMinedByFissure() {
      this.globalStatitics.incrementMinedByFissure();
      this.runStatistics.incrementMinedByFissure();
    }
    incrementMinedByLightning() {
      this.globalStatitics.incrementMinedByLightning();
      this.runStatistics.incrementMinedByLightning();
    }
    incrementMinedByMissile() {
      this.globalStatitics.incrementMinedByMissile();
      this.runStatistics.incrementMinedByMissile();
    }
  };

  // src/model/upgrade/Upgrade.js
  var Upgrade = class {
    /**
     * @abstract
     * @param {string} title
     * @param {string} iconFileName
     */
    constructor(title, iconFileName) {
      this.title = title;
      this.iconFileName = iconFileName;
      this.purchasedCount = 0;
    }
    /**
     * Optional. Return null if there is none.
     * @returns {string}
     */
    getDescription() {
      return null;
    }
    /**
     * @returns {boolean}
     */
    isPurchasable() {
      return this.isAffordable();
    }
    /**
     * @returns {boolean}
     */
    isAffordable() {
      return false;
    }
    /**
     * @abstract
     * @returns {BigNum}
     */
    getCost() {
      return null;
    }
    /**
     * @abstract
     * @returns {string} See UpgradeCostUnit
     */
    getCostUnit() {
      return null;
    }
    /**
     * @returns {number}
     */
    getPurchasedCount() {
      return this.purchasedCount;
    }
    /**
     * @param {number} purchasedCount 
     */
    setPurchasedCount(purchasedCount) {
      this.purchasedCount = purchasedCount;
    }
    /**
     * @param {number} purchasedCount The number of upgrade purchases that have been made. 
     */
    setPurchasedCountFromSave(purchasedCount) {
      this.setPurchasedCount(purchasedCount);
    }
    /**
     * @abstract
     * @returns {boolean} true if the purchase was made.
     */
    purchase() {
      return false;
    }
    /**
     * @override
     */
    resetUpgrade() {
      this.purchasedCount = 0;
    }
  };

  // src/model/upgrade/UpgradeCollection.js
  var UpgradeCollection = class extends GameModel {
    constructor() {
      super();
      this.upgrades = [];
      this.changeCount = 0;
    }
    /**
     * @param {Upgrade} upgrade 
     */
    add(upgrade) {
      if (!upgrade) {
        console.log("UpgradeCollection.add() null upgrade");
        return;
      }
      this.upgrades.push(upgrade);
      this.changeCount++;
    }
    /**
     * Used for when adding lots of upgrades and we don't want to sort every single time.
     * @param {Upgrade} upgrade 
     */
    addBulk(upgrade) {
      if (!upgrade) {
        console.log("UpgradeCollection.addBulk() null upgrade");
        return;
      }
      this.upgrades.push(upgrade);
    }
    addBulkCompleted() {
      this.changeCount++;
    }
    /**
     * @param {Upgrade} upgrade 
     */
    remove(upgrade) {
      if (!upgrade) {
        console.log("UpgradeCollection.remove() upgrade null");
        return;
      }
      const index = this.upgrades.indexOf(upgrade);
      if (index === -1) {
        console.log("UpgradeCollection.remove() did not find upgrade in list");
        return;
      }
      this.upgrades.splice(index, 1);
      this.changeCount++;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.upgrades.length = 0;
      this.changeCount = 0;
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/logic/MineDamageLogic.js
  var MineDamageLogic = class {
    /**
     * @param {Values} values
     * @param {Totals} totals
     * @param {Damage} damage
     * @param {Statistics} globalStatistics
     */
    constructor(values, totals, damage, globalStatistics) {
      this.values = values;
      this.totals = totals;
      this.damage = damage;
      this.globalStatistics = globalStatistics;
      this.workingMineDamage = new BigNum(0);
      this.minedDamageBonus = new BigNum(0);
      this.prestigeBonus = new BigNum(0);
      this.prestigeMultiplier = new BigNum(Settings.prestige.multiplierPerPrestige);
      this.rubyMultiplier = new BigNum(Settings.ruby.multiplierPerRuby);
      this.rubyBonus = new BigNum(0);
      this.blockMultiplier = new BigNum(Settings.blocks.multiplierPerBlock);
      this.blockBonus = new BigNum(0);
      this.workingDepthDamageMultiplier = new BigNum(0);
      this.workingMultiBonus = new BigNum(0);
      this.workingPrestige = new BigNum(0);
      this.oneBigNum = new BigNum(1);
      this.perFrameConversionFactor = new BigNum(1 / Settings.time.turnFrames);
    }
    /**
     * This must be invoked whenever a change is made to the mine damage (typically via an upgrade purchase)
     */
    calculateTotalMineDamagePerTurn() {
      this.workingMineDamage.copy(this.damage.basePickDamagePerTurn);
      this.workingMineDamage.add(this.values.baseAdditiveBonusPerTurn.getValue());
      this.workingMultiBonus.copy(this.oneBigNum);
      this.workingMultiBonus.add(this.values.baseMultiplicativeBonusValue.getValue());
      this.minedDamageBonus.copy(this.oneBigNum);
      this.minedDamageBonus.add(this.values.minedDamageBonusMultiplier.getValue());
      this.damage.minedDamageMultiplier.copy(this.minedDamageBonus);
      this.prestigeMultiplier.setValue(Settings.prestige.multiplierPerPrestige + this.values.skillPrestigeBonusMultiplier.getValue());
      this.prestigeBonus.copy(this.totals.prestigePointsSum);
      this.prestigeBonus.mul(this.prestigeMultiplier);
      this.prestigeBonus.add(this.oneBigNum);
      this.damage.prestigeDamageMultiplier.copy(this.prestigeBonus);
      if (this.totals.ruby.greaterThanZero()) {
        this.rubyMultiplier.setValue(Settings.ruby.multiplierPerRuby + this.values.skillRubyBonusMultiplier.getValue());
        this.rubyBonus.copy(this.totals.ruby);
        this.rubyBonus.mul(this.rubyMultiplier);
        this.rubyBonus.add(this.oneBigNum);
        this.damage.rubyDamageMultiplier.copy(this.rubyBonus);
      } else {
        this.damage.rubyDamageMultiplier.copy(this.oneBigNum);
      }
      const blockBonusMultipleir = this.values.skillBlockBonusMultiplier.getValue();
      if (blockBonusMultipleir > 0 && this.globalStatistics.tilesMined.greaterThanZero()) {
        this.blockMultiplier.setValue(Settings.blocks.multiplierPerBlock + blockBonusMultipleir);
        this.blockBonus.copy(this.globalStatistics.tilesMined);
        this.blockBonus.mul(this.blockMultiplier);
        this.blockBonus.add(this.oneBigNum);
        this.damage.blockDamageMultiplier.copy(this.blockBonus);
      } else {
        this.damage.blockDamageMultiplier.copy(this.oneBigNum);
      }
      const depthBonusMultiplier = this.values.skillDepthBonusMultiplier.getValue();
      if (depthBonusMultiplier > 0) {
        this.workingDepthDamageMultiplier.setValue(this.globalStatistics.maxDepth);
        this.workingDepthDamageMultiplier.mulNumber(depthBonusMultiplier);
        this.damage.depthDamageMultiplier.copy(this.workingDepthDamageMultiplier);
      } else {
        this.workingDepthDamageMultiplier.copy(this.oneBigNum);
        this.damage.depthDamageMultiplier.copy(this.oneBigNum);
      }
      this.workingMineDamage.multiply(this.workingMultiBonus);
      if (this.minedDamageBonus.greaterThan(this.oneBigNum)) {
        this.workingMineDamage.multiply(this.minedDamageBonus);
      }
      if (this.prestigeBonus.greaterThan(this.oneBigNum)) {
        this.workingMineDamage.multiply(this.prestigeBonus);
      }
      if (this.workingDepthDamageMultiplier.greaterThan(this.oneBigNum)) {
        this.workingMineDamage.multiply(this.workingDepthDamageMultiplier);
      }
      if (this.damage.goldDamageMultiplier.greaterThan(this.oneBigNum)) {
        this.workingMineDamage.multiply(this.damage.goldDamageMultiplier);
      }
      if (this.damage.rubyDamageMultiplier.greaterThan(this.oneBigNum)) {
        this.workingMineDamage.multiply(this.damage.rubyDamageMultiplier);
      }
      if (this.damage.blockDamageMultiplier.greaterThan(this.oneBigNum)) {
        this.workingMineDamage.multiply(this.damage.blockDamageMultiplier);
      }
      this.damage.totalPickDamagePerTurn.copy(this.workingMineDamage);
      this.damage.totalPickDamagePerFrame.copy(this.damage.totalPickDamagePerTurn);
      this.damage.totalPickDamagePerFrame.mul(this.perFrameConversionFactor);
    }
  };

  // src/logic/OreCalculationLogic.js
  var OreCalculationLogic = class {
    /**
     * 
     * @param {Values} values 
     */
    constructor(values) {
      this.values = values;
      this.one = new BigNum(1);
    }
    // /**
    //  * The tile MUST be an ORE tile.
    //  * @param {GridTile} tile 
    //  * @param {BigNum} oreOutput
    //  */
    // calculateOre(tile, oreOutput) {
    //     // Only ORE tile types have ore.
    //     if (this.tileType.rarityModifier !== TileTypeRarity.ORE) {
    //         oreOutput.setZero();
    //         return;
    //     }
    //     this.calculateOreForDepth(tile, oreOutput);
    // }
    /**
     * This can be used for tiles that are not ORE tiles.
     * @param {GridTile} tile 
     * @param {BigNum} oreOutput
     */
    calculateOreForDepth(tile, oreOutput) {
      tile.tileType.layerDescription.calculateTileOre(tile.getTileRow(), oreOutput);
      this.applyMultipliers(oreOutput);
    }
    /**
     * @private
     * @param {BigNum} oreOutput
     */
    applyMultipliers(oreOutput) {
      const oreBonusMultiplier = this.values.skillOreBonusMultiplier.getValue();
      if (oreBonusMultiplier.greaterThan(this.one)) {
        oreOutput.mul(oreBonusMultiplier);
      }
      const goldOreBonusMultiplier = this.values.goldOreBonusMultiplier.getValue();
      if (goldOreBonusMultiplier.greaterThan(this.one)) {
        oreOutput.mul(goldOreBonusMultiplier);
      }
    }
  };

  // src/Images.js
  var Images = {
    pick: "images/pick_40x40.png",
    miner: "images/pick_40x40.png",
    offline: "images/pick_40x40.png",
    currency: {
      ore: "images/layers/purple_ore.png",
      gold: "images/layers/gold.png",
      ruby: "images/layers/ruby.png",
      prestige: "images/pick_40x40.png",
      depth: "images/pick_40x40.png",
      upgrades: "images/upgrades_40x40.png"
    },
    skill: {
      missiles: "images/missile_40x40.png",
      orbit: "images/orbit_40x40.png",
      laser: "images/laser_40x40.png",
      lightning: "images/laser_40x40.png",
      chain: "images/laser_40x40.png",
      drill: "images/drill_40x40.png",
      radar: "images/laser_40x40.png",
      fissure: "images/laser_40x40.png",
      minions: "images/laser_40x40.png",
      dynamite: "images/dynamite_40x40.png",
      damage: "images/laser_40x40.png",
      activation: "images/laser_40x40.png"
    }
  };

  // src/model/upgrade/free/UpgradeCreator.js
  var UpgradeCreator = class {
    /**
     * 
     * @param {string} id 
     */
    constructor(id) {
      this.id = id;
    }
    /**
     * @returns {string}
     */
    getId() {
      return this.id;
    }
    /**
     * @abstract
     * @param {GridTile} tile
     * @returns {Upgrade}
     */
    createMinedUpgrade(tile) {
    }
    /**
     * @abstract
     * @param {BigNum} valueDelta
     * @returns {Upgrade}
     */
    createFreeValueUpgradeFromSave(valueDelta) {
    }
    /**
     * @abstract
     * @param {string} id 
     * @returns {Upgrade}
     */
    createFreeIdentifierUpgradeFromSave(id) {
    }
    /**
     * Combine two upgrades. The first upgrade will be updated. The second can be removed.
     * @param {Upgrade} upgrade1
     * @param {Upgrade} upgrade2
     */
    combineUpgrades(upgrade1, upgrade2) {
      if (!upgrade1 || !upgrade2) {
        console.log("UpgradeCreator.combineUpgrade() null upgrade");
        return;
      }
      if (upgrade1.getCreatorId() !== upgrade2.getCreatorId()) {
        console.log("UpgradeCreator.combineUpgrade() creatorId mismatch");
        return;
      }
      if (this.id !== upgrade1.getCreatorId() || this.id !== upgrade2.getCreatorId()) {
        console.log("UpgradeCreator.combineUpgrade() creatorId does not match upgrade creator");
        return;
      }
      this.combineUpgradesInternal(upgrade1, upgrade2);
    }
    /**
     * @abstract
     * @param {Upgrade} upgrade1
     * @param {Upgrade} upgrade2
     */
    combineUpgradesInternal(upgrade1, upgrade2) {
    }
  };

  // src/model/upgrade/free/FreeUpgrade.js
  var FreeUpgrade = class extends Upgrade {
    /**
     * @param {UpgradeCreator} upgradeCreator
     * @param {string} title
     * @param {string} iconFileName
     */
    constructor(upgradeCreator, title, iconFileName) {
      super(title, iconFileName);
      this.upgradeCreator = upgradeCreator;
    }
    /**
     * @returns {string}
     */
    getCreatorId() {
      return this.upgradeCreator.id;
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isCombineSupported() {
      return false;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isPurchasable() {
      return this.purchasedCount === 0;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isAffordable() {
      return true;
    }
    /**
     * @override
     * @returns {boolean} true if the purchase was made.
     */
    purchase() {
      if (this.purchasedCount > 0) {
        return false;
      }
      this.purchasedCount++;
      this.onUpgradePurchased();
      return true;
    }
    /**
     * Invoked by the base class to let the sub-class know that a purchase has been made.
     * @abstract
     */
    onUpgradePurchased() {
    }
  };

  // src/model/upgrade/free/MinedUpgrade.js
  var MinedUpgrade = class extends FreeUpgrade {
    /**
     * @param {UpgradeCreator} upgradeCreator 
     * @param {string} title
     * @param {string} iconFileName
     * @param {BigNum} valueDelta
     * @param {BigNumValue} upgradeBonusValue External value holder for upgrade bonus.
     * @param {MineDamageLogic} mineDamageLogic
     */
    constructor(upgradeCreator, title, iconFileName, valueDelta, upgradeBonusValue, mineDamageLogic) {
      super(upgradeCreator, title, iconFileName);
      this.valueDelta = valueDelta;
      this.upgradeBonusValue = upgradeBonusValue;
      this.mineDamageLogic = mineDamageLogic;
    }
    /**
     * Invoked by the base class to let the sub-class know that a purchase has been made.
     * @override
     */
    onUpgradePurchased() {
      this.upgradeBonusValue.incrementValue(this.valueDelta);
      if (this.mineDamageLogic) {
        this.mineDamageLogic.calculateTotalMineDamagePerTurn();
      }
    }
    /**
     * @override
     * @returns {boolean}
     */
    isCombineSupported() {
      return true;
    }
  };

  // src/model/upgrade/free/MinedUpgradeCreator.js
  var MinedUpgradeCreator = class extends UpgradeCreator {
    /**
     * @abstract
     * @param {string} id 
     * @param {Values} values
     * @param {NumberValue} multiplierValue 
     */
    constructor(id, values, multiplierValue) {
      super(id);
      this.values = values;
      this.multiplierValue = multiplierValue;
    }
    /**
     * @returns {number}
     */
    getUpgradeBonusMultiplier() {
      const upgradeBonusMultiplier = this.multiplierValue.getValue();
      if (upgradeBonusMultiplier > 1) {
        return upgradeBonusMultiplier;
      }
      return 1;
    }
  };

  // src/model/upgrade/free/UpgradeCreatorIds.js
  var UpgadeCreatorIds = {
    /**
     * @constant
     * @type {string}
     */
    mineDamage: "mineDamage",
    /**
     * @constant
     * @type {string}
     */
    mineOre: "mineOre"
  };

  // src/model/upgrade/free/MinedDamageBonusUpgradeCreator.js
  var MinedDamageBonusUpgradeCreator = class extends MinedUpgradeCreator {
    /**
     * @param {Values} values 
     * @param {MineDamageLogic} mineDamageLogic
     */
    constructor(values, mineDamageLogic) {
      super(UpgadeCreatorIds.mineDamage, values, null);
      this.mineDamageLogic = mineDamageLogic;
    }
    /**
     * @abstract
     * @param {GridTile} tile
     * @returns {Upgrade}
     */
    createMinedUpgrade(tile) {
      const value2 = ValueCalculator.calculateMinedDamageUpgradeValue(tile);
      const minedDamageBonus = this.values.skillMinedDamageBonus.getValue();
      if (minedDamageBonus > 0) {
        value2.addNumber(minedDamageBonus);
      }
      return this.createInternal(value2);
    }
    /**
     * @override
     * @param {BigNum} valueDelta
     * @returns {Upgrade}
     */
    createFreeValueUpgradeFromSave(valueDelta) {
      return this.createInternal(valueDelta);
    }
    /**
     * @private
     * @param {BigNum} valueDelta
     * @returns {Upgrade}
     */
    createInternal(valueDelta) {
      const title = this.createTitle(valueDelta);
      return new MinedUpgrade(this, title, Images.pick, valueDelta, this.values.minedDamageBonusMultiplier, this.mineDamageLogic);
    }
    /**
     * @override
     * @param {Upgrade} upgrade1
     * @param {Upgrade} upgrade2
     */
    combineUpgradesInternal(upgrade1, upgrade2) {
      upgrade1.valueDelta.add(upgrade2.valueDelta);
      upgrade1.title = this.createTitle(upgrade1.valueDelta);
    }
    /**
     * @private
     * @param {BigNum} valueDelta 
     * @returns {string}
     */
    createTitle(valueDelta) {
      return "Multiplier: +" + NumberFormatter.formatBigNum(valueDelta);
    }
  };

  // src/model/upgrade/free/MinedOreUpgrade.js
  var MinedOreUpgrade = class extends FreeUpgrade {
    /**
     * @param {UpgradeCreator} upgradeCreator 
     * @param {string} title
     * @param {string} iconFileName
     * @param {BigNum} ore
     * @param {Totals} totals
     * @param {StatisticsIncrementor} statisticsIncrementor
     */
    constructor(upgradeCreator, title, iconFileName, ore, totals, statisticsIncrementor) {
      super(upgradeCreator, title, iconFileName);
      this.ore = ore;
      this.totals = totals;
      this.statisticsInc = statisticsIncrementor;
    }
    /**
     * Invoked by the base class to let the sub-class know that a purchase has been made.
     * @override
     */
    onUpgradePurchased() {
      this.totals.incrementOre(this.ore);
      this.statisticsInc.incrementOre(this.ore);
      this.statisticsInc.incrementUpgradeOre(this.ore);
    }
    /**
     * @override
     * @returns {boolean}
     */
    isCombineSupported() {
      return true;
    }
  };

  // src/model/upgrade/free/MinedOreBonusUpgradeCreator.js
  var MinedOreBonusUpgradeCreator = class extends MinedUpgradeCreator {
    /**
     * @param {Values} values 
     * @param {OreCalculationLogic} oreCalculationLogic
     * @param {Totals} totals
     * @param {StatisticsIncrementor} statisticsIncrementor
     */
    constructor(values, oreCalculationLogic, totals, statisticsIncrementor) {
      super(UpgadeCreatorIds.mineOre, values, null);
      this.oreCalculationLogic = oreCalculationLogic;
      this.totals = totals;
      this.statisticsInc = statisticsIncrementor;
    }
    /**
     * @param {GridTile} tile
     * @returns {Upgrade}
     */
    createMinedUpgrade(tile) {
      const tileOre = new BigNum(0);
      this.oreCalculationLogic.calculateOreForDepth(tile, tileOre);
      let tilesPerUpgrade = Settings.skill.bonus.minedOreBaseTiles;
      const minedOreBonusUpgrades = this.values.skillMinedOreBonusUpgrades.getValue();
      if (minedOreBonusUpgrades > 0) {
        const extraTiles = minedOreBonusUpgrades * Settings.skill.bonus.minedOreBonusPerUpgrade;
        tilesPerUpgrade += extraTiles;
      }
      tileOre.mulNumber(tilesPerUpgrade);
      return this.createInternal(tileOre);
    }
    /**
     * @override
     * @param {BigNum} ore
     * @returns {Upgrade}
     */
    createFreeValueUpgradeFromSave(ore) {
      return this.createInternal(ore);
    }
    /**
     * @private
     * @param {BigNum} ore
     * @returns {Upgrade}
     */
    createInternal(ore) {
      const title = this.createTitle(ore);
      return new MinedOreUpgrade(this, title, Images.pick, ore, this.totals, this.statisticsInc);
    }
    /**
     * @override
     * @param {MinedOreUpgrade} upgrade1
     * @param {MinedOreUpgrade} upgrade2
     */
    combineUpgradesInternal(upgrade1, upgrade2) {
      upgrade1.ore.add(upgrade2.ore);
      upgrade1.title = this.createTitle(upgrade1.ore);
    }
    /**
     * @private
     * @param {BigNum} ore 
     * @returns {string}
     */
    createTitle(ore) {
      return "Ore: +" + NumberFormatter.formatBigNum(ore);
    }
  };

  // src/model/upgrade/free/MinedUpgradeCollection.js
  var MinedUpgradeCollection = class extends UpgradeCollection {
    constructor() {
      super();
      this.combineUpgradeThreshold = 8;
    }
    /**
     * @param {string} creatorId 
     * @returns {boolean}
     */
    contains(creatorId) {
      for (let i = 0; i < this.upgrades.length; i++) {
        const upgrade = this.upgrades[i];
        if (upgrade.getCreatorId() === creatorId) {
          return true;
        }
      }
      return false;
    }
    /**
     * @param {Upgrade} upgrade 
     */
    add(upgrade) {
      super.add(upgrade);
      if (this.upgrades.length > this.combineUpgradeThreshold) {
        this.combineUpgrades();
      }
    }
    /**
     * @private
     */
    combineUpgrades() {
      for (let i = 0; i < this.upgrades.length - 1; i++) {
        const upgrade1 = this.upgrades[i];
        if (!upgrade1.isCombineSupported()) {
          continue;
        }
        for (let j = this.upgrades.length - 1; j > i; j--) {
          const upgrade2 = this.upgrades[j];
          if (!upgrade2.isCombineSupported()) {
            continue;
          }
          if (upgrade1.getCreatorId() !== upgrade2.getCreatorId()) {
            continue;
          }
          upgrade1.upgradeCreator.combineUpgrades(upgrade1, upgrade2);
          this.upgrades.splice(j, 1);
          this.changeCount++;
          break;
        }
      }
    }
  };

  // src/model/upgrade/free/UpgradeCreators.js
  var UpgradeCreators = class {
    /**
     * @param {Values} values 
     * @param {Totals} totals
     * @param {OreCalculationLogic} oreCalculationLogic
     * @param {MineDamageLogic} mineDamageLogic
     * @param {MinedUpgradeCollection} minedUpgradeCollection
     * @param {StatisticsIncrementor} statisticsIncrementor
     */
    constructor(values, totals, oreCalculationLogic, mineDamageLogic, minedUpgradeCollection, statisticsIncrementor) {
      this.creatorsById = {};
      this.minedUpgradeCollection = minedUpgradeCollection;
      this.mineDamage = new MinedDamageBonusUpgradeCreator(values, mineDamageLogic);
      this.creatorsById[this.mineDamage.getId()] = this.mineDamage;
      this.oreBonus = new MinedOreBonusUpgradeCreator(values, oreCalculationLogic, totals, statisticsIncrementor);
      this.creatorsById[this.oreBonus.getId()] = this.oreBonus;
    }
    /**
     * This is used by the save logic to get the correct upgrade creator.
     * @param {string} id 
     * @returns {UpgradeCreator}
     */
    getUpgradeCreatorById(id) {
      return this.creatorsById[id];
    }
    /**
     * Returns an upgrade creator for mined upgrades.
     * @returns {UpgradeCreator}
     */
    getUpgradeCreatorForDrop() {
      const selection = Math.random();
      if (selection < 0.65) {
        return this.oreBonus;
      } else {
        return this.mineDamage;
      }
    }
  };

  // src/logic/TileMinedLogic.js
  var TileMinedLogic = class {
    /**
     * @param {Crew} crew
     * @param {Totals} totals 
     * @param {Damage} damage
     * @param {Values} values
     * @param {StatisticsIncrementor} statisticsIncrementor
     * @param {UpgradeCollection} upgradeCollection
     * @param {UpgradeCreators} upgradeCreators
     * @param {InfoTextProcessor} infoTextProcessor
     * @param {EffectCreators} effectCreators
     * @param {EffectManager} effectManager
     * @param {OreCalculationLogic} oreCalculationLogic
     * @param {MineDamageLogic} mineDamageLogic
     */
    constructor(crew, totals, damage, values, statisticsIncrementor, upgradeCollection, upgradeCreators, infoTextProcessor, effectCreators, effectManager, oreCalculationLogic, mineDamageLogic) {
      this.crew = crew;
      this.totals = totals;
      this.damage = damage;
      this.values = values;
      this.statisticsInc = statisticsIncrementor;
      this.upgradeCollection = upgradeCollection;
      this.upgradeCreators = upgradeCreators;
      this.infoTextProcessor = infoTextProcessor;
      this.effectCreators = effectCreators;
      this.effectManager = effectManager;
      this.oreCalculationLogic = oreCalculationLogic;
      this.mineDamageLogic = mineDamageLogic;
      this.workingValue = new BigNum(0);
      this.workingDamage = new BigNum(0);
      this.turnsPerSecond = new BigNum(Settings.time.turnsPerSecond);
      this.one = new BigNum(1);
    }
    /**
     * @param {Character} character 
     * @param {GridTile} tile 
     */
    mineTileIstantly(character, tile) {
      if (!tile || tile.open) {
        return;
      }
      tile.onTileBreak();
      this.revealTilesAfterMine(character, tile);
      this.statisticsInc.onTileMined(tile);
      this.handleTileDrops(tile);
    }
    /**
     * @param {Character} character 
     * @param {GridTile} tile 
     * @returns {boolean} True if the tile has been mined.
     */
    mineTileForTurn(character, tile) {
      if (!tile || tile.open) {
        return true;
      }
      this.workingDamage.copy(this.damage.totalPickDamagePerTurn);
      tile.onTileDamaged(this.workingDamage);
      if (tile.open) {
        this.revealTilesAfterMine(character, tile);
        this.statisticsInc.onTileMined(tile);
        this.handleTileDrops(tile);
        return true;
      }
      return false;
    }
    /**
     * @private
     * @param {Character} character 
     * @param {GridTile} tile 
     */
    revealTilesAfterMine(character, tile) {
      let oppositeTile = this.getOppositeTile(character.position.tile, tile);
      if (oppositeTile) {
        this.revealTile(oppositeTile);
        for (let i = 0; i < oppositeTile.neighbors.length; i++) {
          this.revealTile(oppositeTile.neighbors[i]);
        }
        this.revealTile(oppositeTile.getNeighborBottomLeft());
        this.revealTile(oppositeTile.getNeighborBottomRight());
        this.revealTile(oppositeTile.getNeighborTopLeft());
        this.revealTile(oppositeTile.getNeighborTopRight());
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     */
    revealTile(tile) {
      if (tile) {
        tile.markTileAsCurrentlyVisible();
      }
    }
    /**
     * Get the tile on the other side from the character.  
     * If the character is on the left of the mined tile, when return the tile on the right.
     * @private
     * @param {GridTile} tile 
     * @param {GridTile} minedTile 
     */
    getOppositeTile(tile, minedTile) {
      if (!tile) {
        return null;
      }
      if (minedTile.isNeighborLeft(tile)) {
        return minedTile.getNeighborRight();
      } else if (minedTile.isNeighborRight(tile)) {
        return minedTile.getNeighborLeft();
      } else if (minedTile.isNeighborBottom(tile)) {
        return minedTile.getNeighborTop();
      } else if (minedTile.isNeighborTop(tile)) {
        return minedTile.getNeighborBottom();
      }
      return null;
    }
    /**
     * @param {GridTile} tile 
     * @param {number} frameTimeRatio
     */
    laserTileForFrame(tile, frameTimeRatio) {
      if (!tile || tile.open) {
        return;
      }
      this.skillDamageForFrame(tile, frameTimeRatio, this.effectCreators.effectSparkleRed);
      if (tile.open) {
        this.statisticsInc.incrementMinedByLaser();
      }
    }
    /**
     * @param {GridTile} tile 
     * @param {number} frameTimeRatio
     */
    drillTileForFrame(tile, frameTimeRatio) {
      if (!tile || tile.open) {
        return;
      }
      this.skillDamageForFrame(tile, frameTimeRatio, this.effectCreators.effectSparkleBlue);
      if (tile.open) {
        this.statisticsInc.incrementMinedByDrill();
      }
    }
    /**
     * @param {GridTile} tile 
     * @param {number} frameTimeRatio
     */
    orbitTileForFrame(tile, frameTimeRatio) {
      if (!tile || tile.open) {
        return;
      }
      this.skillDamageForFrame(tile, frameTimeRatio, this.effectCreators.effectSparkleGold);
      if (tile.open) {
        this.statisticsInc.incrementMinedByOrbit();
      }
    }
    /**
     * @param {BigNum} damageOutput
     * @returns {BigNum}
     */
    calculateMissileDamage(damageOutput) {
      damageOutput.copy(this.damage.totalPickDamagePerTurn);
      return damageOutput;
    }
    /**
     * @param {GridTile} tile 
     * @param {BigNum} missileDamage
     */
    missileTile(tile, missileDamage) {
      if (!tile || tile.open) {
        return;
      }
      const health = tile.getHealth();
      if (health.lessThan(missileDamage)) {
        missileDamage.sub(health);
        tile.onTileBreak();
        tile.markTileAsCurrentlyVisible();
        this.handleTileDrops(tile);
        this.statisticsInc.incrementMinedByMissile();
      } else {
        tile.onTileDamaged(missileDamage);
        missileDamage.setZero();
      }
    }
    /**
     * @param {GridTile} tile 
     * @param {number} frameTimeRatio
     */
    applyFissureSkillForFrame(tile, frameTimeRatio) {
      if (!tile || tile.open) {
        return;
      }
      this.skillDamageForFrame(tile, frameTimeRatio, null);
      if (tile.open) {
        this.statisticsInc.incrementMinedByFissure();
      }
    }
    /**
     * @param {GridTile} tile 
     * @param {number} frameTimeRatio
     */
    applyLightningSkillForFrame(tile, frameTimeRatio) {
      if (!tile || tile.open) {
        return;
      }
      this.skillDamageForFrame(tile, frameTimeRatio, this.effectCreators.effectSparkleOrange);
      if (tile.open) {
        this.statisticsInc.incrementMinedByLightning();
      }
    }
    // /**
    //  * @param {NumberValue} damagePercent
    //  * @param {BigNum} damageOutput 
    //  */
    // calculateDynamiteDamage(damagePercent, damageOutput) {
    //     // Get the damage per turn
    //     damageOutput.copy(this.damage.totalPickDamagePerTurn);
    //     // Apply the dynamite damage bonus skill value
    //     const damageBonusMultiplier = 1.0 + damagePercent.getPercentAsFraction();
    //     damageOutput.mulNumber(damageBonusMultiplier);
    //     // // See if crew damage skill is activated
    //     // if (this.values.globalDamageMultiplier.isValueApplicable()) {
    //     //     const crewDamageBonusMultiplier = 1.0 + this.values.globalDamageMultiplier.getPercentAsFraction();            
    //     //     damageOutput.mulNumber(crewDamageBonusMultiplier);
    //     // }
    // }
    // /**
    //  * @param {GridTile} tile
    //  * @param {BigNum} dynamiteDamage See calculateDynamiteDamage
    //  */
    // dynamiteDamage(tile, dynamiteDamage) {
    //     if (!tile || tile.open) {
    //         return;
    //     }
    //     tile.onTileDamaged(dynamiteDamage);
    //     // If the tile is open then we just finished mining it.
    //     if (tile.open) {
    //         this.statisticsInc.incrementMinedByDynamite();
    //         this.handleTileDrops(tile);
    //     }
    // }
    /**
     * @private
     * @param {GridTile} tile 
     * @param {number} frameTimeRatio 
     * @param {number} skillDamageMultiplier 
     * @param {EffectCreator} effectCreator
     */
    skillDamageForFrame(tile, frameTimeRatio, effectCreator) {
      if (!tile || tile.open) {
        return;
      }
      this.workingDamage.copy(this.damage.totalPickDamagePerFrame);
      this.workingDamage.mulNumber(frameTimeRatio);
      tile.onTileDamaged(this.workingDamage);
      if (tile.open) {
        this.statisticsInc.onTileMined(tile);
        tile.markTileAsCurrentlyVisible();
        this.handleTileDrops(tile);
        if (effectCreator) {
          const effect = effectCreator.createEffectAtPosition(null, tile.origin);
          if (effect) {
            this.effectManager.addEffect(effect);
          } else {
            console.log("TileMinedLogic.skillDamageForFrame. FAILED TO CREATE SPRITE");
          }
        }
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     */
    handleTileDrops(tile) {
      const tileType = tile.tileType;
      const rarityModifier = tileType.rarityModifier;
      if (rarityModifier === TileTypeRarity.UNSET || rarityModifier === TileTypeRarity.COMMON) {
        return;
      }
      this.workingValue.setZero();
      if (rarityModifier === TileTypeRarity.ORE) {
        this.oreCalculationLogic.calculateOreForDepth(tile, this.workingValue);
        this.totals.incrementOre(this.workingValue);
        this.statisticsInc.incrementOre(this.workingValue);
        this.infoTextProcessor.addOreText(tile, this.workingValue);
      } else if (rarityModifier === TileTypeRarity.GOLD) {
        tile.calculateTileGold(this.workingValue);
        this.totals.incrementGold(this.workingValue);
        this.statisticsInc.incrementGold(this.workingValue);
        this.infoTextProcessor.addGoldText(tile, this.workingValue);
      } else if (rarityModifier === TileTypeRarity.UPGRADE) {
        const upgradeCreator = this.upgradeCreators.getUpgradeCreatorForDrop();
        const upgrade = upgradeCreator.createMinedUpgrade(tile);
        if (upgrade) {
          this.upgradeCollection.add(upgrade);
        } else {
          console.log("TileMinedLogic.handleTileDrops() no upgrade created");
        }
      } else if (rarityModifier === TileTypeRarity.RUBY) {
        this.totals.incrementRuby(this.one);
        this.statisticsInc.incrementRuby(this.one);
        this.infoTextProcessor.addRubyText(tile, this.one);
        this.mineDamageLogic.calculateTotalMineDamagePerTurn();
      }
    }
  };

  // src/model/grid/VectorField.js
  var VectorField = class extends GameModel {
    constructor() {
      super();
      this.commonMiningCandidates = [];
      this.priorityMiningCandidates = [];
      this.currencyMiningCandidates = [];
      this.destinationTileCandidates = [];
      this.ignoreCommonTiles = false;
      this.ignorePremiumTiles = false;
      this.centerTile = null;
      this.vectorFieldNumber = 0;
      this.tileHealthNegligible = false;
    }
    /**
     * @returns {boolean}
     */
    isVectorFieldMineTargetsEmpty() {
      return this.commonMiningCandidates.length === 0 && this.currencyMiningCandidates.length === 0 && this.priorityMiningCandidates.length === 0;
    }
    /**
     * @returns {boolean}
     */
    isPriorityTileVisible() {
      if (this.priorityMiningCandidates.length === 0 && this.currencyMiningCandidates.length === 0) {
        return false;
      }
      return this.isClosedTileInList(this.priorityMiningCandidates) || this.isClosedTileInList(this.currencyMiningCandidates);
    }
    /**
     * @private
     * @param {GridTile[]} tiles 
     * @returns {boolean}
     */
    isClosedTileInList(tiles) {
      for (let i = 0; i < tiles.length; i++) {
        if (!tiles[i].open) {
          return true;
        }
      }
      return false;
    }
    /**
     * 
     * @param {Grid} grid 
     * @returns {boolean} True if the full vector field has been reset.
     */
    onGridUnload(grid) {
      if (this.centerTile && this.centerTile.grid === grid) {
        this.reset();
        return true;
      }
      this.removeTilesForGrid(grid, this.commonMiningCandidates);
      this.removeTilesForGrid(grid, this.priorityMiningCandidates);
      this.removeTilesForGrid(grid, this.currencyMiningCandidates);
      return false;
    }
    /**
     * @private
     * @param {Grid} grid 
     * @param {GridTile[]} tiles 
     */
    removeTilesForGrid(grid, tiles) {
      for (let i = tiles.length - 1; i >= 0; i--) {
        if (tiles[i].grid === grid) {
          tiles.splice(i, 1);
        }
      }
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.reset();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.reset();
    }
    reset() {
      if (this.commonMiningCandidates.length > 0) {
        this.commonMiningCandidates.length = 0;
      }
      if (this.priorityMiningCandidates.length > 0) {
        this.priorityMiningCandidates.length = 0;
      }
      if (this.currencyMiningCandidates.length > 0) {
        this.currencyMiningCandidates.length = 0;
      }
      this.centerTile = null;
      this.vectorFieldNumber++;
      if (this.vectorFieldNumber > 1e5) {
        this.vectorFieldNumber = 0;
      }
    }
  };

  // src/model/performance/PerformanceTrack.js
  var PerformanceTrack = class {
    /**
     * 
     * @param {string} subject 
     */
    constructor(subject) {
      this.subject = subject;
      this.startTime = performance.now();
      this.elapsed = 0;
      this.count = 0;
    }
    startTimer() {
      this.startTime = performance.now();
    }
    endTimer() {
      this.elapsed += performance.now() - this.startTime;
      this.count++;
    }
    reset() {
      this.startTime = performance.now();
      this.elapsed = 0;
      this.count = 0;
    }
  };

  // src/model/performance/PerformanceMetrics.js
  var valueMap = {};
  var PerformanceMetrics = class {
    constructor() {
    }
    /**
     * @param {string} subject 
     */
    static startTime(subject) {
      let value2 = valueMap[subject];
      if (!value2) {
        value2 = new PerformanceTrack(subject);
        valueMap[subject] = value2;
      }
      value2.startTimer();
    }
    /**
     * @param {string} subject 
     */
    static endTime(subject) {
      const value2 = valueMap[subject];
      if (!value2) {
        console.log("PerformanceMetrics: failed to find: " + subject);
        return;
      }
      value2.endTimer();
    }
    /**
     * @returns {string[]}
     */
    static getKeys() {
      return Object.keys(valueMap);
    }
    /**
     * @param {string} key 
     * @returns {PerformanceTrack}
     */
    static getPerformanceTrack(key) {
      return valueMap[key];
    }
    static reset() {
      for (const [key] of Object.entries(valueMap)) {
        const performanceTrack = valueMap[key];
        if (performanceTrack) {
          performanceTrack.reset();
        }
      }
    }
  };

  // src/model/path/Path.js
  var Path = class {
    constructor() {
      const initialCapacity = 100;
      this.tiles = new Array(initialCapacity);
      for (let i = 0; i < initialCapacity; i++) {
        this.tiles[i] = null;
      }
      this.pathBuilder = new Array(initialCapacity);
      for (let i = 0; i < initialCapacity; i++) {
        this.tiles[i] = null;
      }
      this.pathBuilderIndex = 0;
      this.size = 0;
    }
    /**
     * Add a tile to the end of the path.
     * @param {GridTile} tile 
     */
    add(tile) {
      if (this.size >= this.tiles.length) {
        for (let i = 0; i < 20; i++) {
          this.tiles.push(null);
        }
      }
      this.tiles[this.size] = tile;
      this.size++;
    }
    addToFrontStart() {
      this.pathBuilderIndex = 0;
    }
    addToFrontEnd() {
      for (let i = this.pathBuilderIndex - 1; i >= 0; i--) {
        this.add(this.pathBuilder[i]);
      }
    }
    /**
     * Add a tile to the end of the path.
     * @param {GridTile} tile 
     */
    addToFront(tile) {
      if (this.pathBuilderIndex >= this.pathBuilder.length) {
        for (let i = 0; i < 20; i++) {
          this.pathBuilder.push(null);
        }
      }
      this.pathBuilder[this.pathBuilderIndex] = tile;
      this.pathBuilderIndex++;
    }
    reset() {
      this.size = 0;
    }
  };

  // src/model/path/find/DirectLinePathFinder.js
  var DirectLinePathFinder = class {
    constructor() {
      this.movementVector = new Vector(0, 0);
      this.position = new Vector(0, 0);
      this.nearZero = 1e-3;
    }
    /**
     * @param {Path} path 
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @returns {boolean}
     */
    findPath(path, startTile, endTile) {
      if (!startTile || !endTile) {
        return false;
      }
      if (startTile === endTile) {
        path.add(endTile);
        return true;
      }
      if (startTile.isNeighborTile(endTile)) {
        path.add(startTile);
        path.add(endTile);
        return true;
      }
      this.position.copy(startTile.origin);
      let tile = startTile;
      path.add(tile);
      const step = Settings.tile.halfSize;
      this.movementVector.copy(endTile.origin);
      this.movementVector.subtract(this.position);
      const totalDistance = Fast.len(this.movementVector);
      if (Math.abs(totalDistance) < this.nearZero) {
        return true;
      }
      const worldGrid = startTile.getWorldGrid();
      let traveledDistance = 0;
      this.movementVector.scale(step / totalDistance);
      let addedEnd = false;
      do {
        this.position.add(this.movementVector);
        traveledDistance += step;
        if (!tile.contains(this.position)) {
          const prev = tile;
          let neighbor = tile.getNeighbor(this.position);
          if (!neighbor) {
            console.log("DirectLinePathFinder.findPath() stepped to non-neighbor tile somehow!");
            neighbor = worldGrid.findGridTile(this.position);
            if (!neighbor) {
              return false;
            }
          }
          tile = neighbor;
          this.checkForDiagonal(path, prev, tile);
          path.add(tile);
          if (tile === endTile) {
            addedEnd = true;
            break;
          }
        }
      } while (traveledDistance < totalDistance && tile !== endTile);
      if (!addedEnd) {
        path.add(endTile);
      }
      return true;
    }
    /**
     * @private
     * @param {Path} path 
     * @param {GridTile} prev 
     * @param {GridTile} current 
     */
    checkForDiagonal(path, prev, current) {
      if (!current.isNeighborTile(prev)) {
        const left = prev.getNeighborLeft();
        const right = prev.getNeighborRight();
        const top = prev.getNeighborTop();
        const bottom = prev.getNeighborBottom();
        if (current === prev.getNeighborBottomLeft()) {
          if (bottom.open) {
            path.add(bottom);
          } else {
            path.add(left);
          }
        } else if (current === prev.getNeighborBottomRight()) {
          if (bottom.open) {
            path.add(bottom);
          } else {
            path.add(right);
          }
        } else if (current === prev.getNeighborTopLeft()) {
          if (top.open) {
            path.add(top);
          } else {
            path.add(left);
          }
        } else if (current === prev.getNeighborTopRight()) {
          if (top.open) {
            path.add(top);
          } else {
            path.add(right);
          }
        }
      }
    }
    // /**
    //  * The path plan cannot handle diagonal steps. See if we have any and add in an intermediate step.
    //  * @private
    //  * @param {Path} path
    //  */
    // fixDiagonalSteps(path) {
    //     /**
    //      * @type {GridTile}
    //      */
    //     for (let i = 1; i < path.length; i++) {
    //         const prev = path[i - 1];
    //         const current = path[i];
    //         if (!current.isNeighborTile(prev)) {
    //             const left = prev.getNeighborLeft();
    //             const right = prev.getNeighborRight();
    //             const top = prev.getNeighborTop();
    //             const bottom = prev.getNeighborBottom();
    //             if (current === prev.getNeighborBottomLeft()) {
    //                 // pick either bottom or left.
    //                 if (bottom.open) {
    //                     path.splice(i, 0, bottom);
    //                 }
    //                 else {
    //                     path.splice(i, 0, left);
    //                 }
    //             }
    //             else if (current === prev.getNeighborBottomRight()) {
    //                 // pick either bottom or right.
    //                 if (bottom.open) {
    //                     path.splice(i, 0, bottom);
    //                 }
    //                 else {
    //                     path.splice(i, 0, right);
    //                 }
    //             }
    //             else if (current === prev.getNeighborTopLeft()) {
    //                 // pick either top or left.
    //                 if (top.open) {
    //                     path.splice(i, 0, top);
    //                 }
    //                 else {
    //                     path.splice(i, 0, left);
    //                 }                    
    //             }
    //             else if (current === prev.getNeighborTopRight()) {
    //                 // pick either top or right.
    //                 if (top.open) {
    //                     path.splice(i, 0, top);
    //                 }
    //                 else {
    //                     path.splice(i, 0, right);
    //                 }                                        
    //             }
    //             else {
    //                 console.log('DirectLinePathFinder.fixDiagonalSteps() tiles are not adjacent');
    //                 console.log('i=' + i + ' curr=' + i + ' ' + current.origin.toString() + ' prev=' + prev.origin.toString() + ' adjacent=' + current.isAdjacentTo(prev) + ' neighbor=' + current.isNeighborTile(prev));
    //             }
    //         }
    //     }
    // }
  };

  // src/model/path/find/ScoreTile.js
  var ScoreTile = class {
    constructor() {
      this.score = 0;
      this.tile = null;
    }
    reset() {
      this.score = 0;
      this.tile = null;
    }
    /**
     * @param {number} score 
     * @param {GridTile} tile 
     */
    set(score, tile) {
      this.score = score;
      this.tile = tile;
    }
    /**
     * @param {ScoreTile} scoreTile 
     */
    copy(scoreTile) {
      this.score = scoreTile.score;
      this.tile = scoreTile.tile;
    }
  };

  // src/model/path/find/PriorityQueue2.js
  var PriorityQueue2 = class {
    constructor() {
      const initialCapacity = 100;
      this.queue = new Array(initialCapacity);
      for (let i = 0; i < initialCapacity; i++) {
        this.queue[i] = new ScoreTile();
      }
      this.size = 0;
    }
    // add() just calls offer
    // public boolean offer(E e) {
    //     if (e == null)
    //         throw new NullPointerException();
    //     modCount++;
    //     int i = size;
    //     if (i >= queue.length)
    //         grow(i + 1);
    //     siftUp(i, e);
    //     size = i + 1;
    //     return true;
    // }
    /**
     * @param {number} score
     * @param {GridTile} tile 
     */
    add(score, tile) {
      if (this.size >= this.queue.length) {
        this.grow(this.size + 1);
      }
      this.siftUpUsingComparator(this.size, score, tile);
      this.size = this.size + 1;
    }
    // private void grow(int minCapacity) {
    //     int oldCapacity = queue.length;
    //     // Double size if small; else grow by 50%
    //     int newCapacity = ArraysSupport.newLength(oldCapacity,
    //             minCapacity - oldCapacity, /* minimum growth */
    //             oldCapacity < 64 ? oldCapacity + 2 : oldCapacity >> 1
    //                                        /* preferred growth */);
    //     queue = Arrays.copyOf(queue, newCapacity);
    // }    
    /**
     * @private
     * @param {number} minCapacity 
     */
    grow(minCapacity) {
      const oldCapacity = this.queue.length;
      const minGrowth = minCapacity - oldCapacity;
      const prefGrowth = oldCapacity < 64 ? oldCapacity + 2 : oldCapacity >> 1;
      const growAmount = Math.max(minGrowth, prefGrowth);
      console.log("PriorityQueue2.grow() length=" + this.queue.length + " min=" + minGrowth + " pref=" + prefGrowth + " amount=" + growAmount);
      for (let i = 0; i < growAmount; i++) {
        this.queue.push(new ScoreTile());
      }
      console.log("PriorityQueue2.grow() new length: " + this.queue.length);
    }
    // private static <T> void siftUpUsingComparator(
    //     int k, T x, Object[] es, Comparator<? super T> cmp) {
    //     while (k > 0) {
    //         int parent = (k - 1) >>> 1;
    //         Object e = es[parent];
    //         if (cmp.compare(x, (T) e) >= 0)
    //             break;
    //         es[k] = e;
    //         k = parent;
    //     }
    //     es[k] = x;
    // }
    /**
     * @private
     * @param {number} index 
     * @param {number} score 
     * @param {GridTile} tile 
     */
    siftUpUsingComparator(index, score, tile) {
      while (index > 0) {
        const parentIndex = index - 1 >>> 1;
        let parentScoreTile = this.queue[parentIndex];
        if (this.compare(score, parentScoreTile.score) >= 0) {
          break;
        }
        this.queue[index].copy(parentScoreTile);
        index = parentIndex;
      }
      this.queue[index].set(score, tile);
    }
    // private static <T> void siftDownUsingComparator(
    //     int k, T x, Object[] es, int n, Comparator<? super T> cmp) {
    //     // assert n > 0;
    //     int half = n >>> 1;
    //     while (k < half) {
    //         int child = (k << 1) + 1;
    //         Object c = es[child];
    //         int right = child + 1;
    //         if (right < n && cmp.compare((T) c, (T) es[right]) > 0)
    //             c = es[child = right];
    //         if (cmp.compare(x, (T) c) <= 0)
    //             break;
    //         es[k] = c;
    //         k = child;
    //     }
    //     es[k] = x;
    // }
    /**
     * @private
     * @param {number} index 
     * @param {number} score
     * @param {GridTile} tile
     */
    siftDownUsingComparator(index, score, tile) {
      let half = this.size >>> 1;
      while (index < half) {
        let childIndex = (index << 1) + 1;
        let childScoreTile = this.queue[childIndex];
        let rightIndex = childIndex + 1;
        if (rightIndex < this.size && this.compare(childScoreTile.score, this.queue[rightIndex].score) > 0) {
          childIndex = rightIndex;
          childScoreTile = this.queue[childIndex];
        }
        if (this.compare(score, childScoreTile.score) <= 0) {
          break;
        }
        this.queue[index].copy(childScoreTile);
        index = childIndex;
      }
      this.queue[index].set(score, tile);
    }
    // public E poll() {
    //     final Object[] es;
    //     final E result;
    //     if ((result = (E) ((es = queue)[0])) != null) {
    //         modCount++;
    //         final int n;
    //         final E x = (E) es[(n = --size)];
    //         es[n] = null;
    //         if (n > 0) {
    //             final Comparator<? super E> cmp;
    //             if ((cmp = comparator) == null)
    //                 siftDownComparable(0, x, es, n);
    //             else
    //                 siftDownUsingComparator(0, x, es, n, cmp);
    //         }
    //     }
    //     return result;
    // }
    /**
     * @returns {GridTile}
     */
    poll() {
      let firstElement = this.queue[0];
      const tile = firstElement.tile;
      this.size--;
      const scoreTile = this.queue[this.size];
      const tileToSift = scoreTile.tile;
      const scoreToSift = scoreTile.score;
      scoreTile.reset();
      if (this.size > 0) {
        this.siftDownUsingComparator(0, scoreToSift, tileToSift);
      }
      return tile;
    }
    /**
     * @private
     * @param {number} x
     * @param {number} y
     * @returns {number}
     */
    compare(x, y) {
      return x - y;
    }
    /**
     * @returns {boolean}
     */
    isEmpty() {
      return this.size === 0;
    }
    clear() {
      for (let i = 0; i < this.size; i++) {
        this.queue[i].reset();
      }
      this.size = 0;
    }
  };

  // src/model/path/find/PathFinder.js
  var PathFinder = class {
    constructor() {
      this.openAirTileCost = Settings.tile.size * 15;
      this.closedTileCost = Settings.tile.size * 155;
      this.gravityDiscount = Settings.tile.halfSize;
      this.maxPathDistance = Settings.tile.size * 80;
      this.openList = new PriorityQueue2();
      this.pathNumber = 0;
      this.diagonalSize = Math.sqrt(Settings.tile.size * Settings.tile.size + Settings.tile.size * Settings.tile.size) | 0;
    }
    /**
     * @private
     * @param {Path} path 
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {boolean} inclusive 
     * @returns {boolean} Returns true if the path has been handled.
     */
    findPathSpecialCases(path, startTile, endTile, inclusive) {
      if (startTile === endTile) {
        if (inclusive) {
          path.add(endTile);
        }
        return true;
      }
      if (startTile.isNeighborTile(endTile)) {
        if (inclusive) {
          path.add(startTile);
          path.add(endTile);
        }
        return true;
      }
      const dist = Fast.dist(startTile.origin, endTile.origin);
      if (dist > this.maxPathDistance) {
        console.log("Path too long: " + dist / Settings.tile.size + " max: " + this.maxPathDistance / Settings.tile.size);
        return true;
      }
      return false;
    }
    /**
     * @param {Path} path 
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {boolean} inclusive 
     * @param {boolean} mineThroughWallsEnabled 
     * @param {boolean} ignoreWallPenalty
     */
    findPath(path, startTile, endTile, inclusive, mineThroughWallsEnabled, ignoreWallPenalty) {
      if (!startTile || !endTile) {
        console.log("findPath() null start/end");
        return;
      }
      if (this.findPathSpecialCases(path, startTile, endTile, inclusive)) {
        return;
      }
      this.pathNumber++;
      this.openList.clear();
      startTile.pathData.setCost(0, this.pathNumber);
      this.openList.add(0, startTile);
      startTile.pathData.setInOpenList(true, this.pathNumber);
      let current;
      while (!this.openList.isEmpty()) {
        current = this.openList.poll();
        if (!current) {
          console.log("PathFinder.findPath() current is null. bug");
          break;
        }
        current.pathData.setInOpenList(false, this.pathNumber);
        if (current === endTile) {
          this.constructPath(path, endTile, inclusive);
          break;
        } else {
          current.pathData.setClosed(true, this.pathNumber);
          const costToCurrent = current.pathData.getCost(this.pathNumber);
          const neighborBottom = current.getNeighborBottom();
          const currentTileOpenAir = !neighborBottom || neighborBottom.isTraversable();
          const neighbors = current.getNeighbors();
          for (let i = 0; i < neighbors.length; i++) {
            const neighbor = neighbors[i];
            if (!neighbor) {
              continue;
            }
            if (neighbor.pathData.isClosed(this.pathNumber)) {
              continue;
            }
            let costPenalty = 0;
            if (currentTileOpenAir) {
              if (i === 1) {
                costPenalty -= this.gravityDiscount;
              } else {
                costPenalty += this.openAirTileCost;
              }
            }
            if (!neighbor.open && mineThroughWallsEnabled && !ignoreWallPenalty) {
              costPenalty += this.closedTileCost;
            }
            const tentativeCost = costToCurrent + this.distanceBetween(current, neighbor) + costPenalty;
            const neighborInOpenList = neighbor.pathData.isInOpenList(this.pathNumber);
            if (neighborInOpenList && tentativeCost >= neighbor.pathData.getCost(this.pathNumber)) {
              continue;
            }
            const estimatedScore = tentativeCost + this.calculateHeuristicCostEstimate(neighbor, endTile);
            neighbor.pathData.set(current, tentativeCost, estimatedScore, this.pathNumber);
            if (!neighborInOpenList) {
              this.openList.add(estimatedScore, neighbor);
              neighbor.pathData.setInOpenList(true, this.pathNumber);
            }
          }
        }
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @param {GridTile} endTile 
     * @returns {number}
     */
    calculateHeuristicCostEstimate(tile, endTile) {
      return Fast.dist(tile.getOrigin(), endTile.getOrigin()) | 0;
    }
    /**
     * @private
     * @param {GridTile} current 
     * @param {GridTile} neighbor 
     * @returns {number}
     */
    distanceBetween(current, neighbor) {
      const currentOrigin = current.getOrigin();
      const neighborOrigin = neighbor.getOrigin();
      if (currentOrigin.x == neighborOrigin.x) {
        return Settings.tile.size;
      } else if (currentOrigin.y == neighborOrigin.y) {
        return Settings.tile.size;
      } else {
        return this.diagonalSize;
      }
    }
    /**
     * @private
     * @param {Path} path 
     * @param {GridTile} endTile 
     * @param {boolean} inclusive 
     */
    constructPath(path, endTile, inclusive) {
      let current;
      if (inclusive) {
        current = endTile;
      } else {
        current = endTile.pathData.getCameFrom(this.pathNumber);
        if (current == null) {
          return;
        }
      }
      path.addToFrontStart();
      do {
        path.addToFront(current);
        current = current.pathData.getCameFrom(this.pathNumber);
      } while (current != null);
      path.addToFrontEnd();
    }
  };

  // src/model/path/template/Template.js
  var Template = {
    /**
     * @const
     * @type {number}
     */
    IGNORE: -10,
    // Must be negative. Only path tiles are positive
    /**
     * @const
     * @type {number}
     */
    OPEN: -9,
    // Must be negative. Only path tiles are positive
    /**
     * Path tiles are open tiles. We do not always care if an open tile is also a path tile.
     * @const
     * @type {number}
     */
    OPEN_OR_PATH: -11,
    // Must be negative
    /**
     * @const
     * @type {number}
     */
    CLOSED: -8,
    // Must be negative. Only path tiles are positive
    /**
     * @const
     * @type {number}
     */
    START: 0,
    /**
     * @const
     * @type {number}
     */
    END: 1e3,
    // Must be positive, but use a number that will be greater than any possible path index
    /**
     * @const
     * @type {number}
     */
    PATH: 2e3
  };

  // src/model/path/template/PathTemplatePattern.js
  var PathTemplatePattern = class {
    /**
     * @param {Array.<String>} stringPattern 
     * @param {boolean} horizontalFlip
     */
    constructor(stringPattern, horizontalFlip) {
      this.startCol = 0;
      this.startRow = 0;
      this.endCol = 0;
      this.endRow = 0;
      this.startColFlipped = 0;
      this.startRowFlipped = 0;
      this.endColFlipped = 0;
      this.endRowFlipped = 0;
      this.pathCount = 0;
      this.pattern = this.convertPattern(stringPattern);
      this.flippedPattern = horizontalFlip ? this.convertFlippedPattern(stringPattern) : null;
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @abstract
     * @returns {number}
     */
    getMinRequiredPathSteps() {
    }
    /**
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @param {number} templateCol The col index in the template of the current path step
     * @param {number} templateRow The row index in the template of the current path step
     * @param {Array.<Array.<number>>} template The template grid.
     * @returns {PathPlan}
     */
    getPlanIfMatch(path, pathIndex, templateCol, templateRow, template) {
      if (this.isMatch(templateCol, templateRow, template, this.pattern, this.startCol, this.startRow, this.endCol, this.endRow)) {
        return this.getPathPlan(path, pathIndex);
      }
      if (!this.flippedPattern) {
        return null;
      }
      if (this.isMatch(templateCol, templateRow, template, this.flippedPattern, this.startColFlipped, this.startRowFlipped, this.endColFlipped, this.endRowFlipped)) {
        return this.getPathPlanFlipped(path, pathIndex);
      }
      return null;
    }
    /**
     * @abstract
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
    }
    /**
     * @abstract
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
    }
    /**
     * @private
     * @param {number} templateCol column index in template that corresponds with current path step col.
     * @param {number} templateRow row index in template that corresponds with current path step row.
     * @param {Array.<Array.<number>>} template The main path template
     * @param {Array.<Array.<number>>} pattern
     * @param {number} patternStartCol
     * @param {number} patternStartRow
     * @param {number} patternEndCol
     * @param {number} patternEndRow
     * @returns {boolean}
     */
    isMatch(templateCol, templateRow, template, pattern, patternStartCol, patternStartRow, patternEndCol, patternEndRow) {
      if (template.length === 0) {
        return false;
      }
      const tOriginCol = templateCol - patternStartCol;
      const tOriginRow = templateRow - patternStartRow;
      if (tOriginCol < 0 || tOriginRow < 0) {
        return false;
      }
      const tValAtStart = template[templateCol][templateRow];
      if (tValAtStart < 0) {
        return false;
      }
      const tEndCol = templateCol + (patternEndCol - patternStartCol);
      const tEndRow = templateRow + (patternEndRow - patternStartRow);
      if (tEndCol >= template.length) {
        return false;
      }
      const templateEndRow = template[tEndCol];
      if (tEndRow >= templateEndRow.length) {
        return false;
      }
      const tValAtEnd = templateEndRow[tEndRow];
      if (tValAtEnd < tValAtStart) {
        return false;
      }
      for (let pCol = 0; pCol < pattern.length; pCol++) {
        const patternRow = pattern[pCol];
        for (let pRow = 0; pRow < patternRow.length; pRow++) {
          const pVal = patternRow[pRow];
          if (pVal === Template.IGNORE || pVal === Template.START || pVal === Template.END) {
            continue;
          }
          const tCol = tOriginCol + pCol;
          const tRow = tOriginRow + pRow;
          if (tCol >= template.length) {
            return false;
          }
          const templateRows = template[tCol];
          if (tRow >= templateRows.length) {
            return false;
          }
          const tVal = templateRows[tRow];
          if (pVal === Template.OPEN_OR_PATH) {
            if (tVal === Template.OPEN || tVal > 0) {
              continue;
            } else {
              return false;
            }
          } else if (pVal === Template.OPEN) {
            if (tVal === Template.OPEN) {
              continue;
            } else {
              return false;
            }
          } else if (pVal === Template.CLOSED) {
            if (tVal === Template.CLOSED) {
              continue;
            } else {
              return false;
            }
          } else if (pVal === Template.PATH) {
            if (tVal < 0) {
              return false;
            }
          } else {
            return false;
          }
        }
      }
      return true;
    }
    // String Pattern:
    // S start
    // P path
    // E end
    // X closed
    // O open
    // . ignore
    /**
     * @private
     * @param {Array.<string>} stringPattern 
     * @returns {Array.<Array.<number>>}
     */
    convertPattern(stringPattern) {
      if (!stringPattern || stringPattern.length === 0) {
        console.log("PathTemplatePattern.convertPattern() Invalid empty string pattern");
        return [];
      }
      const cols = stringPattern[0].length;
      const rows = stringPattern.length;
      const pattern = new Array(cols);
      for (let col = 0; col < cols; col++) {
        const rowArray = new Array(rows);
        rowArray.fill(Template.IGNORE);
        pattern[col] = rowArray;
      }
      for (let row = 0; row < rows; row++) {
        const patternRow = stringPattern[row];
        for (let col = 0; col < cols; col++) {
          const patternChar = patternRow.charAt(col);
          const value2 = this.convertPatternChar(patternChar);
          if (value2 === Template.START) {
            this.startCol = col;
            this.startRow = row;
          } else if (value2 === Template.END) {
            this.endCol = col;
            this.endRow = row;
          } else if (value2 === Template.PATH) {
            this.pathCount++;
          }
          pattern[col][row] = value2;
        }
      }
      return pattern;
    }
    /**
     * @private
     * @param {Array.<string>} stringPattern 
     * @returns {Array.<Array.<number>>}
     */
    convertFlippedPattern(stringPattern) {
      if (!stringPattern || stringPattern.length === 0) {
        console.log("PathTemplatePattern.convertPattern() Invalid empty string pattern");
        return [];
      }
      const cols = stringPattern[0].length;
      const rows = stringPattern.length;
      const pattern = new Array(cols);
      for (let col = 0; col < cols; col++) {
        const rowArray = new Array(rows);
        rowArray.fill(Template.IGNORE);
        pattern[col] = rowArray;
      }
      for (let row = 0; row < rows; row++) {
        const patternRow = stringPattern[row];
        let cc = 0;
        for (let col = cols - 1; col >= 0; col--) {
          const patternChar = patternRow.charAt(col);
          const value2 = this.convertPatternChar(patternChar);
          if (value2 === Template.START) {
            this.startColFlipped = cc;
            this.startRowFlipped = row;
          } else if (value2 === Template.END) {
            this.endColFlipped = cc;
            this.endRowFlipped = row;
          }
          pattern[cc][row] = value2;
          cc++;
        }
      }
      return pattern;
    }
    /**
     * @private
     * @param {string} char 
     * @returns {number}
     */
    convertPatternChar(char) {
      switch (char) {
        case "S":
          return Template.START;
        case "E":
          return Template.END;
        case "P":
          return Template.PATH;
        case "X":
          return Template.CLOSED;
        case "O":
          return Template.OPEN;
        case "8":
          return Template.OPEN_OR_PATH;
        case ".":
          return Template.IGNORE;
      }
      console.log("PathTemplatePattern.convertPatternChar() Invalid char: " + char);
      return Template.IGNORE;
    }
    /**
     * @param {Path} path
     * @param {number} startIndex 
     * @param {number} tileCol 
     * @param {number} tileRow 
     * @returns {number}
     */
    findTilePathIndex(path, startIndex, tileCol, tileRow) {
      for (let i = startIndex; i < path.size; i++) {
        const tile = path.tiles[i];
        const col = tile.getTileCol();
        if (col !== tileCol) {
          continue;
        }
        const row = tile.getTileRow();
        if (row != tileRow) {
          continue;
        }
        return i;
      }
      console.log("PathTemplatePattern.findTilePathIndex() failed to find tile in path.");
      return -1;
    }
    printPattern(pattern) {
      if (pattern.length === 0) {
        console("printPattern() template empty");
        return;
      }
      const rows = pattern[0].length;
      for (let row = 0; row < rows; row++) {
        let s = "";
        for (let col = 0; col < pattern.length; col++) {
          const v = pattern[col][row];
          if (v === Template.IGNORE) {
            s += ".";
          } else if (v === Template.PATH) {
            s += "P";
          } else if (v === Template.OPEN) {
            s += "0";
          } else if (v === Template.OPEN_OR_PATH) {
            s += "8";
          } else if (v === Template.CLOSED) {
            s += "X";
          } else if (v === Template.START) {
            s += "S";
          } else if (v === Template.END) {
            s += "E";
          } else {
            s += "?";
          }
        }
        console.log(s);
      }
    }
    /**
     * @abstract
     * @returns {string}
     */
    toString() {
    }
  };

  // src/model/path/template/PathTemplate.js
  var PathTemplate = class {
    constructor() {
      this.template = this.initializeTemplate(30, 30);
      this.startColIndex = 0;
      this.startRowIndex = 0;
    }
    /**
     * @param {Path} path 
     */
    updateTemplate(path) {
      this.buildTemplate(path);
    }
    /**
     * @param {PathTemplatePattern} pattern
     * @param {Path} path 
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPlanIfPatternMatch(pattern, path, pathIndex) {
      const curr = path.tiles[pathIndex];
      const currCol = curr.getTileCol();
      const currRow = curr.getTileRow();
      const start = path.tiles[0];
      const startCol = start.getTileCol();
      const startRow = start.getTileRow();
      const templateCol = this.startColIndex + (currCol - startCol);
      const templateRow = this.startRowIndex + (currRow - startRow);
      return pattern.getPlanIfMatch(path, pathIndex, templateCol, templateRow, this.template);
    }
    /**
     * @private
     * @param {Path} path 
     */
    buildTemplate(path) {
      if (path.size < 2) {
        return;
      }
      const step0 = path.tiles[0];
      let minCol = step0.getTileCol();
      let maxCol = minCol;
      let minRow = step0.getTileRow();
      let maxRow = minRow;
      for (let i = 1; i < path.size; i++) {
        const step = path.tiles[i];
        const col2 = step.getTileCol();
        const row2 = step.getTileRow();
        minCol = Math.min(minCol, col2);
        maxCol = Math.max(maxCol, col2);
        minRow = Math.min(minRow, row2);
        maxRow = Math.max(maxRow, row2);
      }
      minCol--;
      minRow--;
      maxCol += 2;
      maxRow += 2;
      const deltaCol = maxCol - minCol;
      const deltaRow = maxRow - minRow;
      this.growAndClearTemplate(deltaCol, deltaRow);
      const startTile = path.tiles[0];
      this.startColIndex = startTile.getTileCol() - minCol;
      this.startRowIndex = startTile.getTileRow() - minRow;
      let col = this.startColIndex;
      let row = this.startRowIndex;
      this.populateTileAndNeighbors(startTile, col, row, 0);
      let prev = startTile;
      for (let i = 1; i < path.size; i++) {
        const curr = path.tiles[i];
        col += curr.getTileCol() - prev.getTileCol();
        row += curr.getTileRow() - prev.getTileRow();
        this.populateTileAndNeighbors(curr, col, row, i);
        prev = curr;
      }
    }
    /**
     * @private
     * @param {number} cols 
     * @param {number} rows 
     * @returns {Array.<number>}
     */
    initializeTemplate(cols, rows) {
      const template = new Array(cols);
      for (let col = 0; col < cols; col++) {
        const rowArray = new Array(rows);
        rowArray.fill(Template.IGNORE);
        template[col] = rowArray;
      }
      return template;
    }
    /**
     * @private
     * @param {number} newCols
     * @param {number} newRows
     */
    growAndClearTemplate(newCols, newRows) {
      const currentCols = this.template.length;
      const currentRows = this.template[0].length;
      let grew = false;
      if (currentRows < newRows) {
        for (let col = 0; col < this.template.length; col++) {
          const rowArray = this.template[col];
          const currLen = rowArray.length;
          rowArray.length = newRows;
          for (let row = currLen; row < newRows; row++) {
            rowArray[row] = Template.IGNORE;
          }
        }
        grew = true;
      }
      if (currentCols < newCols) {
        this.template.length = newCols;
        const rowSize = Math.max(currentRows, newRows);
        for (let col = currentCols; col < newCols; col++) {
          const rowArray = new Array(rowSize);
          for (let row = 0; row < rowSize; row++) {
            rowArray[row] = Template.IGNORE;
          }
          this.template[col] = rowArray;
        }
        grew = true;
      }
      for (let col = 0; col < this.template.length; col++) {
        const rowArray = this.template[col];
        rowArray.fill(Template.IGNORE);
      }
      if (grew) {
        console.log("PathTemplate grew. [" + this.template.length + "][" + this.template[0].length + "]");
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @param {number} col 
     * @param {number} row 
     * @param {number} pathIndex
     */
    populateTileAndNeighbors(tile, col, row, pathIndex) {
      if (tile.open) {
        this.template[col][row] = pathIndex;
      } else {
        this.template[col][row] = Template.CLOSED;
      }
      if (this.template[col][row - 1] === Template.IGNORE) {
        const neighbor = tile.getNeighborTop();
        if (neighbor) {
          this.template[col][row - 1] = neighbor.open ? Template.OPEN : Template.CLOSED;
        }
      }
      if (this.template[col][row + 1] === Template.IGNORE) {
        const neighbor = tile.getNeighborBottom();
        if (neighbor) {
          this.template[col][row + 1] = neighbor.open ? Template.OPEN : Template.CLOSED;
        }
      }
      if (this.template[col - 1][row] === Template.IGNORE) {
        const neighbor = tile.getNeighborLeft();
        if (neighbor) {
          this.template[col - 1][row] = neighbor.open ? Template.OPEN : Template.CLOSED;
        }
      }
      if (this.template[col + 1][row] === Template.IGNORE) {
        const neighbor = tile.getNeighborRight();
        if (neighbor) {
          this.template[col + 1][row] = neighbor.open ? Template.OPEN : Template.CLOSED;
        }
      }
      if (this.template[col - 1][row - 1] === Template.IGNORE) {
        const neighbor = tile.getNeighborTopLeft();
        if (neighbor) {
          this.template[col - 1][row - 1] = neighbor.open ? Template.OPEN : Template.CLOSED;
        }
      }
      if (this.template[col + 1][row - 1] === Template.IGNORE) {
        const neighbor = tile.getNeighborTopRight();
        if (neighbor) {
          this.template[col + 1][row - 1] = neighbor.open ? Template.OPEN : Template.CLOSED;
        }
      }
      if (this.template[col - 1][row - 1] === Template.IGNORE) {
        const neighbor = tile.getNeighborBottomLeft();
        if (neighbor) {
          this.template[col - 1][row - 1] = neighbor.open ? Template.OPEN : Template.CLOSED;
        }
      }
      if (this.template[col + 1][row - 1] === Template.IGNORE) {
        const neighbor = tile.getNeighborBottomRight();
        if (neighbor) {
          this.template[col + 1][row - 1] = neighbor.open ? Template.OPEN : Template.CLOSED;
        }
      }
    }
    // testSquare(situationText) {
    //     // test that each row is the same length
    //     let square = true;
    //     let len = this.template[0].length;
    //     for (let col = 1; col < this.template.length; col++) {
    //         const len2 = this.template[col].length;
    //         if (len !== len2) {
    //             console.log('growTemplate row length mismatch!  len=' + len + ' vs len2=' + len2);
    //             square = false;
    //         }                
    //     }
    //     if (square) {
    //         console.log('template is square.  situation=' + situationText);
    //     }
    //     else {
    //         console.log('template NOT square!!!!!!!!!! situation=' + situationText);
    //     }
    // }
    // printTemplate() {
    //     if (this.template.length === 0) {
    //         console.log('printTemplate() template empty');
    //         return;
    //     }
    //     const rows = this.template[0].length;
    //     for (let row = 0; row < rows; row++) {
    //         let s = '';
    //         for (let col = 0; col < this.template.length; col++) {
    //             const v = this.template[col][row];
    //             if (col === this.startColIndex && row === this.startRowIndex) {
    //                 s += 'S';
    //             }
    //             else if (v === Template.IGNORE) {
    //                 s += '.';
    //             }
    //             else if (v === Template.OPEN) {
    //                 s += 'o';
    //             }
    //             else if (v === Template.CLOSED) {
    //                 s += 'x';
    //             }
    //             else if (v > 0) { // <-- path 
    //                 s += v.toString();
    //             }
    //             else {
    //                 s += '?';
    //                 console.log('bad val: ' + v);
    //             }
    //         }
    //         console.log(s + ' r=' + row);
    //     }
    // }
  };

  // src/model/path/plan/PathPlanFallDownRight.js
  var PathPlanFallDownRight = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      super(startTile, endTile, pathSteps);
      this.landCoordinate = new Vector();
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      const fallCoordinate = this.startTile.origin;
      const fallCoordinateX = fallCoordinate.x + Settings.tile.size + Settings.character.halfWidth;
      if (character.position.worldCoordinateCenter.x < fallCoordinateX) {
        this.walkRightToCenterX(character, frameTimeRatio, fallCoordinateX);
        return false;
      }
      this.landCoordinate.copy(this.endTile.origin);
      this.landCoordinate.addXY(Settings.tile.halfSize, 0);
      if (character.position.worldCoordinateCenter.x < this.endTile.origin.x || character.position.worldCoordinateOrigin.y < this.endTile.origin.y) {
        this.fallDownAndRight(character, frameTimeRatio, this.landCoordinate);
        return false;
      }
      this.assertEndTileReached(character, this.endTile);
      return true;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "FallDownRight(" + this.pathSteps + ")";
    }
  };

  // src/model/path/plan/PathPlanFallDownLeft.js
  var PathPlanFallDownLeft = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      super(startTile, endTile, pathSteps);
      this.landCoordinate = new Vector(0, 0);
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      const fallCoordinate = this.startTile.origin;
      const fallCoordinateX = fallCoordinate.x - Settings.character.halfWidth;
      if (character.position.worldCoordinateCenter.x > fallCoordinateX) {
        this.walkLeftToCenterX(character, frameTimeRatio, fallCoordinateX);
        return false;
      }
      this.landCoordinate.copy(this.endTile.origin);
      this.landCoordinate.addXY(Settings.tile.halfSize, 0);
      if (character.position.worldCoordinateCenter.x > this.landCoordinate.x || character.position.worldCoordinateOrigin.y < this.endTile.origin.y) {
        this.fallDownAndLeft(character, frameTimeRatio, this.landCoordinate);
        return false;
      }
      this.assertEndTileReached(character, this.endTile);
      return true;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "FallDownLeft(" + this.pathSteps + ")";
    }
  };

  // src/model/path/template/PatternFallDown2Side1.js
  var PatternFallDown2Side1 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "S8",
          // start   o|p
          "X8",
          // closed  o|p
          ".E"
          // ignore  end
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 3;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 1;
      const targetRow = start.getTileRow() + 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanFallDownRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 1;
      const targetRow = start.getTileRow() + 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanFallDownLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternFallDown2Side1";
    }
  };

  // src/model/path/plan/PathPlanJumpDownLeft.js
  var PathPlanJumpDownLeft = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      super(startTile, endTile, pathSteps);
      this.jumpCoordinate = new Vector(0, 0);
      this.landCoordinate = new Vector(0, 0);
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      this.jumpCoordinate.copy(this.startTile.origin);
      this.jumpCoordinate.subtractXY(Settings.character.halfWidth, 0);
      const jumpCoordinateX = this.jumpCoordinate.x;
      if (character.position.worldCoordinateCenter.x > jumpCoordinateX) {
        this.walkLeftToCenterX(character, frameTimeRatio, jumpCoordinateX);
        return false;
      }
      this.landCoordinate.copy(this.endTile.origin);
      this.landCoordinate.addXY(Settings.tile.halfSize, 0);
      if (character.position.worldCoordinateCenter.x > this.landCoordinate.x || character.position.worldCoordinateOrigin.y < this.endTile.origin.y) {
        this.jumpDownAndLeft(character, frameTimeRatio, this.jumpCoordinate, this.landCoordinate);
        return false;
      }
      this.assertEndTileReached(character, this.endTile);
      return true;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "JumpDownLeft(" + this.pathSteps + ")";
    }
  };

  // src/model/path/plan/PathPlanJumpDownRight.js
  var PathPlanJumpDownRight = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      super(startTile, endTile, pathSteps);
      this.jumpCoordinate = new Vector(0, 0);
      this.landCoordinate = new Vector(0, 0);
    }
    /**
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      this.jumpCoordinate.copy(this.startTile.origin);
      this.jumpCoordinate.addXY(Settings.tile.size + Settings.character.halfWidth, 0);
      const jumpCoordinateX = this.jumpCoordinate.x;
      if (character.position.worldCoordinateCenter.x < jumpCoordinateX) {
        this.walkRightToCenterX(character, frameTimeRatio, jumpCoordinateX);
        return false;
      }
      this.landCoordinate.copy(this.endTile.origin);
      this.landCoordinate.addXY(Settings.tile.halfSize, 0);
      if (character.position.worldCoordinateCenter.x < this.landCoordinate.x || character.position.worldCoordinateOrigin.y < this.endTile.origin.y) {
        this.jumpDownAndRight(character, frameTimeRatio, this.jumpCoordinate, this.landCoordinate);
        return false;
      }
      this.assertEndTileReached(character, this.endTile);
      return true;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "JumpDownRight(" + this.pathSteps + ")";
    }
  };

  // src/model/path/template/PatternJumpDown1Side2.js
  var PatternJumpDown1Side2 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          ".O.",
          // ignore   open    ignore
          "S88",
          // start    o|p     o|p
          "X8E"
          // closed   o|p     end
          //'..X'      // ignore  ignore  closed
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 3;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 2;
      const targetRow = start.getTileRow() + 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpDownRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 2;
      const targetRow = start.getTileRow() + 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpDownLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpDown1Side2";
    }
  };

  // src/model/path/template/PatternJumpDown1Side3.js
  var PatternJumpDown1Side3 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          ".OO.",
          // ignore   open    open    ignore
          "S888",
          // start    o|p     o|p     o|p
          "X88E"
          // closed   o|p     o|p     end
          //'...X'    // ignore   ignore  ignore  closed
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 4;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 3;
      const targetRow = start.getTileRow() + 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 4, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpDownRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 3;
      const targetRow = start.getTileRow() + 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 4, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpDownLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpDown1Side3";
    }
  };

  // src/model/path/template/PatternJumpDown1Side4.js
  var PatternJumpDown1Side4 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          ".OO..",
          // ignore   open    open    ignore   ignore
          "S8888",
          // start    o|p     o|p     o|p      o|p
          "X.88E"
          // closed   o|p     o|p     o|p      end
          //'....X'      // ignore   ignore  ignore  ignore   closed
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 5;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 4;
      const targetRow = start.getTileRow() + 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 5, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpDownRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 4;
      const targetRow = start.getTileRow() + 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 5, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpDownLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpDown1Side4";
    }
  };

  // src/model/path/plan/PathPlanJumpLeft.js
  var PathPlanJumpLeft = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     * @param {number} jumpHeight
     */
    constructor(startTile, endTile, pathSteps, jumpHeight) {
      super(startTile, endTile, pathSteps);
      this.jumpCoordinate = new Vector(0, 0);
      this.landCoordinate = new Vector(0, 0);
      this.jumpHeight = jumpHeight;
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      this.jumpCoordinate.copy(this.startTile.origin);
      this.jumpCoordinate.subtractXY(Settings.character.halfWidth, 0);
      const jumpCoordinateX = this.jumpCoordinate.x;
      if (character.position.worldCoordinateCenter.x > jumpCoordinateX) {
        this.walkLeftToCenterX(character, frameTimeRatio, jumpCoordinateX);
        return false;
      }
      this.landCoordinate.copy(this.endTile.origin);
      this.landCoordinate.addXY(Settings.tile.halfSize, 0);
      if (character.position.worldCoordinateCenter.x > this.landCoordinate.x || character.position.worldCoordinateOrigin.y < this.endTile.origin.y) {
        this.jumpLeft(character, frameTimeRatio, this.jumpCoordinate, this.landCoordinate, this.jumpHeight);
        return false;
      }
      this.assertEndTileReached(character, this.endTile);
      return true;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "JumpLeft(" + this.pathSteps + ")";
    }
  };

  // src/model/path/plan/PathPlanJumpRight.js
  var PathPlanJumpRight = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     * @param {number} jumpHeight
     */
    constructor(startTile, endTile, pathSteps, jumpHeight) {
      super(startTile, endTile, pathSteps);
      this.jumpCoordinate = new Vector(0, 0);
      this.landCoordinate = new Vector(0, 0);
      this.jumpHeight = jumpHeight;
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      this.jumpCoordinate.copy(this.startTile.origin);
      this.jumpCoordinate.addXY(Settings.tile.size + Settings.character.halfWidth, 0);
      const jumpCoordinateX = this.jumpCoordinate.x;
      if (character.position.worldCoordinateCenter.x < jumpCoordinateX) {
        this.walkRightToCenterX(character, frameTimeRatio, jumpCoordinateX);
        return false;
      }
      this.landCoordinate.copy(this.endTile.origin);
      this.landCoordinate.addXY(Settings.tile.halfSize, 0);
      if (character.position.worldCoordinateCenter.x < this.landCoordinate.x || character.position.worldCoordinateOrigin.y < this.endTile.origin.y) {
        this.jumpRight(character, frameTimeRatio, this.jumpCoordinate, this.landCoordinate, this.jumpHeight);
        return false;
      }
      this.assertEndTileReached(character, this.endTile);
      return true;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "JumpRight(" + this.pathSteps + ")";
    }
  };

  // src/model/path/template/PatternJump0Side2.js
  var PatternJump0Side2 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          ".O.",
          // ignore   open   ignore
          "S8E",
          // start    o|p    end
          "X8."
          //  ignore   o|p    ignore
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 2;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 2;
      const targetRow = start.getTileRow();
      const endIndex = this.findTilePathIndex(path, pathIndex + 2, targetCol, targetRow);
      if (endIndex < 0) {
        console.log("PathTemplatePatternJumpSide2() getPathPlan() failed to find end tile");
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpRight(start, end, steps, Settings.tile.halfSize);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 2;
      const targetRow = start.getTileRow();
      const endIndex = this.findTilePathIndex(path, pathIndex + 2, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpLeft(start, end, steps, Settings.tile.halfSize);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJump0Side2";
    }
  };

  // src/model/path/template/PatternJump0Side3.js
  var PatternJump0Side3 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          ".OO.",
          // ignore open   open   ignore
          "S88E",
          // start  o|p    o|p    end
          "X88."
          //  closed o|p    o|p    closed
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 3;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 3;
      const targetRow = start.getTileRow();
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpRight(start, end, steps, Settings.tile.threeQuarterSize);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 3;
      const targetRow = start.getTileRow();
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpLeft(start, end, steps, Settings.tile.threeQuarterSize);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJump0Side3";
    }
  };

  // src/model/path/template/PatternJump0Side4.js
  var PatternJump0Side4 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          ".OOO.",
          // ignore open   open    open   ignore
          "S8.8E",
          // start  o|p    o|p     o|p    end
          "X8.8."
          //  closed o|p    .       o|p    closed
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 4;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 4;
      const targetRow = start.getTileRow();
      const endIndex = this.findTilePathIndex(path, pathIndex + 4, targetCol, targetRow);
      if (endIndex < 0) {
        console.log("PatternJump0Side4 getPathPlan failed to find end index");
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpRight(start, end, steps, Settings.tile.size);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 4;
      const targetRow = start.getTileRow();
      const endIndex = this.findTilePathIndex(path, pathIndex + 4, targetCol, targetRow);
      if (endIndex < 0) {
        console.log("PatternJump0Side4 getPathPlanFlipped failed to find end index");
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpLeft(start, end, steps, Settings.tile.size);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJump0Side4";
    }
  };

  // src/model/path/plan/PathPlanJumpUpLeft.js
  var PathPlanJumpUpLeft = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      super(startTile, endTile, pathSteps);
      this.jumpCoordinate = new Vector(0, 0);
      this.landCoordinate = new Vector(0, 0);
    }
    /**
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      this.jumpCoordinate.copy(this.startTile.origin);
      this.jumpCoordinate.addXY(Settings.tile.halfSize, 0);
      const jumpCoordinateX = this.jumpCoordinate.x;
      if (character.position.worldCoordinateCenter.x > jumpCoordinateX) {
        this.walkLeftToCenterX(character, frameTimeRatio, jumpCoordinateX);
        return false;
      }
      this.landCoordinate.copy(this.endTile.origin);
      this.landCoordinate.addXY(Settings.tile.halfSize, 0);
      if (character.position.worldCoordinateCenter.x > this.landCoordinate.x) {
        this.jumpUpAndLeft(character, frameTimeRatio, this.jumpCoordinate, this.landCoordinate);
        return false;
      }
      this.assertEndTileReached(character, this.endTile);
      return true;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "JumpUpLeft(" + this.pathSteps + ")";
    }
  };

  // src/model/path/plan/PathPlanJumpUpRight.js
  var PathPlanJumpUpRight = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      super(startTile, endTile, pathSteps);
      this.jumpCoordinate = new Vector(0, 0);
      this.landCoordinate = new Vector(0, 0);
    }
    /**
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      this.jumpCoordinate.copy(this.startTile.origin);
      this.jumpCoordinate.addXY(Settings.tile.halfSize, 0);
      const jumpCoordinateX = this.jumpCoordinate.x;
      if (character.position.worldCoordinateCenter.x < jumpCoordinateX) {
        this.walkRightToCenterX(character, frameTimeRatio, jumpCoordinateX);
        return false;
      }
      this.landCoordinate.copy(this.endTile.origin);
      this.landCoordinate.addXY(Settings.tile.halfSize, 0);
      if (character.position.worldCoordinateCenter.x < this.landCoordinate.x) {
        this.jumpUpAndRight(character, frameTimeRatio, this.jumpCoordinate, this.landCoordinate);
        return false;
      }
      this.assertEndTileReached(character, this.endTile);
      return true;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "JumpUpRight(" + this.pathSteps + ")";
    }
  };

  // src/model/path/template/PatternJumpUp1Side2.js
  var PatternJumpUp1Side2 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "88E",
          // ignore   o|p     end
          "SX."
          // start    o|p     closed
          //'X..'     //  closed   ignore  ignore
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 3;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 2;
      const targetRow = start.getTileRow() - 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 2;
      const targetRow = start.getTileRow() - 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpUp1Side2";
    }
  };

  // src/model/path/template/PatternJumpUp1Side3.js
  var PatternJumpUp1Side3 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "888E",
          // ignore   o|p     o|p     end
          "S8X."
          // start    o|p     o|p     closed
          //'X...'     //  closed   ignore  ignore  ignore
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 4;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 3;
      const targetRow = start.getTileRow() - 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 4, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 3;
      const targetRow = start.getTileRow() - 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 4, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpUp1Side3";
    }
  };

  // src/model/path/plan/PathPlanWalkLeft.js
  var PathPlanWalkLeft = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      super(startTile, endTile, pathSteps);
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      const endTileCenterX = this.endTile.origin.x + Settings.tile.halfSize;
      const result = this.walkLeftToCenterX(character, frameTimeRatio, endTileCenterX);
      if (result) {
        this.assertEndTileReached(character, this.endTile);
      }
      return result;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "WalkLeft(" + this.pathSteps + ")";
    }
  };

  // src/model/path/plan/PathPlanWalkRight.js
  var PathPlanWalkRight = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      super(startTile, endTile, pathSteps);
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      const endTileCenterX = this.endTile.origin.x + Settings.tile.halfSize;
      const result = this.walkRightToCenterX(character, frameTimeRatio, endTileCenterX);
      if (result) {
        this.assertEndTileReached(character, this.endTile);
      }
      return result;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "WalkRight(" + this.pathSteps + ")";
    }
  };

  // src/model/path/template/PatternWalkSide2.js
  var PatternWalkSide2 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "SPE",
          // start  path   end
          "XXX"
          // closed closed closed
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 2;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const end = path.tiles[pathIndex + 2];
      return new PathPlanWalkRight(start, end, 2);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const end = path.tiles[pathIndex + 2];
      return new PathPlanWalkLeft(start, end, 2);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternWalkSide2";
    }
  };

  // src/model/path/template/PatternWalkSide4.js
  var PatternWalkSide4 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "SPPPE",
          // start  path   path   path   end
          "XXXXX"
          // closed closed closed closed closed
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 4;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const end = path.tiles[pathIndex + 4];
      return new PathPlanWalkRight(start, end, 4);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const end = path.tiles[pathIndex + 4];
      return new PathPlanWalkLeft(start, end, 4);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternWalkSide4";
    }
  };

  // src/model/path/plan/PathPlanFallDown.js
  var PathPlanFallDown = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      super(startTile, endTile, pathSteps);
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      const result = this.fallDown(character, frameTimeRatio, this.endTile);
      if (result) {
        this.assertEndTileReached(character, this.endTile);
      }
      return result;
    }
    /**
     * @override
     * @return {boolean} True if this plan requires that the character be standing on top of a solid tile when it starts.
     */
    isSolidFloorRequiredAtStart() {
      return false;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "FallDown(" + this.pathSteps + ")";
    }
  };

  // src/model/path/plan/PathPlanJumpUp.js
  var PathPlanJumpUp = class extends PathPlan {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     */
    constructor(startTile, endTile, pathSteps) {
      super(startTile, endTile, pathSteps);
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      const result = this.jumpUp(character, frameTimeRatio, this.endTile);
      if (result) {
        this.assertEndTileReached(character, this.endTile);
      }
      return result;
    }
    /**
     * @returns {String}
     */
    toString() {
      return "JumpUp(" + this.pathSteps + ")";
    }
  };

  // src/model/path/template/PatternJumpUp1Side1.js
  var PatternJumpUp1Side1 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "8E",
          // ignore   o|p     end
          "S."
          // start    o|p     closed
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 2;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 1;
      const targetRow = start.getTileRow() - 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 2, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 1;
      const targetRow = start.getTileRow() - 1;
      const endIndex = this.findTilePathIndex(path, pathIndex + 2, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpUp1Side1";
    }
  };

  // src/model/path/template/PatternJumpUp2Side3.js
  var PatternJumpUp2Side3 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          ".88E",
          // ignore   o|p     o|p     end
          "888X",
          // o|p      o|p     o|p     closed
          "S8.."
          //  start    o|p     ignore  ignore
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 5;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 3;
      const targetRow = start.getTileRow() - 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 5, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 3;
      const targetRow = start.getTileRow() - 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 5, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpUp2Side3";
    }
  };

  // src/model/path/template/PatternJumpUp2Side2.js
  var PatternJumpUp2Side2 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          ".8E",
          // ignore   o|p     end
          "88.",
          // o|p      o|p     closed
          "S.."
          //  start    ignore  ignore
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 4;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 2;
      const targetRow = start.getTileRow() - 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 4, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 2;
      const targetRow = start.getTileRow() - 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 4, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpUp2Side2";
    }
  };

  // src/model/path/template/PatternJumpUp2Side1.js
  var PatternJumpUp2Side1 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "8E",
          // ignore   o|p     end
          "8.",
          // o|p      o|p     closed
          "S."
          //  start    ignore  ignore
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 3;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 1;
      const targetRow = start.getTileRow() - 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 1;
      const targetRow = start.getTileRow() - 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUpLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpUp2Side1";
    }
  };

  // src/model/path/template/PatternJumpDown2Side3.js
  var PatternJumpDown2Side3 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          ".OO.",
          // ignore   open    open    ignore
          "S888",
          // start    o|p     o|p     o|p
          "X.88",
          // closed   o|p     o|p     end
          "...E",
          // closed   o|p     o|p     end
          "...X"
          // ignore   ignore  ignore  closed
        ],
        true
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 5;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() + 3;
      const targetRow = start.getTileRow() + 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 5, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpDownRight(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol() - 3;
      const targetRow = start.getTileRow() + 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 5, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpDownLeft(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpDown2Side3";
    }
  };

  // src/model/path/template/PatternJumpUp2.js
  var PatternJumpUp2 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "E",
          // end
          "8",
          // o|p
          "S"
          // start
        ],
        false
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 2;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol();
      const targetRow = start.getTileRow() - 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 2, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUp(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol();
      const targetRow = start.getTileRow() - 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUp(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpUp2";
    }
  };

  // src/model/path/template/PatternJumpUp3.js
  var PatternJumpUp3 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "E",
          // end
          "8",
          // o|p
          "8",
          // o|p
          "S"
          // start
        ],
        false
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 3;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol();
      const targetRow = start.getTileRow() - 3;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUp(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol();
      const targetRow = start.getTileRow() - 3;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanJumpUp(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternJumpUp3";
    }
  };

  // src/model/path/template/PatternFallDown2.js
  var PatternFallDown2 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "S",
          // start
          "8",
          // o|p
          "E"
          // end
        ],
        false
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 2;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol();
      const targetRow = start.getTileRow() + 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 2, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanFallDown(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol();
      const targetRow = start.getTileRow() + 2;
      const endIndex = this.findTilePathIndex(path, pathIndex + 2, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanFallDown(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternFallDown2";
    }
  };

  // src/model/path/template/PatternFallDown3.js
  var PatternFallDown3 = class extends PathTemplatePattern {
    constructor() {
      super(
        [
          "S",
          // start
          "8",
          // o|p
          "8",
          // o|p
          "E"
          // end
        ],
        false
      );
    }
    /**
     * Returns the minimum number of path steps required by this pattern to be applied.
     * @override
     * @returns {number}
     */
    getMinRequiredPathSteps() {
      return 3;
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlan(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol();
      const targetRow = start.getTileRow() + 3;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanFallDown(start, end, steps);
    }
    /**
     * @override
     * @param {Path} path
     * @param {number} pathIndex The path index.
     * @returns {PathPlan}
     */
    getPathPlanFlipped(path, pathIndex) {
      const start = path.tiles[pathIndex];
      const targetCol = start.getTileCol();
      const targetRow = start.getTileRow() + 3;
      const endIndex = this.findTilePathIndex(path, pathIndex + 3, targetCol, targetRow);
      if (endIndex < 0) {
        return null;
      }
      const end = path.tiles[endIndex];
      const steps = endIndex - pathIndex;
      return new PathPlanFallDown(start, end, steps);
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "PatternFallDown3";
    }
  };

  // src/model/path/plan/PathPlanMineAndWalkLeft.js
  var PathPlanMineAndWalkLeft = class extends PathPlanWalkLeft {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     * @param {TileMinedLogic} tileMinedLogic
     * @param {boolean} tileHealthNegligible
     */
    constructor(startTile, endTile, pathSteps, tileMinedLogic, tileHealthNegligible) {
      super(startTile, endTile, pathSteps);
      this.tileMinedLogic = tileMinedLogic;
      this.tileHealthNegligible = tileHealthNegligible;
      this.miningThisTurn = false;
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      if (!this.endTile.open) {
        if (this.tileHealthNegligible) {
          this.tileMinedLogic.mineTileIstantly(character, this.endTile);
        } else {
          character.setCharacterAction(CharacterAction.MINE);
          this.miningThisTurn = true;
          if (character.position.worldCoordinateOrigin.x !== this.endTile.origin.x) {
            character.position.facingLeft = character.position.worldCoordinateOrigin.x > this.endTile.origin.x;
          }
          if (!turnStart) {
            return false;
          }
          this.tileMinedLogic.mineTileForTurn(character, this.endTile);
          return false;
        }
      } else if (this.miningThisTurn) {
        if (turnStart) {
          this.miningThisTurn = false;
        } else {
          return false;
        }
      }
      return super.executePlan(character, frameTimeRatio, turnStart);
    }
    /**
     * @returns {String}
     */
    toString() {
      return "MineAndWalkLeft(" + this.pathSteps + ")";
    }
  };

  // src/model/path/plan/PathPlanMineAndWalkRight.js
  var PathPlanMineAndWalkRight = class extends PathPlanWalkRight {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     * @param {TileMinedLogic} tileMinedLogic
     * @param {boolean} tileHealthNegligible
     */
    constructor(startTile, endTile, pathSteps, tileMinedLogic, tileHealthNegligible) {
      super(startTile, endTile, pathSteps);
      this.tileMinedLogic = tileMinedLogic;
      this.tileHealthNegligible = tileHealthNegligible;
      this.miningThisTurn = false;
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      if (!this.endTile.open) {
        if (this.tileHealthNegligible) {
          this.tileMinedLogic.mineTileIstantly(character, this.endTile);
        } else {
          character.setCharacterAction(CharacterAction.MINE);
          this.miningThisTurn = true;
          if (character.position.worldCoordinateOrigin.x !== this.endTile.origin.x) {
            character.position.facingLeft = character.position.worldCoordinateOrigin.x > this.endTile.origin.x;
          }
          if (!turnStart) {
            return false;
          }
          this.tileMinedLogic.mineTileForTurn(character, this.endTile);
          return false;
        }
      } else if (this.miningThisTurn) {
        if (turnStart) {
          this.miningThisTurn = false;
        } else {
          return false;
        }
      }
      return super.executePlan(character, frameTimeRatio, turnStart);
    }
    /**
     * @returns {String}
     */
    toString() {
      return "MineAndWalkRight(" + this.pathSteps + ")";
    }
  };

  // src/model/path/plan/PathPlanMineAndJumpUp.js
  var PathPlanMineAndJumpUp = class extends PathPlanJumpUp {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     * @param {TileMinedLogic} tileMinedLogic
     * @param {boolean} tileHealthNegligible
     */
    constructor(startTile, endTile, pathSteps, tileMinedLogic, tileHealthNegligible) {
      super(startTile, endTile, pathSteps);
      this.tileMinedLogic = tileMinedLogic;
      this.tileHealthNegligible = tileHealthNegligible;
      this.miningThisTurn = false;
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      if (!this.endTile.open) {
        if (this.tileHealthNegligible) {
          this.tileMinedLogic.mineTileIstantly(character, this.endTile);
        } else {
          character.setCharacterAction(CharacterAction.MINE);
          this.miningThisTurn = true;
          if (character.position.worldCoordinateOrigin.x !== this.endTile.origin.x) {
            character.position.facingLeft = character.position.worldCoordinateOrigin.x > this.endTile.origin.x;
          }
          if (!turnStart) {
            return false;
          }
          this.tileMinedLogic.mineTileForTurn(character, this.endTile);
          return false;
        }
      } else if (this.miningThisTurn) {
        if (turnStart) {
          this.miningThisTurn = false;
        } else {
          return false;
        }
      }
      return super.executePlan(character, frameTimeRatio, turnStart);
    }
    /**
     * @returns {string}
     */
    toString() {
      return "MineAndJumpUp(" + this.pathSteps + ")";
    }
  };

  // src/model/path/plan/PathPlanMineAndFallDown.js
  var PathPlanMineAndFallDown = class extends PathPlanFallDown {
    /**
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {number} pathSteps
     * @param {TileMinedLogic} tileMinedLogic
     * @param {boolean} tileHealthNegligible
     */
    constructor(startTile, endTile, pathSteps, tileMinedLogic, tileHealthNegligible) {
      super(startTile, endTile, pathSteps);
      this.tileMinedLogic = tileMinedLogic;
      this.tileHealthNegligible = tileHealthNegligible;
      this.miningThisTurn = false;
    }
    /**
     * @override
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart True if this is the start of a turn.
     * @return {boolean} True when the step is completed.
     */
    executePlan(character, frameTimeRatio, turnStart) {
      if (!this.endTile.open) {
        if (this.tileHealthNegligible) {
          this.tileMinedLogic.mineTileIstantly(character, this.endTile);
        } else {
          character.setCharacterAction(CharacterAction.MINE);
          this.miningThisTurn = true;
          if (character.position.worldCoordinateOrigin.x !== this.endTile.origin.x) {
            character.position.facingLeft = character.position.worldCoordinateOrigin.x > this.endTile.origin.x;
          }
          if (!turnStart) {
            return false;
          }
          this.tileMinedLogic.mineTileForTurn(character, this.endTile);
          return false;
        }
      } else if (this.miningThisTurn) {
        if (turnStart) {
          this.miningThisTurn = false;
        } else {
          return false;
        }
      }
      return super.executePlan(character, frameTimeRatio, turnStart);
    }
    /**
     * @returns {String}
     */
    toString() {
      return "MineAndFallDown(" + this.pathSteps + ")";
    }
  };

  // src/model/path/plan/PathPlanEvaluator.js
  var PathPlanEvaluator = class {
    /**
     * 
     * @param {TileMinedLogic} tileMinedLogic 
     */
    constructor(tileMinedLogic) {
      this.tileMinedLogic = tileMinedLogic;
      this.pathTemplate = new PathTemplate();
      this.patterns = [
        /////////////////////////////////
        // 3-Tile jumps
        /////////////////////////////////
        new PatternJump0Side4(),
        // 3-tile jump across horizontal gap
        new PatternJumpDown1Side4(),
        // 3-tile jump across gap, down one tile step
        new PatternJumpUp2Side3(),
        // jump up 2 tiles, across 3.
        new PatternJumpDown2Side3(),
        // jump down 2 tiles, across 3
        /////////////////////////////////
        // 2-tile jumps
        /////////////////////////////////
        new PatternJump0Side3(),
        // 2-tile jump across horizontal gap
        new PatternJumpUp1Side3(),
        // 2-tile jump across gap, up one tile step
        new PatternJumpDown1Side3(),
        // 2-tile jump across gap, down one tile step
        new PatternJumpUp2Side2(),
        // jump up 2 tile step, across 2
        new PatternJumpUp3(),
        // jump up 3 tiles
        new PatternFallDown3(),
        // fall down 3 tiles
        /////////////////////////////////
        // 1-tile jumps
        /////////////////////////////////
        new PatternJump0Side2(),
        // Jump over gap (1 open tiles)
        new PatternJumpUp2Side1(),
        // Jump up 2, across 1.
        new PatternJumpUp1Side2(),
        // Jump up one step, one tile away
        new PatternJumpDown1Side2(),
        // 1-tile jump across gape, down one tile stap.
        new PatternJumpUp1Side1(),
        // 1-tile jump a step.        
        new PatternJumpUp2(),
        // jump up 2 tiles.
        new PatternFallDown2(),
        // fall down 2 tiles.
        new PatternFallDown2Side1(),
        // Fall off edge
        new PatternWalkSide4(),
        // Walk straight long
        new PatternWalkSide2()
        // Walk straight short
      ];
      this.claimedPath = new Array(30);
      this.claimedPath.fill(null);
    }
    /**
     * Connect the path to the existing plan.
     * @param {Path} path
     * @param {Array.<PathPlan>} pathPlan
     * @param {number} startIndex Where the path starts in the existing path plan
     * @param {boolean} tileHealthNegligible
     */
    connectPathToPlan2(path, pathPlan, startIndex, tileHealthNegligible) {
      if (path.size === 0) {
        return;
      }
      this.evaluatePathInternal(path, tileHealthNegligible);
      pathPlan.length = startIndex;
      this.buildPathPlanFromClaimedPath(path, pathPlan, this.claimedPath);
    }
    /**
     * Evaluate the path and figure out the path plan.
     * @param {Path} path
     * @param {Array.<PathPlan>} pathPlan
     * @param {boolean} tileHealthNegligible
     */
    evaluatePath(path, pathPlan, tileHealthNegligible) {
      if (path.size === 0) {
        pathPlan.length = 0;
        return;
      }
      this.evaluatePathInternal(path, tileHealthNegligible);
      pathPlan.length = 0;
      this.buildPathPlanFromClaimedPath(path, pathPlan, this.claimedPath);
    }
    /**
     * @private
     * @param {Path} path
     * @param {Array.<PathPlan>} pathPlan
     * @param {Array.<PathPlan>} claimedPath 
     */
    buildPathPlanFromClaimedPath(path, pathPlan, claimedPath) {
      let prevPlan = null;
      for (let i = 0; i < path.size; i++) {
        const currPlan = claimedPath[i];
        if (currPlan && currPlan !== prevPlan) {
          pathPlan.push(currPlan);
        }
        prevPlan = currPlan;
      }
    }
    /**
     * @private
     * @param {Path} path
     * @param {boolean} tileHealthNegligible
     */
    evaluatePathInternal(path, tileHealthNegligible) {
      if (path.size > this.claimedPath.length) {
        this.claimedPath.length = path.size;
      }
      this.claimedPath.fill(null);
      if (path.size < 3) {
        for (let i = 0; i < path.size - 1; i++) {
          this.addDefaultPlan(path, i, this.claimedPath);
        }
      } else {
        this.pathTemplate.updateTemplate(path);
        for (let i = 0; i < path.size - 1; i++) {
          this.addMinePlan(path, i, this.claimedPath, tileHealthNegligible);
        }
        for (let i = 0; i < this.patterns.length; i++) {
          this.checkPatternAgainstPath(this.patterns[i], path, this.claimedPath);
        }
        for (let i = 0; i < path.size - 1; i++) {
          if (!this.claimedPath[i]) {
            this.addDefaultPlan(path, i, this.claimedPath);
          }
        }
      }
    }
    /**
     * @private
     * @param {PathTemplatePattern} pattern 
     * @param {Path} path 
     * @param {Array.<PathPlan>} claimedPath 
     */
    checkPatternAgainstPath(pattern, path, claimedPath) {
      let i = 0;
      while (i < path.size) {
        if (claimedPath[i]) {
          i++;
          continue;
        }
        const unclaimedSpaceAvailable = this.getUnclaimedSpaceAvailable(claimedPath, path.size, i);
        if (unclaimedSpaceAvailable < pattern.getMinRequiredPathSteps()) {
          i++;
          continue;
        }
        const pathPlan = this.pathTemplate.getPlanIfPatternMatch(pattern, path, i);
        if (pathPlan) {
          const steps = pathPlan.pathSteps;
          if (steps === 0) {
            console.log("PathPlanEvaluator.checkPatternAgainstPath() pattern=" + pattern.toString() + " used no steps");
            i++;
            continue;
          }
          if (steps <= unclaimedSpaceAvailable) {
            for (let j = 0; j < steps; j++) {
              claimedPath[i] = pathPlan;
              i++;
            }
            continue;
          }
        }
        i++;
      }
    }
    /**
     * @private
     * @param {Array.<PathPlan>} claimedPath 
     * @param {number} length The path length
     * @param {number} index 
     * @returns {number}
     */
    getUnclaimedSpaceAvailable(claimedPath, length, index) {
      let count = 0;
      for (let i = index; i < length; i++) {
        if (claimedPath[i] !== null) {
          return count;
        }
        count++;
      }
      return count;
    }
    /**
     * @private
     * @param {Path} path
     * @param {number} index
     * @param {Array.<PathPlan>} claimedPath 
     */
    addDefaultPlan(path, index, claimedPath) {
      const current = path.tiles[index];
      const next = path.tiles[index + 1];
      if (!next.open) {
        this.addMinePlan(path, index, claimedPath);
        return;
      }
      let plan;
      if (current.isNeighborLeft(next)) {
        plan = new PathPlanWalkLeft(current, next, 1);
      } else if (current.isNeighborRight(next)) {
        plan = new PathPlanWalkRight(current, next, 1);
      } else if (current.isNeighborTop(next)) {
        plan = new PathPlanJumpUp(current, next, 1);
      } else if (current.isNeighborBottom(next)) {
        plan = new PathPlanFallDown(current, next, 1);
      } else {
        console.log("addDefaultPlan() neighbor is not adjacent tile");
        this.printPathDebug(path, index);
        return;
      }
      claimedPath[index] = plan;
    }
    /**
     * @param {Path} path 
     * @param {number} index 
     */
    printPathDebug(path, index) {
      console.log("DEBUG BAD INDEX: " + index);
      for (let i = 0; i < path.size; i++) {
        if (i == 0) {
          console.log("DEBUG step=" + i + " " + path.tiles[i].origin.toString());
        } else {
          console.log("DEBUG step=" + i + " " + path.tiles[i].origin.toString() + " adjacent=" + path.tiles[i].isAdjacentTo(path[i - 1]) + " neighbor=" + path.tiles[i].isNeighborTile(path.tiles[i - 1]) + (i === index ? " <-----" : ""));
        }
      }
    }
    /**
     * @private
     * @param {Path} path
     * @param {number} index
     * @param {Array.<PathPlan>} claimedPath 
     * @param {boolean} tileHealthNegligible
     */
    addMinePlan(path, index, claimedPath, tileHealthNegligible) {
      const next = path.tiles[index + 1];
      if (next.open) {
        return;
      }
      const current = path.tiles[index];
      let plan;
      if (current.isNeighborLeft(next)) {
        plan = new PathPlanMineAndWalkLeft(current, next, 1, this.tileMinedLogic, tileHealthNegligible);
      } else if (current.isNeighborRight(next)) {
        plan = new PathPlanMineAndWalkRight(current, next, 1, this.tileMinedLogic, tileHealthNegligible);
      } else if (current.isNeighborTop(next)) {
        plan = new PathPlanMineAndJumpUp(current, next, 1, this.tileMinedLogic, tileHealthNegligible);
      } else if (current.isNeighborBottom(next)) {
        plan = new PathPlanMineAndFallDown(current, next, 1, this.tileMinedLogic, tileHealthNegligible);
      } else {
        console.log("addMinePlan() neighbor is not adjacent tile");
        return;
      }
      claimedPath[index] = plan;
    }
  };

  // src/model/path/PathPlanFinder.js
  var PathPlanFinder = class extends GameModel {
    /**
     * @param {VectorField} vectorField 
     * @param {TileMinedLogic} tileMinedLogic 
     */
    constructor(vectorField, tileMinedLogic) {
      super();
      this.vectorField = vectorField;
      this.pathFinder = new PathFinder();
      this.directLinePathFinder = new DirectLinePathFinder();
      this.pathPlanEvaluator = new PathPlanEvaluator(tileMinedLogic);
      this.path = new Path();
    }
    /**
     * @private
     * @param {GridTile} start 
     * @param {GridTile} destination 
     * @param {Array<PathPlan>} pathPlan The output parameter.
     * @param {boolean} mineThroughWallsEnabled 
     * @param {boolean} ignoreWallPenalty
     */
    findPathPlan(start, destination, pathPlan, mineThroughWallsEnabled, ignoreWallPenalty) {
      this.path.reset();
      PerformanceMetrics.startTime("PathFinding");
      this.pathFinder.findPath(this.path, start, destination, true, mineThroughWallsEnabled, ignoreWallPenalty);
      PerformanceMetrics.endTime("PathFinding");
      if (this.path.size > 0) {
        this.pathPlanEvaluator.evaluatePath(this.path, pathPlan, false);
      } else {
        pathPlan.length = 0;
      }
    }
    // /**
    //  * @private
    //  * @param {Path} path 
    //  */
    // printPath(path) {
    //     let s = '';
    //     for (let i = 0; i < path.size; i++) {
    //         s += 'i=' + i + ':' + path.tiles[i].origin.toString() + '  ';
    //     }
    //     console.log('path=' + s);
    // }
    /**
     * @private
     * @param {GridTile} start 
     * @param {GridTile} destination 
     * @param {Array<PathPlan>} pathPlan The output parameter.
     * @returns {boolean} True if the direct path was found.
     */
    findDirectPathPlan(start, destination, pathPlan) {
      this.path.reset();
      PerformanceMetrics.startTime("DirectPath");
      const result = this.directLinePathFinder.findPath(this.path, start, destination);
      PerformanceMetrics.endTime("DirectPath");
      if (!result) {
        return false;
      }
      if (this.path.size > 0) {
        this.pathPlanEvaluator.evaluatePath(this.path, pathPlan, true);
      } else {
        pathPlan.length = 0;
      }
      return true;
    }
    // /**
    //  * @private
    //  * @param {GridTile} start 
    //  * @param {GridTile} destination 
    //  * @param {Array<PathPlan>} pathPlan The output parameter.
    //  * @returns {boolean}
    //  */
    // findContinuedDirectPathPlan(start, destination, pathPlan) {
    //     // If there is no current path plan, or it is very short, then just find a new path.
    //     if (pathPlan.length < 1) {
    //         //console.log('PathPlanFinder.findContinuedDirectPathPlan() < 1 steps. using normal');
    //         return this.findDirectPathPlan(start, destination, pathPlan);
    //     }
    //     // Check to see if the existing path already goes to the destination.
    //     const pathStep = pathPlan[0];
    //     if (pathStep.endTile === destination) {
    //         pathPlan.length = 1; // chop off the plan after this step.
    //         return true;
    //     }
    //     // We want to keep the closest path step in our plan, so start at the next index.
    //     const bestStartTile = pathStep.endTile;
    //     const continuedStartIndex = 1;
    //     this.path.reset();
    //     // 2. Find path using that tile as the start position.
    //     PerformanceMetrics.startTime('DirectPath');
    //     const result = this.directLinePathFinder.findPath(this.path, bestStartTile, destination); // <-- path is an output variable.
    //     PerformanceMetrics.endTime('DirectPath');
    //     if (!result) {
    //         //console.log('PathPlanFinder.findContinuedDirectPathPlan() failed to find path from best start tile. defaulting to normal.');
    //         return this.findDirectPathPlan(start, destination, pathPlan);
    //     }
    //     // Special case: 1 step in path.
    //     if (this.path.size === 1) {
    //         ///////console.log('DIRECT PATH SIZE 1.  dest=' + destination.origin.toString() + ' path[0]=' + this.path.tiles[0].origin.toString());
    //         // Clear out the path plan.
    //         console.log('PathPlanFinder.findContinuedDirectPathPlan() resulting path length 1');
    //         pathPlan.length = 0;
    //         return;
    //     }
    //     // 3. combine paths
    //     if (this.path.size > 0) {
    //         this.pathPlanEvaluator.connectPathToPlan2(this.path, pathPlan, continuedStartIndex, true); // true = tileHealthNegligible.  always true for direct paths.
    //         return true;
    //     }
    //     else {
    //         console.log('PathPlanFinder.findContinuedDirectPathPlan() did not find a good path.');
    //         pathPlan.length = 0;
    //         return false;
    //     }
    // }
    /**
     * @private
     * @param {GridTile} start 
     * @param {GridTile} destination 
     * @param {Array<PathPlan>} pathPlan The output parameter.
     * @returns {boolean}
     */
    findContinuedDirectPathPlan2(start, destination, pathPlan) {
      if (pathPlan.length < 1) {
        return this.findDirectPathPlan(start, destination, pathPlan);
      }
      const pathStep = pathPlan[0];
      if (pathStep.endTile === destination) {
        pathPlan.length = 1;
        return true;
      }
      this.path.reset();
      PerformanceMetrics.startTime("DirectPath");
      const result = this.directLinePathFinder.findPath(this.path, pathStep.endTile, destination);
      PerformanceMetrics.endTime("DirectPath");
      if (!result) {
        return this.findDirectPathPlan(start, destination, pathPlan);
      }
      if (this.path.size === 1) {
        console.log("PathPlanFinder.findContinuedDirectPathPlan() resulting path length 1");
        pathPlan.length = 0;
        return;
      }
      if (this.path.size > 0) {
        this.pathPlanEvaluator.connectPathToPlan2(this.path, pathPlan, 1, true);
        return true;
      } else {
        console.log("PathPlanFinder.findContinuedDirectPathPlan() did not find a good path.");
        pathPlan.length = 0;
        return false;
      }
    }
    /**
     * This version always starts and the end of the first step in the path plan.
     * @private
     * @param {GridTile} start 
     * @param {GridTile} destination 
     * @param {Array<PathPlan>} pathPlan The output parameter.
     * @param {boolean} mineThroughWallsEnabled 
     * @param {boolean} ignoreWallPenalty
     */
    findContinuedPathPlan2(start, destination, pathPlan, mineThroughWallsEnabled, ignoreWallPenalty) {
      if (pathPlan.length < 1) {
        this.findPathPlan(start, destination, pathPlan, mineThroughWallsEnabled, ignoreWallPenalty);
        return;
      }
      const pathStep = pathPlan[0];
      if (pathStep.endTile === destination) {
        pathPlan.length = 1;
        return true;
      }
      this.path.reset();
      PerformanceMetrics.startTime("PathFinding");
      this.pathFinder.findPath(this.path, pathStep.endTile, destination, true, mineThroughWallsEnabled, ignoreWallPenalty);
      PerformanceMetrics.endTime("PathFinding");
      if (this.path.size === 1) {
        console.log("NORMAL PATH SIZE 1.  dest=" + destination.origin.toString() + " path[0]=" + this.path.tiles[0].origin.toString());
        pathPlan.length = 0;
        return;
      }
      if (this.path.size > 0) {
        this.pathPlanEvaluator.connectPathToPlan2(this.path, pathPlan, 1, ignoreWallPenalty);
      } else {
        console.log("PathPlanFinder.findContinuedPathPlan2() did not find a good path.");
      }
    }
    // /**
    //  * @private
    //  * @param {GridTile} start 
    //  * @param {GridTile} destination 
    //  * @param {Array<PathPlan>} pathPlan The output parameter.
    //  * @returns {boolean}
    //  */
    // findContinuedDirectPathPlan(start, destination, pathPlan) {
    //     // If there is no current path plan, or it is very short, then just find a new path.
    //     if (pathPlan.length < 1) {
    //         //console.log('PathPlanFinder.findContinuedDirectPathPlan() < 1 steps. using normal');
    //         return this.findDirectPathPlan(start, destination, pathPlan);
    //     }
    //     // 1. Find step in the current plan - this is inclusive. We want to keep this step in the new path.
    //     const closestPathStepIndex = this.findClosestPathStepIndex(pathPlan, destination);
    //     if (closestPathStepIndex === -1) {
    //         console.log('PathPlanFinder.findContinuedDirectPathPlan() FAILED to find best start index');
    //         return this.findDirectPathPlan(start, destination, pathPlan);
    //     }
    //     // Check to see if the existing path already goes to the destination.
    //     const pathStep = pathPlan[closestPathStepIndex];
    //     if (pathStep.endTile === destination) {
    //         pathPlan.length = closestPathStepIndex + 1; // chop off the plan after this step.
    //         return true;
    //     }
    //     // We want to keep the closest path step in our plan, so start at the next index.
    //     const bestStartTile = pathStep.endTile;
    //     const continuedStartIndex = closestPathStepIndex + 1;
    //     this.path.reset();
    //     // 2. Find path using that tile as the start position.
    //     PerformanceMetrics.startTime('DirectPath');
    //     const result = this.directLinePathFinder.findPath(this.path, bestStartTile, destination); // <-- path is an output variable.
    //     PerformanceMetrics.endTime('DirectPath');
    //     if (!result) {
    //         //console.log('PathPlanFinder.findContinuedDirectPathPlan() failed to find path from best start tile. defaulting to normal.');
    //         return this.findDirectPathPlan(start, destination, pathPlan);
    //     }
    //     // Special case: 1 step in path.
    //     if (this.path.size === 1) {
    //         ///////console.log('DIRECT PATH SIZE 1.  dest=' + destination.origin.toString() + ' path[0]=' + this.path.tiles[0].origin.toString());
    //         // Clear out the path plan.
    //         console.log('PathPlanFinder.findContinuedDirectPathPlan() resulting path length 1');
    //         pathPlan.length = 0;
    //         return;
    //     }
    //     // 3. combine paths
    //     if (this.path.size > 0) {
    //         //console.log('PathPlanFinder.findContinuedDirectPathPlan() CONNECTING. OLD plan length=' + pathPlan.length + ' index=' + continuedStartIndex + ' NEW path length=' + this.path.size);
    //         this.pathPlanEvaluator.connectPathToPlan2(this.path, pathPlan, continuedStartIndex, true); // true = tileHealthNegligible.  always true for direct paths.
    //         return true;
    //     }
    //     else {
    //         console.log('PathPlanFinder.findContinuedDirectPathPlan() did not find a good path.');
    //         return false;
    //     }
    // }
    // /**
    //  * @private
    //  * @param {GridTile} start 
    //  * @param {GridTile} destination 
    //  * @param {Array<PathPlan>} pathPlan The output parameter.
    //  * @param {boolean} mineThroughWallsEnabled 
    //  * @param {boolean} ignoreWallPenalty
    //  */
    // findContinuedPathPlan(start, destination, pathPlan, mineThroughWallsEnabled, ignoreWallPenalty) {
    //     // If there is no current path plan, then just find a new path.
    //     if (pathPlan.length < 1) {
    //         //console.log('PathPlanFinder.findContinuedPathPlan() defaulting to normal finding');
    //         this.findPathPlan(start, destination, pathPlan, mineThroughWallsEnabled, ignoreWallPenalty);
    //         return;
    //     }
    //     // 1. Find step in the current plan - this is inclusive. We want to keep this step in the new path.
    //     const closestPathStepIndex = this.findClosestPathStepIndex(pathPlan, destination);
    //     if (closestPathStepIndex === -1) {
    //         console.log('PathPlanFinder.findContinuedPathPlan() FAILED to find best start index.');
    //         this.findPathPlan(start, destination, pathPlan, mineThroughWallsEnabled, ignoreWallPenalty);
    //         return;
    //     }
    //     // Check to see if the existing path already goes to the destination.
    //     const pathStep = pathPlan[closestPathStepIndex];
    //     if (pathStep.endTile === destination) {
    //         pathPlan.length = closestPathStepIndex + 1; // chop off the plan after this step.
    //         return true;
    //     }
    //     // We want to keep the closest path step in our plan, so start at the next index.
    //     const bestStartTile = pathStep.endTile;
    //     const continuedStartIndex = closestPathStepIndex + 1;
    //     this.path.reset();
    //     // 2. Find path using that tile as the start position.
    //     PerformanceMetrics.startTime('PathFinding');
    //     this.pathFinder.findPath(this.path, bestStartTile, destination, true, mineThroughWallsEnabled, ignoreWallPenalty); // <-- path is an output variable.
    //     PerformanceMetrics.endTime('PathFinding');
    //     if (this.path.size === 1) {
    //         console.log('NORMAL PATH SIZE 1.  dest=' + destination.origin.toString() + ' path[0]=' + this.path.tiles[0].origin.toString());
    //         // Clear out the path plan.
    //         pathPlan.length = 0;
    //         return;
    //     }
    //     // 3. combine paths
    //     if (this.path.size > 0) {
    //         ///////this.pathPlanEvaluator.evaluatePath(this.path, pathPlan, false);
    //         ////////console.log('PathPlanFinder.findContinuedPathPlan() found path from best start tile, connecting path to plan');
    //         //console.log('PathPlanFinder.findContinuedPathPlan() CONNECTING. OLD plan length=' + pathPlan.length + ' index=' + continuedStartIndex + ' NEW path length=' + this.path.size);
    //         this.pathPlanEvaluator.connectPathToPlan2(this.path, pathPlan, continuedStartIndex, ignoreWallPenalty);
    //     }
    //     else {
    //         console.log('PathPlanFinder.findContinuedPathPlan() did not find a good path.');
    //     }
    // }
    /**
     * @private
     * @param {Array<PathPlan>} pathPlan The output parameter.
     * @param {GridTile} destination 
     * @returns {number}
     */
    findClosestPathStepIndex(pathPlan, destination) {
      let closestTile = null;
      let closestDist2 = 1e6;
      let bestIndex = -1;
      const destOrigin = destination.origin;
      for (let i = 0; i < pathPlan.length; i++) {
        const planStep = pathPlan[i];
        if (!planStep) {
          continue;
        }
        const stepEnd = planStep.endTile;
        if (stepEnd === destination) {
          return i;
        }
        const dist2 = destOrigin.distanceSquared(stepEnd.origin);
        if (!closestTile || closestDist2 > dist2) {
          closestTile = stepEnd;
          closestDist2 = dist2;
          bestIndex = i;
        }
      }
      return bestIndex;
    }
    /**
     * @param {GridTile} start 
     * @param {GridTile} destination 
     * @param {Array<PathPlan>} pathPlan The output parameter.
     */
    findMonsterPathPlan(start, destination, pathPlan) {
      this.findPathPlan(start, destination, pathPlan, true, false);
    }
    // /**
    //  * @param {GridTile} start 
    //  * @param {GridTile} destination 
    //  * @param {Array<PathPlan>} pathPlan The output parameter.
    //  */
    // findPartyCharacterPathPlan(start, destination, pathPlan) {
    //     if (start === destination) {
    //         console.log('findPartyCharacterPathPlan() start == destination.');
    //         pathPlan.length = 0;
    //         return;
    //     }
    //     if (this.vectorField.tileHealthNegligible && this.findContinuedDirectPathPlan(start, destination, pathPlan)) {
    //         return;
    //     }
    //     this.findPathPlan(start, destination, pathPlan, true, this.vectorField.tileHealthNegligible);
    //     ///////this.findContinuedPathPlan(start, destination, pathPlan, true, this.vectorField.tileHealthNegligible); // TODO an experiment
    // }
    /**
     * @param {GridTile} start 
     * @param {GridTile} destination 
     * @param {Array<PathPlan>} pathPlan The output parameter.
     * @param {boolean} startAtStart If false, then we need to start the path at a point along the existing path plan.
     */
    findPartyCharacterPathPlan(start, destination, pathPlan, startAtStart) {
      if (start === destination) {
        console.log("findPartyCharacterPathPlan() start == destination.");
        pathPlan.length = 0;
        return;
      }
      if (this.vectorField.tileHealthNegligible) {
        if (startAtStart || pathPlan.length === 0) {
          if (this.findDirectPathPlan(start, destination, pathPlan)) {
            return;
          }
        } else {
          if (this.findContinuedDirectPathPlan2(start, destination, pathPlan)) {
            return;
          }
        }
      }
      if (startAtStart || pathPlan.length === 0) {
        this.findPathPlan(start, destination, pathPlan, true, this.vectorField.tileHealthNegligible);
      } else {
        this.findContinuedPathPlan2(start, destination, pathPlan, true, this.vectorField.tileHealthNegligible);
      }
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.path.reset();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/character/turn/MoveTurnAction.js
  var MoveTurnAction = class extends TurnAction {
    /**
     */
    constructor() {
      super();
    }
    /**
     * @override
     * @param {Character} character The character making the turn action.
     * @param {number} frameTimeRatio The time frame ratio.
     * @param {boolean} turnStart True if this is the start of a turn.
     */
    performAction(character, frameTimeRatio, turnStart) {
      const position = character.position;
      if (position.pathPlan.length > 0) {
        character.followPathPlan(frameTimeRatio, turnStart);
      }
      if (position.pathPlan.length === 0) {
        character.position.resetPathPlan();
        character.turnAction = null;
      }
    }
    /**
     * Returns true if this turn action will move the character and affect the path plan.
     * @override
     * @returns {boolean}
     */
    isMovementAction() {
      return true;
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "MoveTurnAction";
    }
  };

  // src/model/character/brain/MonsterWanderBehavior.js
  var MonsterWanderBehavior = class extends CharacterBehavior {
    /**
     * @param {number} behaviorId
     * @param {PathPlanFinder} pathPlanFinder 
     * @param {TurnAction} moveTurnAction
     */
    constructor(behaviorId, pathPlanFinder, moveTurnAction) {
      super(behaviorId);
      this.pathPlanFinder = pathPlanFinder;
      this.moveTurnAction = moveTurnAction;
    }
    /**
     * Applies the behavior, but only if it is appropriate for the current state of the world.
     * @override
     * @param {Character} character
     * @return {boolean} True if the behavior was applied.
     */
    applyIfAppropriate(character) {
      const position = character.position;
      if (position.pathPlan.length === 0) {
        if (Date.now() - character.pathCompletedTime < 3e3) {
          return false;
        }
        if (Math.random() < 0.75) {
          return false;
        }
      }
      const currentTile = position.tile;
      if (!currentTile) {
        return false;
      }
      const target = character.target;
      if (position.pathPlan.length === 0) {
        const targetTile = this.chooseRandomNeighborTile(currentTile);
        if (!targetTile) {
          return false;
        }
        target.setTargetTile(targetTile, null, this.behaviorId);
        this.pathPlanFinder.findMonsterPathPlan(character.position.tile, targetTile, character.position.pathPlan);
      }
      if (target.behaviorId !== this.behaviorId) {
        return;
      }
      character.turnAction = this.moveTurnAction;
      return true;
    }
    /**
     * @private
     * @param {GridTile} tile
     * @returns {GridTile}
     */
    chooseRandomNeighborTile(tile) {
      let neighbor = null;
      const r = Math.random();
      if (r < 0.15) {
        neighbor = tile.getNeighborLeft();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
        neighbor = tile.getNeighborRight();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
      } else if (r < 0.3) {
        neighbor = tile.getNeighborRight();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
        neighbor = tile.getNeighborLeft();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
      } else if (r < 0.45) {
        neighbor = tile.getNeighborTopLeft();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
        neighbor = tile.getNeighborTopRight();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
      } else if (r < 0.6) {
        neighbor = tile.getNeighborTopRight();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
        neighbor = tile.getNeighborTopLeft();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
      } else if (r < 0.75) {
        neighbor = tile.getNeighborBottomLeft();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
        neighbor = tile.getNeighborBottomRight();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
      } else if (r < 0.9) {
        neighbor = tile.getNeighborBottomRight();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
        neighbor = tile.getNeighborBottomLeft();
        if (this.isGoodTargetTile(neighbor)) {
          return neighbor;
        }
      }
      return null;
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @returns {boolean} 
     */
    isGoodTargetTile(tile) {
      if (!tile || !tile.isTraversable()) {
        return false;
      }
      const bottom = tile.getNeighborBottom();
      if (!bottom || bottom.isTraversable()) {
        return false;
      }
      return true;
    }
  };

  // src/model/character/brain/CharacterBrains.js
  var CharacterBrains = class {
    /**
     * @param {PathPlanFinder} pathPlanFinder 
     */
    constructor(pathPlanFinder) {
      this.moveTurnAction = new MoveTurnAction();
      this.monsterWanderBehavior = new MonsterWanderBehavior(1, pathPlanFinder, this.moveTurnAction);
      this.brainById = {};
      this.basicMonsterBrain = new CharacterBrain(MonsterBrainIds.BASIC, [
        this.monsterWanderBehavior
      ]);
      this.brainById[this.basicMonsterBrain.id] = this.basicMonsterBrain;
    }
    /**
     * @param {string} brainId 
     * @returns {CharacterBrain}
     */
    getBrainById(brainId) {
      return this.brainById[brainId];
    }
  };

  // src/model/character/CharacterCreator.js
  var CharacterCreator = class extends GameModel {
    /**
     * @param {MonsterSpritesheet} monsterSpritesheet 
     * @param {CharacterBrains} characterBrains
     */
    constructor(monsterSpritesheet, characterBrains) {
      super();
      this.monsterSpritesheet = monsterSpritesheet;
      this.characterBrains = characterBrains;
      this.monsterCharacterCache = new MonsterCharacterCache();
      this.baseMonsterDamage = 5;
      this.monsterDamageIncrease = 0.6;
      this.monsterDamageHundredFactor = 0.1;
      this.baseMonsterHealth = 5;
      this.monsterHealthIncrease = 0.6;
      this.monsterHealthHundredFactor = 0.1;
    }
    /**
     * @param {MonsterDescription} monsterDescription 
     * @param {GridTile} tile 
     * @returns {MonsterCharacter}
     */
    createMonsterAtTile(monsterDescription, tile) {
      const monster = this.createMonsterCharacter(monsterDescription);
      const origin = tile.origin;
      monster.position.setTileAndOriginPosition(tile, origin.x, origin.y);
      return monster;
    }
    /**
     * @private
     * @param {MonsterDescription} monsterDescription 
     * @returns {MonsterCharacter}
     */
    createMonsterCharacter(monsterDescription) {
      const sprite = this.monsterSpritesheet.getSprite(monsterDescription.spriteName);
      if (sprite == null) {
        console.log("CharacterCreator.createMonsterCharacter() Failed to find monster sprite: " + monsterDescription.spriteName);
        return null;
      }
      const brain = this.characterBrains.getBrainById(monsterDescription.brainId);
      if (!brain) {
        console.log("CharacterCreator.createMonsterCharacter() Failed to find monster brain id: " + monsterDescription.brainId);
        return null;
      }
      const monster = this.monsterCharacterCache.get();
      monster.set(brain, sprite, monsterDescription);
      return monster;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.monsterCharacterCache.resetCache();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/monster/MonsterDescriptions.js
  var MonsterDescriptions = {
    ANT: new MonsterDescription("1", MonsterSpriteNames.PEST_ANT_10, MonsterBrainIds.BASIC),
    SPIDER1: new MonsterDescription("2", MonsterSpriteNames.PEST_SPIDER_20, MonsterBrainIds.BASIC),
    SPIDER2: new MonsterDescription("3", MonsterSpriteNames.PEST_SPIDER_21, MonsterBrainIds.BASIC),
    SPIDER3: new MonsterDescription("4", MonsterSpriteNames.PEST_SPIDER_22, MonsterBrainIds.BASIC),
    WORM1: new MonsterDescription("5", MonsterSpriteNames.PEST_WORM_30, MonsterBrainIds.BASIC),
    WORM2: new MonsterDescription("6", MonsterSpriteNames.PEST_WORM_31, MonsterBrainIds.BASIC),
    WORM4: new MonsterDescription("7", MonsterSpriteNames.PEST_WORM_33, MonsterBrainIds.BASIC),
    WORM5: new MonsterDescription("8", MonsterSpriteNames.PEST_WORM_34, MonsterBrainIds.BASIC),
    BALL: new MonsterDescription("9", MonsterSpriteNames.PEST_BALL, MonsterBrainIds.BASIC),
    SLUG1: new MonsterDescription("10", MonsterSpriteNames.PEST_SLUG_70, MonsterBrainIds.BASIC),
    SLUG2: new MonsterDescription("11", MonsterSpriteNames.PEST_SLUG_71, MonsterBrainIds.BASIC),
    SNAIL1: new MonsterDescription("12", MonsterSpriteNames.PEST_SNAIL_72, MonsterBrainIds.BASIC),
    SNAIL2: new MonsterDescription("13", MonsterSpriteNames.PEST_SNAIL_73, MonsterBrainIds.BASIC),
    SLIME01: new MonsterDescription("14", MonsterSpriteNames.SLIME_BLUE_00, MonsterBrainIds.BASIC),
    SLIME02: new MonsterDescription("15", MonsterSpriteNames.SLIME_BROWN_01, MonsterBrainIds.BASIC),
    SLIME03: new MonsterDescription("16", MonsterSpriteNames.SLIME_WHITE_02, MonsterBrainIds.BASIC),
    SLIME04: new MonsterDescription("17", MonsterSpriteNames.SLIME_GREEN_03, MonsterBrainIds.BASIC),
    SLIME05: new MonsterDescription("18", MonsterSpriteNames.SLIME_PINK_04, MonsterBrainIds.BASIC),
    SLIME06: new MonsterDescription("19", MonsterSpriteNames.SLIME_MUCUS_GREEN_40, MonsterBrainIds.BASIC),
    SLIME07: new MonsterDescription("20", MonsterSpriteNames.SLIME_MUCUS_BLUE_41, MonsterBrainIds.BASIC),
    SLIME08: new MonsterDescription("21", MonsterSpriteNames.SLIME_CORRODED_20, MonsterBrainIds.BASIC),
    SLIME09: new MonsterDescription("22", MonsterSpriteNames.SLIME_SEEING_21, MonsterBrainIds.BASIC),
    SLIME10: new MonsterDescription("23", MonsterSpriteNames.SLIME_ORANGE_22, MonsterBrainIds.BASIC),
    SLIME11: new MonsterDescription("24", MonsterSpriteNames.SLIME_MINI_BLUE_30, MonsterBrainIds.BASIC),
    SLIME12: new MonsterDescription("25", MonsterSpriteNames.SLIME_MINI_31, MonsterBrainIds.BASIC),
    SLIME13: new MonsterDescription("26", MonsterSpriteNames.SLIME_MINI_ORANGE_32, MonsterBrainIds.BASIC)
  };
  function buildMonsterDescriptionMap() {
    const map = {};
    for (let monsterDescription of Object.values(MonsterDescriptions)) {
      map[monsterDescription.id] = monsterDescription;
    }
    return map;
  }
  function buildMonsterDescriptionArray() {
    const monsters = [];
    for (let monsterDescription of Object.values(MonsterDescriptions)) {
      monsters.push(monsterDescription);
    }
    return monsters;
  }
  var MonsterDescriptionMap = buildMonsterDescriptionMap();
  var MonsterDescriptionArray = buildMonsterDescriptionArray();
  function getRandomMonsterDescriptions() {
    const monsters = [];
    monsters.push(MonsterDescriptionArray[Rand.randomInt(MonsterDescriptionArray.length)]);
    monsters.push(MonsterDescriptionArray[Rand.randomInt(MonsterDescriptionArray.length)]);
    return monsters;
  }

  // src/model/grid/LayerDescriptions.js
  var LayerDescriptions = {
    SKY_LAYER: new LayerDescription(SpecialTileTypes.SKY, -1),
    GRASS_LAYER: new LayerDescription(SpecialTileTypes.GRASS, -1),
    DIRT_LAYER: new LayerDescription(SpecialTileTypes.DIRT, 1)
  };
  function createLayerDescriptionArray() {
    const layers = [];
    layers.push(LayerDescriptions.SKY_LAYER);
    layers.push(LayerDescriptions.GRASS_LAYER);
    layers.push(LayerDescriptions.DIRT_LAYER);
    let nominalIndex = 2;
    for (let i = 0; i < TileTypeArray.length; i++) {
      layers.push(new LayerDescription(TileTypeArray[i], nominalIndex++));
    }
    LayerDescriptions.SKY_LAYER.minDepth = -1e6;
    LayerDescriptions.SKY_LAYER.maxDepth = -1;
    LayerDescriptions.SKY_LAYER.baseHealth = new BigNum(20);
    LayerDescriptions.GRASS_LAYER.minDepth = -1;
    LayerDescriptions.GRASS_LAYER.maxDepth = 0;
    LayerDescriptions.GRASS_LAYER.baseHealth = new BigNum(20);
    LayerDescriptions.GRASS_LAYER.baseOre = new BigNum(1);
    LayerDescriptions.SKY_LAYER.initializeLayerValues(1, 1, 0.05, new BigNum(1), new BigNum(0));
    let baseGold = 1;
    let additiveBonusFactor = 10;
    let multiplicativeBonusFactor = 0.1;
    const oreStep = new BigNum(0.8);
    const healthStep = new BigNum(12);
    const healthStepMultiplier = new BigNum(10);
    const oreStepMultiplier = new BigNum(5);
    const additiveMultiplier = 2;
    let multiplicativeIncrement = 0.1;
    const multiplicativeIncrementIncrement = 0.1;
    let prevLayer = LayerDescriptions.GRASS_LAYER;
    const layerThickness = 500;
    const dirtIndex = 2;
    for (let i = dirtIndex; i < layers.length; i++) {
      const layer = layers[i];
      layer.monsterDescriptions = getRandomMonsterDescriptions();
      layer.initializeLayerValues(baseGold, additiveBonusFactor, multiplicativeBonusFactor, oreStep, healthStep);
      if (i < layers.length - 1) {
        layer.initializeLayer(prevLayer, layerThickness, i == dirtIndex);
      } else {
        layer.initializeLayer(prevLayer, -1, false);
      }
      prevLayer = layer;
      oreStep.mul(oreStepMultiplier);
      healthStep.mul(healthStepMultiplier);
      additiveBonusFactor *= additiveMultiplier;
      multiplicativeBonusFactor += multiplicativeIncrement;
      multiplicativeIncrement += multiplicativeIncrementIncrement;
    }
    return layers;
  }
  var LayerDescriptionArray = createLayerDescriptionArray();
  function buildLayerDescriptionMap() {
    const map = {};
    for (let i = 0; i < LayerDescriptionArray.length; i++) {
      const layerDescription = LayerDescriptionArray[i];
      map[layerDescription.id] = layerDescription;
    }
    return map;
  }
  var LayerDescriptionMap = buildLayerDescriptionMap();
  function getLayerDescriptionForRow(tileRow) {
    for (let i = 0; i < LayerDescriptionArray.length; i++) {
      const layerDescription = LayerDescriptionArray[i];
      if (layerDescription.minDepth <= tileRow && tileRow < layerDescription.maxDepth) {
        return layerDescription;
      }
    }
    return LayerDescriptionArray[LayerDescriptionArray.length - 1];
  }
  function findLayerForHealth(currentLayerDescription, health) {
    let layer = currentLayerDescription;
    while (layer && layer.prevLayer && layer.baseHealth.greaterThan(health)) {
      layer = layer.prevLayer;
    }
    while (layer && layer.nextLayer && layer.maxHealth.lessThan(health)) {
      layer = layer.nextLayer;
    }
    if (!layer) {
      console.log("LayerDescriptions.findLayerForHealth() null layer. using default");
      return currentLayerDescription;
    }
    return layer;
  }

  // src/model/math/MersenneTwister.js
  var MersenneTwister = class {
    /**
     * 
     * @param {number} seed 
     */
    constructor(seed) {
      this.N = 624;
      this.M = 397;
      this.MATRIX_A = 2567483615;
      this.UPPER_MASK = 2147483648;
      this.LOWER_MASK = 2147483647;
      this.randFactor = 1 / 4294967296;
      this.mag01 = [0, this.MATRIX_A];
      this.mt = new Array(this.N);
      this.mti = this.N + 1;
      this.setSeed(seed);
    }
    /**
     * @param {number} seed 
     */
    setSeed(seed) {
      this.mti = this.N + 1;
      this.initGenRand2(seed);
    }
    /**
     * Initializes mt[N] with a seed
     * @this {MersenneTwister}
     * @param {number} s
     */
    initGenRand2(s) {
      this.mt[0] = s & 4294967295;
      for (this.mti = 1; this.mti < this.N; this.mti++) {
        this.mt[this.mti] = 1812433253 * (this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >> 30) + this.mti;
        this.mt[this.mti] &= 4294967295;
      }
    }
    ///**
    // * Initializes mt[N] with a seed
    // * @this {MersenneTwister}
    // * @param {number} s
    // */
    //initGenRand(s) {
    //    "use strict";
    //    this.mt[0] = s >>> 0;
    //    var xxx;
    //    for (this.mti = 1; this.mti < this.N; this.mti++) {
    //        xxx = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
    //        this.mt[this.mti] = (((((xxx & 0xffff0000) >>> 16) * 1812433253) << 16)
    //            + (xxx & 0x0000ffff) * 1812433253) + this.mti;
    //
    //        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
    //        /* In the previous versions, MSBs of the seed affect */
    //        /* only MSBs of the array mt[]. */
    //        /* 2002/01/09 modified by Makoto Matsumoto */
    //        this.mt[this.mti] >>>= 0;
    //        /* for >32 bit machines */
    //    }
    //}
    /**
     * Generates a random number on [0,0xffffffff]-interval
     * @private
     * @this {MersenneTwister}
     * @returns {number}
     */
    genRandInt() {
      var y;
      this.mag01[0] = 0;
      this.mag01[1] = this.MATRIX_A;
      if (this.mti >= this.N) {
        var kk;
        for (kk = 0; kk < this.N - this.M; kk++) {
          y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
          this.mt[kk] = this.mt[kk + this.M] ^ y >>> 1 ^ this.mag01[y & 1];
        }
        for (; kk < this.N - 1; kk++) {
          y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
          this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ y >>> 1 ^ this.mag01[y & 1];
        }
        y = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK;
        this.mt[this.N - 1] = this.mt[this.M - 1] ^ y >>> 1 ^ this.mag01[y & 1];
        this.mti = 0;
      }
      y = this.mt[this.mti++];
      y ^= y >>> 11;
      y ^= y << 7 & 2636928640;
      y ^= y << 15 & 4022730752;
      y ^= y >>> 18;
      return y >>> 0;
    }
    /**
     * Generates a random number on [0,1)-real-interval.
     * @this {MersenneTwister}
     * @returns {number}
     */
    random() {
      return this.genRandInt() * this.randFactor;
    }
    /**
     * Returns a random integer in the range of 0 to limit (exclusive).
     * @param limit The max value of the resulting integer (exclusive).
     * @returns {number}
     */
    randomInt(limit) {
      return this.random() * limit | 0;
    }
  };

  // src/model/generator/SimplexNoise.js
  var grad3 = [
    [1, 1, 0],
    [-1, 1, 0],
    [1, -1, 0],
    [-1, -1, 0],
    [1, 0, 1],
    [-1, 0, 1],
    [1, 0, -1],
    [-1, 0, -1],
    [0, 1, 1],
    [0, -1, 1],
    [0, 1, -1],
    [0, -1, -1]
  ];
  var F2 = 0.5 * (Math.sqrt(3) - 1);
  var G2 = (3 - Math.sqrt(3)) / 6;
  var F3 = 1 / 3;
  var G3 = 1 / 6;
  var SimplexNoise = class {
    /**
     * @param {number} seed 
     */
    constructor(seed) {
      this.perm = this.initializePerm(seed);
    }
    /**
     * @private
     * @param {number} seed
     * @returns {Array<number>}
     */
    initializePerm(seed) {
      const rng = new MersenneTwister(seed);
      const p = new Array(256);
      for (let i = 0; i < p.length; i++) {
        p[i] = Math.floor(rng.random() * 256);
      }
      const perm = new Array(512);
      for (let i = 0; i < perm.length; i++) {
        perm[i] = p[i & 255];
      }
      return perm;
    }
    // /**
    //  * @private
    //  * @param {Array.<number>} g 
    //  * @param {number} x 
    //  * @param {number} y 
    //  * @returns {number}
    //  */
    // dot2D(g, x, y) { 
    //     return g[0]*x + g[1]*y;
    // }
    // /**
    //  * @private
    //  * @param {Array.<number>} g 
    //  * @param {number} x 
    //  * @param {number} y 
    //  * @param {number} z
    //  * @returns {number}
    //  */
    // dot3D(g, x, y, z) { 
    //     return g[0]*x + g[1]*y + g[2]*z; 
    // };
    /**
     * 2D simplex noise.
     * @param {number} xin 
     * @param {number} yin 
     * @returns {number}
     */
    noise(xin, yin) {
      const s = (xin + yin) * F2;
      const i = Math.floor(xin + s);
      const j = Math.floor(yin + s);
      const t = (i + j) * G2;
      const X0 = i - t;
      const Y0 = j - t;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      let i1, j1;
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      } else {
        i1 = 0;
        j1 = 1;
      }
      const x1 = x0 - i1 + G2;
      const y1 = y0 - j1 + G2;
      const x2 = x0 - 1 + 2 * G2;
      const y2 = y0 - 1 + 2 * G2;
      const ii = i & 255;
      const jj = j & 255;
      const gi0 = this.perm[ii + this.perm[jj]] % 12;
      const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
      const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
      let n0, n1, n2;
      let t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 < 0) n0 = 0;
      else {
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0][0] * x0 + grad3[gi0][1] * y0);
      }
      let t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 < 0) n1 = 0;
      else {
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1][0] * x1 + grad3[gi1][1] * y1);
      }
      let t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 < 0) n2 = 0;
      else {
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2][0] * x2 + grad3[gi2][1] * y2);
      }
      return 70 * (n0 + n1 + n2);
    }
    /**
     * 3D simplex noise 
     * @param {number} xin 
     * @param {number} yin 
     * @param {number} zin 
     * @returns {number}
     */
    noise3d(xin, yin, zin) {
      const s = (xin + yin + zin) * F3;
      const i = Math.floor(xin + s);
      const j = Math.floor(yin + s);
      const k = Math.floor(zin + s);
      const t = (i + j + k) * G3;
      const X0 = i - t;
      const Y0 = j - t;
      const Z0 = k - t;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      const z0 = zin - Z0;
      let i1, j1, k1;
      let i2, j2, k2;
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        }
      } else {
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        }
      }
      const x1 = x0 - i1 + G3;
      const y1 = y0 - j1 + G3;
      const z1 = z0 - k1 + G3;
      const x2 = x0 - i2 + 2 * G3;
      const y2 = y0 - j2 + 2 * G3;
      const z2 = z0 - k2 + 2 * G3;
      const x3 = x0 - 1 + 3 * G3;
      const y3 = y0 - 1 + 3 * G3;
      const z3 = z0 - 1 + 3 * G3;
      const ii = i & 255;
      const jj = j & 255;
      const kk = k & 255;
      const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
      const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
      const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
      const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
      let n0, n1, n2, n3;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) n0 = 0;
      else {
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0][0] * x0 + grad3[gi0][1] * y0 + grad3[gi0][2] * z0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) n1 = 0;
      else {
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1][0] * x1 + grad3[gi1][1] * y1 + grad3[gi1][2] * z1);
      }
      let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t2 < 0) n2 = 0;
      else {
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2][0] * x2 + grad3[gi2][1] * y2 + grad3[gi2][2] * z2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) n3 = 0;
      else {
        t3 *= t3;
        n3 = t3 * t3 * (grad3[gi3][0] * x3 + grad3[gi3][1] * y3 + grad3[gi3][2] * z3);
      }
      return 32 * (n0 + n1 + n2 + n3);
    }
  };

  // src/model/generator/FractionalBrownianMotion.js
  var FractionalBrownianMotion = class {
    /**
     * @param {number} seed
     * @param {number} terrainAmplitude The amplitude is how tall the features should be.
     * @param {number} terrainLacunarity Lacunarity is what makes the frequency grow. Each octave the frequency is multiplied by the lacunarity.
     * @param {number} terrainGain Gain is what makes the amplitude shrink (or not shrink).
     * @param {number} terrainOctaves Octaves are how many layers you are putting together.
     * @param {number} terrainFrequencyMultiplier The frequency of a layer is how many points fit into the space you've created.
     */
    constructor(seed, terrainAmplitude, terrainLacunarity, terrainGain, terrainOctaves, terrainFrequencyMultiplier) {
      this.simplexNoise = new SimplexNoise(seed);
      this.terrainAmplitude = terrainAmplitude;
      this.terrainLacunarity = terrainLacunarity;
      this.terrainGain = terrainGain;
      this.terrainOctaves = terrainOctaves;
      this.terrainFrequencyMultiplier = terrainFrequencyMultiplier;
    }
    // https://www.redblobgames.com/maps/terrain-from-noise/
    // const TAU = 2 * M_PI;
    // function cylindernoise(double nx, double ny) {
    //     double angle_x = TAU * nx;
    //     /* In "noise parameter space", we need nx and ny to travel the
    //        same distance. The circle created from nx needs to have
    //        circumference=1 to match the length=1 line created from ny,
    //        which means the circle's radius is 1/2π, or 1/tau */
    //     return noise3D(cos(angle_x) / TAU, sin(angle_x) / TAU, ny);
    // }
    // /**
    //  * Cylinder world
    //  * @param {number} x The x coordinate.
    //  * @param {number} y The y coordinate.
    //  * @returns {number}
    //  */
    // calculateNoise(x, y) {
    //     let sum = 0;
    //     // Make copies of amplitude and frequency because we need to modify them.
    //     let amplitude = this.terrainAmplitude;
    //     let frequency = this.terrainFrequencyMultiplier;
    //     const xRadians = 2 * Math.PI * (x / Settings.grid.worldPixelWidth); // world pixel width is the circumference.
    //     const xx = Settings.grid.pixelRadius * Math.cos(xRadians);
    //     const zz = Settings.grid.pixelRadius * Math.sin(xRadians);
    //     for (let i = 0; i < this.terrainOctaves; i++) {
    //         sum += amplitude * this.simplexNoise.noise3d(xx * frequency, zz * frequency, y * frequency);
    //         amplitude *= this.terrainGain;
    //         frequency *= this.terrainLacunarity;
    //     }
    //     return sum;   // most results are from [-0.8 to 0.2].
    // }    
    /**
     * @param {number} x The x coordinate.
     * @param {number} y The y coordinate.
     * @returns {number}
     */
    calculateNoise(x, y) {
      let sum = 0;
      let amplitude = this.terrainAmplitude;
      let frequency = this.terrainFrequencyMultiplier;
      for (let i = 0; i < this.terrainOctaves; i++) {
        sum += amplitude * this.simplexNoise.noise(x * frequency, y * frequency);
        amplitude *= this.terrainGain;
        frequency *= this.terrainLacunarity;
      }
      return sum;
    }
  };

  // src/model/generator/TerrainLayer.js
  var TerrainLayer = class {
    /**
     * @abstract
     * @returns {LayerDescription}
     */
    getLayerDescription() {
    }
    /**
     * @abstract
     * @param {number} minGridTileDepth
     * @param {number} maxGridTileDepth
     * @returns {boolean}
     */
    isLayerForGrid(minGridTileDepth, maxGridTileDepth) {
    }
    /**
     * @abstract
     * @param {GridTile} tile The tile
     * @param {number} tileDepth The depth of the tile in tile rows.
     * @returns {boolean}
     */
    isLayerForTile(tile, tileDepth) {
    }
    /**
     * @abstract
     * @returns {boolean} True if the terrain layer has ore tiles
     */
    isOreTileSupported() {
    }
    /**
     * @abstract
     * @returns {boolean} True if the terrain layer has gold tiles
     */
    isGoldTileSupported() {
    }
    /**
     * @abstract
     * @returns {boolean} True if the terrain layer has ruby tiles
     */
    isRubyTileSupported() {
    }
    /**
     * @abstract
     * @returns {boolean} True if the terrain layer has rare tiles
     */
    isUpgradeTileSupported() {
    }
    /**
     * @abstract
     * @param {GridTile} tile 
     */
    assignTileToOreType(tile) {
    }
    /**
     * @abstract
     * @param {GridTile} tile 
     */
    assignTileToGoldType(tile) {
    }
    /**
     * @abstract
     * @param {GridTile} tile 
     */
    assignTileToUpgradeType(tile) {
    }
    /**
     * @abstract
     * @param {GridTile} tile 
     */
    assignTileToRubyType(tile) {
    }
    /**
     * @abstract
     * @param {GridTile} tile 
     * @param {boolean} open
     */
    assignTileTerrain(tile, open) {
    }
  };

  // src/model/generator/BasicTerrainLayer.js
  var TILE_FUDGE = 60;
  var BasicTerrainLayer = class extends TerrainLayer {
    /**
     * @param {LayerDescription} layerDescription
     * @param {FractionalBrownianMotion} fbm 
     * @param {boolean} goldGenerated
     * @param {boolean} rubyGenerated
     */
    constructor(layerDescription, fbm, goldGenerated, rubyGenerated) {
      super();
      this.layerDescription = layerDescription;
      this.maxTileDepth = layerDescription.maxDepth;
      this.minTileDepth = layerDescription.minDepth;
      this.adjustedMinTileDepth = this.minTileDepth - TILE_FUDGE;
      this.fbm = fbm;
      this.goldGenerated = goldGenerated;
      this.rubyGenerated = rubyGenerated;
    }
    /**
     * @override
     * @returns {LayerDescription}
     */
    getLayerDescription() {
      return this.layerDescription;
    }
    /**
     * @private
     * @param {number} tileRow The tile row
     * @returns {boolean}
     */
    isInAdjustedRange(tileRow) {
      return tileRow >= this.adjustedMinTileDepth && tileRow < this.maxTileDepth;
    }
    /**
     * Returns true if at least some part of the grid overlaps with the layer. 
     * Not all tiles in the grid will necessarily be affected by this layer.
     * @override
     * @param {number} minGridTileDepth
     * @param {number} maxGridTileDepth
     * @returns {boolean}
     */
    isLayerForGrid(minGridTileDepth, maxGridTileDepth) {
      if (maxGridTileDepth < this.adjustedMinTileDepth || minGridTileDepth > this.maxTileDepth) {
        return false;
      }
      return true;
    }
    /**
     * @override
     * @param {GridTile} tile The tile
     * @param {number} tileDepth The depth of the tile in tile rows.
     * @returns {boolean}
     */
    isLayerForTile(tile, tileDepth) {
      if (!this.isInAdjustedRange(tileDepth)) {
        return false;
      }
      const origin = tile.origin;
      const noiseAdjustment = Settings.tile.size * this.fbm.calculateNoise(origin.y, origin.x);
      const adjustedMinLayerDepth = this.minTileDepth + noiseAdjustment;
      return tileDepth >= adjustedMinLayerDepth;
    }
    /**
     * @override
     * @returns {boolean} True if the terrain layer has ore tiles
     */
    isOreTileSupported() {
      return this.layerDescription.oreTileType !== null;
    }
    /**
     * @override
     * @returns {boolean} True if the terrain layer has greater tiles
     */
    isGoldTileSupported() {
      return this.goldGenerated && this.layerDescription.goldTileType !== null;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isRubyTileSupported() {
      return this.rubyGenerated && this.layerDescription.rubyTileType !== null;
    }
    /**
     * @override
     * @returns {boolean} True if the terrain layer has rare tiles
     */
    isUpgradeTileSupported() {
      return this.layerDescription.upgradeTileType !== null;
    }
    /**
     * @override
     * @param {GridTile} tile 
     */
    assignTileToOreType(tile) {
      tile.tileInit(false, this.layerDescription.oreTileType);
    }
    /**
     * @override
     * @param {GridTile} tile 
     */
    assignTileToGoldType(tile) {
      tile.tileInit(false, this.layerDescription.goldTileType);
    }
    /**
     * @override
     * @param {GridTile} tile 
     */
    assignTileToUpgradeType(tile) {
      tile.tileInit(false, this.layerDescription.upgradeTileType);
    }
    /**
     * @override
     * @param {GridTile} tile 
     */
    assignTileToRubyType(tile) {
      tile.tileInit(false, this.layerDescription.rubyTileType);
    }
    /**
     * @override
     * @param {GridTile} tile 
      * @param {boolean} open
    */
    assignTileTerrain(tile, open) {
      tile.tileInit(open, this.layerDescription.primaryTileType);
    }
  };

  // src/model/generator/SkyTerrainLayer.js
  var SkyTerrainLayer = class extends TerrainLayer {
    /**
     * @param {TileType} tileType 
     * @param {LayerDescription} layerDescription
     */
    constructor(tileType, layerDescription) {
      super();
      this.tileType = tileType;
      this.layerDescription = layerDescription;
      this.maxSkyTileDepth = 20;
    }
    /**
     * @abstract
     * @returns {LayerDescription}
     */
    getLayerDescription() {
      return this.layerDescription;
    }
    /**
     * @override
     * @param {number} minGridTileDepth
     * @param {number} maxGridTileDepth
     * @returns {boolean}
     */
    isLayerForGrid(minGridTileDepth, maxGridTileDepth) {
      return minGridTileDepth < this.maxSkyTileDepth;
    }
    /**
     * @override
     * @param {GridTile} tile The tile
     * @param {number} tileDepth The depth of the tile in tile rows.
     * @returns {boolean}
     */
    isLayerForTile(tile, tileDepth) {
      return tileDepth < this.maxSkyTileDepth;
    }
    /**
     * @override
     * @returns {boolean} True if the terrain layer has lesser tiles
     */
    isOreTileSupported() {
      return false;
    }
    /**
     * @override
     * @returns {boolean} True if the terrain layer has greater tiles
     */
    isGoldTileSupported() {
      return false;
    }
    /**
     * @override
     * @returns {boolean} True if the terrain layer has greater tiles
     */
    isRubyTileSupported() {
      return false;
    }
    /**
     * @override
     * @returns {boolean} True if the terrain layer has rare tiles
     */
    isUpgradeTileSupported() {
      return false;
    }
    /**
     * @override
     * @param {GridTile} tile 
     */
    assignTileToOreType(tile) {
      tile.tileInit(true, this.tileType);
    }
    /**
     * @override
     * @param {GridTile} tile 
     */
    assignTileToGoldType(tile) {
      tile.tileInit(true, this.tileType);
    }
    /**
     * @override
     * @param {GridTile} tile 
     */
    assignTileToUpgradeType(tile) {
      tile.tileInit(true, this.tileType);
    }
    /**
     * @override
     * @param {GridTile} tile 
     */
    assignTileToRubyType(tile) {
      tile.tileInit(true, this.tileType);
    }
    /**
     * @override
     * @param {GridTile} tile 
     * @param {boolean} open
     */
    assignTileTerrain(tile, open) {
      tile.tileInit(true, this.tileType);
    }
  };

  // src/model/generator/GrassTerrainLayer.js
  var GrassTerrainLayer = class extends BasicTerrainLayer {
    /**
     * @param {LayerDescription} layerDescription
     * @param {FractionalBrownianMotion} fbm 
     */
    constructor(layerDescription, fbm) {
      super(layerDescription, fbm);
    }
    /**
     * @override
     * @param {GridTile} tile The tile
     * @param {number} tileDepth The depth of the tile in tile rows.
     * @returns {boolean}
     */
    isLayerForTile(tile, tileDepth) {
      if (!this.isInAdjustedRange(tileDepth)) {
        return false;
      }
      const origin = tile.origin;
      const noiseAdjustment = Settings.tile.size * this.fbm.calculateNoise(origin.x, origin.x);
      const adjustedMinLayerDepth = this.minTileDepth + noiseAdjustment - 5;
      return tileDepth >= adjustedMinLayerDepth;
    }
  };

  // src/model/generator/DirtTerrainLayer.js
  var DirtTerrainLayer = class extends BasicTerrainLayer {
    /**
     * @param {LayerDescription} layerDescription
     * @param {FractionalBrownianMotion} fbm 
     */
    constructor(layerDescription, fbm) {
      super(layerDescription, fbm);
    }
    /**
     * @override
     * @param {GridTile} tile The tile
     * @param {number} tileDepth The depth of the tile in tile rows.
     * @returns {boolean}
     */
    isLayerForTile(tile, tileDepth) {
      if (!this.isInAdjustedRange(tileDepth)) {
        return false;
      }
      const origin = tile.origin;
      const noiseAdjustment = Settings.tile.size * this.fbm.calculateNoise(origin.x, origin.x);
      const adjustedMinLayerDepth = this.minTileDepth + noiseAdjustment - 5;
      return tileDepth >= adjustedMinLayerDepth;
    }
  };

  // src/model/generator/IndexGenerator.js
  var IndexGenerator = class {
    /**
     * 
     * @param {number} worldSeed 
     */
    constructor(worldSeed) {
      this.shiftValue = 2.2734306378540854;
      this.indexFbm = new FractionalBrownianMotion(worldSeed, 1, 2.1, 0.7, 5, 5e-4);
      this.indexLookup = {};
      this.indexLookup["0.00"] = 0;
      this.indexLookup["0.01"] = 0;
      this.indexLookup["0.02"] = 0;
      this.indexLookup["0.03"] = 0;
      this.indexLookup["0.04"] = 0;
      this.indexLookup["0.05"] = 0;
      this.indexLookup["0.06"] = 0;
      this.indexLookup["0.07"] = 0;
      this.indexLookup["0.08"] = 0;
      this.indexLookup["0.09"] = 0;
      this.indexLookup["0.10"] = 0;
      this.indexLookup["0.11"] = 0;
      this.indexLookup["0.12"] = 0;
      this.indexLookup["0.13"] = 0;
      this.indexLookup["0.14"] = 0;
      this.indexLookup["0.15"] = 0;
      this.indexLookup["0.16"] = 0;
      this.indexLookup["0.17"] = 0;
      this.indexLookup["0.18"] = 0;
      this.indexLookup["0.19"] = 0;
      this.indexLookup["0.20"] = 0;
      this.indexLookup["0.21"] = 0;
      this.indexLookup["0.22"] = 0;
      this.indexLookup["0.23"] = 0;
      this.indexLookup["0.24"] = 0;
      this.indexLookup["0.25"] = 0;
      this.indexLookup["0.26"] = 0;
      this.indexLookup["0.27"] = 0;
      this.indexLookup["0.28"] = 0;
      this.indexLookup["0.29"] = 0;
      this.indexLookup["0.30"] = 0;
      this.indexLookup["0.31"] = 0;
      this.indexLookup["0.32"] = 0;
      this.indexLookup["0.33"] = 0;
      this.indexLookup["0.34"] = 0;
      this.indexLookup["0.35"] = 0;
      this.indexLookup["0.36"] = 0;
      this.indexLookup["0.37"] = 0;
      this.indexLookup["0.38"] = 0;
      this.indexLookup["0.39"] = 0;
      this.indexLookup["0.40"] = 0;
      this.indexLookup["0.41"] = 0;
      this.indexLookup["0.42"] = 0;
      this.indexLookup["0.43"] = 0;
      this.indexLookup["0.44"] = 0;
      this.indexLookup["0.45"] = 0;
      this.indexLookup["0.46"] = 0;
      this.indexLookup["0.47"] = 0;
      this.indexLookup["0.48"] = 0;
      this.indexLookup["0.49"] = 0;
      this.indexLookup["0.50"] = 0;
      this.indexLookup["0.51"] = 0;
      this.indexLookup["0.52"] = 0;
      this.indexLookup["0.53"] = 0;
      this.indexLookup["0.54"] = 0;
      this.indexLookup["0.55"] = 0;
      this.indexLookup["0.56"] = 0;
      this.indexLookup["0.57"] = 0;
      this.indexLookup["0.58"] = 0;
      this.indexLookup["0.59"] = 0;
      this.indexLookup["0.60"] = 0;
      this.indexLookup["0.61"] = 0;
      this.indexLookup["0.62"] = 0;
      this.indexLookup["0.63"] = 0;
      this.indexLookup["0.64"] = 0;
      this.indexLookup["0.65"] = 0;
      this.indexLookup["0.66"] = 0;
      this.indexLookup["0.67"] = 0;
      this.indexLookup["0.68"] = 0;
      this.indexLookup["0.69"] = 0;
      this.indexLookup["0.70"] = 0;
      this.indexLookup["0.71"] = 0;
      this.indexLookup["0.72"] = 0;
      this.indexLookup["0.73"] = 0;
      this.indexLookup["0.74"] = 0;
      this.indexLookup["0.75"] = 0;
      this.indexLookup["0.76"] = 0;
      this.indexLookup["0.77"] = 0;
      this.indexLookup["0.78"] = 0;
      this.indexLookup["0.79"] = 0;
      this.indexLookup["0.80"] = 0;
      this.indexLookup["0.81"] = 0;
      this.indexLookup["0.82"] = 0;
      this.indexLookup["0.83"] = 0;
      this.indexLookup["0.84"] = 0;
      this.indexLookup["0.85"] = 0;
      this.indexLookup["0.86"] = 0;
      this.indexLookup["0.87"] = 0;
      this.indexLookup["0.88"] = 0;
      this.indexLookup["0.89"] = 0;
      this.indexLookup["0.90"] = 0;
      this.indexLookup["0.91"] = 0;
      this.indexLookup["0.92"] = 0.01;
      this.indexLookup["0.93"] = 0.01;
      this.indexLookup["0.94"] = 0.01;
      this.indexLookup["0.95"] = 0.01;
      this.indexLookup["0.96"] = 0.01;
      this.indexLookup["0.97"] = 0.01;
      this.indexLookup["0.98"] = 0.01;
      this.indexLookup["0.99"] = 0.01;
      this.indexLookup["1.00"] = 0.01;
      this.indexLookup["1.01"] = 0.01;
      this.indexLookup["1.02"] = 0.01;
      this.indexLookup["1.03"] = 0.01;
      this.indexLookup["1.04"] = 0.01;
      this.indexLookup["1.05"] = 0.01;
      this.indexLookup["1.06"] = 0.02;
      this.indexLookup["1.07"] = 0.02;
      this.indexLookup["1.08"] = 0.02;
      this.indexLookup["1.09"] = 0.02;
      this.indexLookup["1.10"] = 0.02;
      this.indexLookup["1.11"] = 0.02;
      this.indexLookup["1.12"] = 0.02;
      this.indexLookup["1.13"] = 0.02;
      this.indexLookup["1.14"] = 0.02;
      this.indexLookup["1.15"] = 0.03;
      this.indexLookup["1.16"] = 0.03;
      this.indexLookup["1.17"] = 0.03;
      this.indexLookup["1.18"] = 0.03;
      this.indexLookup["1.19"] = 0.03;
      this.indexLookup["1.20"] = 0.03;
      this.indexLookup["1.21"] = 0.04;
      this.indexLookup["1.22"] = 0.04;
      this.indexLookup["1.23"] = 0.04;
      this.indexLookup["1.24"] = 0.04;
      this.indexLookup["1.25"] = 0.04;
      this.indexLookup["1.26"] = 0.04;
      this.indexLookup["1.27"] = 0.05;
      this.indexLookup["1.28"] = 0.05;
      this.indexLookup["1.29"] = 0.05;
      this.indexLookup["1.30"] = 0.05;
      this.indexLookup["1.31"] = 0.05;
      this.indexLookup["1.32"] = 0.06;
      this.indexLookup["1.33"] = 0.06;
      this.indexLookup["1.34"] = 0.06;
      this.indexLookup["1.35"] = 0.06;
      this.indexLookup["1.36"] = 0.07;
      this.indexLookup["1.37"] = 0.07;
      this.indexLookup["1.38"] = 0.07;
      this.indexLookup["1.39"] = 0.07;
      this.indexLookup["1.40"] = 0.08;
      this.indexLookup["1.41"] = 0.08;
      this.indexLookup["1.42"] = 0.08;
      this.indexLookup["1.43"] = 0.08;
      this.indexLookup["1.44"] = 0.09;
      this.indexLookup["1.45"] = 0.09;
      this.indexLookup["1.46"] = 0.09;
      this.indexLookup["1.47"] = 0.1;
      this.indexLookup["1.48"] = 0.1;
      this.indexLookup["1.49"] = 0.1;
      this.indexLookup["1.50"] = 0.11;
      this.indexLookup["1.51"] = 0.11;
      this.indexLookup["1.52"] = 0.11;
      this.indexLookup["1.53"] = 0.12;
      this.indexLookup["1.54"] = 0.12;
      this.indexLookup["1.55"] = 0.12;
      this.indexLookup["1.56"] = 0.13;
      this.indexLookup["1.57"] = 0.13;
      this.indexLookup["1.58"] = 0.13;
      this.indexLookup["1.59"] = 0.14;
      this.indexLookup["1.60"] = 0.14;
      this.indexLookup["1.61"] = 0.15;
      this.indexLookup["1.62"] = 0.15;
      this.indexLookup["1.63"] = 0.15;
      this.indexLookup["1.64"] = 0.16;
      this.indexLookup["1.65"] = 0.16;
      this.indexLookup["1.66"] = 0.17;
      this.indexLookup["1.67"] = 0.17;
      this.indexLookup["1.68"] = 0.17;
      this.indexLookup["1.69"] = 0.18;
      this.indexLookup["1.70"] = 0.18;
      this.indexLookup["1.71"] = 0.19;
      this.indexLookup["1.72"] = 0.19;
      this.indexLookup["1.73"] = 0.2;
      this.indexLookup["1.74"] = 0.2;
      this.indexLookup["1.75"] = 0.21;
      this.indexLookup["1.76"] = 0.21;
      this.indexLookup["1.77"] = 0.21;
      this.indexLookup["1.78"] = 0.22;
      this.indexLookup["1.79"] = 0.22;
      this.indexLookup["1.80"] = 0.23;
      this.indexLookup["1.81"] = 0.23;
      this.indexLookup["1.82"] = 0.24;
      this.indexLookup["1.83"] = 0.24;
      this.indexLookup["1.84"] = 0.25;
      this.indexLookup["1.85"] = 0.25;
      this.indexLookup["1.86"] = 0.26;
      this.indexLookup["1.87"] = 0.26;
      this.indexLookup["1.88"] = 0.27;
      this.indexLookup["1.89"] = 0.27;
      this.indexLookup["1.90"] = 0.28;
      this.indexLookup["1.91"] = 0.29;
      this.indexLookup["1.92"] = 0.29;
      this.indexLookup["1.93"] = 0.3;
      this.indexLookup["1.94"] = 0.3;
      this.indexLookup["1.95"] = 0.31;
      this.indexLookup["1.96"] = 0.31;
      this.indexLookup["1.97"] = 0.32;
      this.indexLookup["1.98"] = 0.32;
      this.indexLookup["1.99"] = 0.33;
      this.indexLookup["2.00"] = 0.34;
      this.indexLookup["2.01"] = 0.34;
      this.indexLookup["2.02"] = 0.35;
      this.indexLookup["2.03"] = 0.35;
      this.indexLookup["2.04"] = 0.36;
      this.indexLookup["2.05"] = 0.36;
      this.indexLookup["2.06"] = 0.37;
      this.indexLookup["2.07"] = 0.38;
      this.indexLookup["2.08"] = 0.38;
      this.indexLookup["2.09"] = 0.39;
      this.indexLookup["2.10"] = 0.39;
      this.indexLookup["2.11"] = 0.4;
      this.indexLookup["2.12"] = 0.41;
      this.indexLookup["2.13"] = 0.41;
      this.indexLookup["2.14"] = 0.42;
      this.indexLookup["2.15"] = 0.42;
      this.indexLookup["2.16"] = 0.43;
      this.indexLookup["2.17"] = 0.44;
      this.indexLookup["2.18"] = 0.44;
      this.indexLookup["2.19"] = 0.45;
      this.indexLookup["2.20"] = 0.46;
      this.indexLookup["2.21"] = 0.46;
      this.indexLookup["2.22"] = 0.47;
      this.indexLookup["2.23"] = 0.47;
      this.indexLookup["2.24"] = 0.48;
      this.indexLookup["2.25"] = 0.49;
      this.indexLookup["2.26"] = 0.49;
      this.indexLookup["2.27"] = 0.5;
      this.indexLookup["2.28"] = 0.5;
      this.indexLookup["2.29"] = 0.51;
      this.indexLookup["2.30"] = 0.52;
      this.indexLookup["2.31"] = 0.52;
      this.indexLookup["2.32"] = 0.53;
      this.indexLookup["2.33"] = 0.53;
      this.indexLookup["2.34"] = 0.54;
      this.indexLookup["2.35"] = 0.55;
      this.indexLookup["2.36"] = 0.55;
      this.indexLookup["2.37"] = 0.56;
      this.indexLookup["2.38"] = 0.57;
      this.indexLookup["2.39"] = 0.57;
      this.indexLookup["2.40"] = 0.58;
      this.indexLookup["2.41"] = 0.58;
      this.indexLookup["2.42"] = 0.59;
      this.indexLookup["2.43"] = 0.6;
      this.indexLookup["2.44"] = 0.6;
      this.indexLookup["2.45"] = 0.61;
      this.indexLookup["2.46"] = 0.61;
      this.indexLookup["2.47"] = 0.62;
      this.indexLookup["2.48"] = 0.63;
      this.indexLookup["2.49"] = 0.63;
      this.indexLookup["2.50"] = 0.64;
      this.indexLookup["2.51"] = 0.64;
      this.indexLookup["2.52"] = 0.65;
      this.indexLookup["2.53"] = 0.65;
      this.indexLookup["2.54"] = 0.66;
      this.indexLookup["2.55"] = 0.67;
      this.indexLookup["2.56"] = 0.67;
      this.indexLookup["2.57"] = 0.68;
      this.indexLookup["2.58"] = 0.68;
      this.indexLookup["2.59"] = 0.69;
      this.indexLookup["2.60"] = 0.69;
      this.indexLookup["2.61"] = 0.7;
      this.indexLookup["2.62"] = 0.71;
      this.indexLookup["2.63"] = 0.71;
      this.indexLookup["2.64"] = 0.72;
      this.indexLookup["2.65"] = 0.72;
      this.indexLookup["2.66"] = 0.73;
      this.indexLookup["2.67"] = 0.73;
      this.indexLookup["2.68"] = 0.74;
      this.indexLookup["2.69"] = 0.74;
      this.indexLookup["2.70"] = 0.75;
      this.indexLookup["2.71"] = 0.75;
      this.indexLookup["2.72"] = 0.76;
      this.indexLookup["2.73"] = 0.76;
      this.indexLookup["2.74"] = 0.77;
      this.indexLookup["2.75"] = 0.77;
      this.indexLookup["2.76"] = 0.78;
      this.indexLookup["2.77"] = 0.78;
      this.indexLookup["2.78"] = 0.79;
      this.indexLookup["2.79"] = 0.79;
      this.indexLookup["2.80"] = 0.8;
      this.indexLookup["2.81"] = 0.8;
      this.indexLookup["2.82"] = 0.8;
      this.indexLookup["2.83"] = 0.81;
      this.indexLookup["2.84"] = 0.81;
      this.indexLookup["2.85"] = 0.82;
      this.indexLookup["2.86"] = 0.82;
      this.indexLookup["2.87"] = 0.83;
      this.indexLookup["2.88"] = 0.83;
      this.indexLookup["2.89"] = 0.83;
      this.indexLookup["2.90"] = 0.84;
      this.indexLookup["2.91"] = 0.84;
      this.indexLookup["2.92"] = 0.85;
      this.indexLookup["2.93"] = 0.85;
      this.indexLookup["2.94"] = 0.85;
      this.indexLookup["2.95"] = 0.86;
      this.indexLookup["2.96"] = 0.86;
      this.indexLookup["2.97"] = 0.86;
      this.indexLookup["2.98"] = 0.87;
      this.indexLookup["2.99"] = 0.87;
      this.indexLookup["3.00"] = 0.87;
      this.indexLookup["3.01"] = 0.88;
      this.indexLookup["3.02"] = 0.88;
      this.indexLookup["3.03"] = 0.88;
      this.indexLookup["3.04"] = 0.89;
      this.indexLookup["3.05"] = 0.89;
      this.indexLookup["3.06"] = 0.89;
      this.indexLookup["3.07"] = 0.9;
      this.indexLookup["3.08"] = 0.9;
      this.indexLookup["3.09"] = 0.9;
      this.indexLookup["3.10"] = 0.9;
      this.indexLookup["3.11"] = 0.91;
      this.indexLookup["3.12"] = 0.91;
      this.indexLookup["3.13"] = 0.91;
      this.indexLookup["3.14"] = 0.92;
      this.indexLookup["3.15"] = 0.92;
      this.indexLookup["3.16"] = 0.92;
      this.indexLookup["3.17"] = 0.92;
      this.indexLookup["3.18"] = 0.93;
      this.indexLookup["3.19"] = 0.93;
      this.indexLookup["3.20"] = 0.93;
      this.indexLookup["3.21"] = 0.93;
      this.indexLookup["3.22"] = 0.93;
      this.indexLookup["3.23"] = 0.94;
      this.indexLookup["3.24"] = 0.94;
      this.indexLookup["3.25"] = 0.94;
      this.indexLookup["3.26"] = 0.94;
      this.indexLookup["3.27"] = 0.94;
      this.indexLookup["3.28"] = 0.95;
      this.indexLookup["3.29"] = 0.95;
      this.indexLookup["3.30"] = 0.95;
      this.indexLookup["3.31"] = 0.95;
      this.indexLookup["3.32"] = 0.95;
      this.indexLookup["3.33"] = 0.96;
      this.indexLookup["3.34"] = 0.96;
      this.indexLookup["3.35"] = 0.96;
      this.indexLookup["3.36"] = 0.96;
      this.indexLookup["3.37"] = 0.96;
      this.indexLookup["3.38"] = 0.96;
      this.indexLookup["3.39"] = 0.96;
      this.indexLookup["3.40"] = 0.97;
      this.indexLookup["3.41"] = 0.97;
      this.indexLookup["3.42"] = 0.97;
      this.indexLookup["3.43"] = 0.97;
      this.indexLookup["3.44"] = 0.97;
      this.indexLookup["3.45"] = 0.97;
      this.indexLookup["3.46"] = 0.97;
      this.indexLookup["3.47"] = 0.97;
      this.indexLookup["3.48"] = 0.97;
      this.indexLookup["3.49"] = 0.98;
      this.indexLookup["3.50"] = 0.98;
      this.indexLookup["3.51"] = 0.98;
      this.indexLookup["3.52"] = 0.98;
      this.indexLookup["3.53"] = 0.98;
      this.indexLookup["3.54"] = 0.98;
      this.indexLookup["3.55"] = 0.98;
      this.indexLookup["3.56"] = 0.98;
      this.indexLookup["3.57"] = 0.98;
      this.indexLookup["3.58"] = 0.98;
      this.indexLookup["3.59"] = 0.98;
      this.indexLookup["3.60"] = 0.98;
      this.indexLookup["3.61"] = 0.98;
      this.indexLookup["3.62"] = 0.99;
      this.indexLookup["3.63"] = 0.99;
      this.indexLookup["3.64"] = 0.99;
      this.indexLookup["3.65"] = 0.99;
      this.indexLookup["3.66"] = 0.99;
      this.indexLookup["3.67"] = 0.99;
      this.indexLookup["3.68"] = 0.99;
      this.indexLookup["3.69"] = 0.99;
      this.indexLookup["3.70"] = 0.99;
      this.indexLookup["3.71"] = 0.99;
      this.indexLookup["3.72"] = 0.99;
      this.indexLookup["3.73"] = 0.99;
      this.indexLookup["3.74"] = 0.99;
      this.indexLookup["3.75"] = 0.99;
      this.indexLookup["3.76"] = 0.99;
      this.indexLookup["3.77"] = 0.99;
      this.indexLookup["3.78"] = 0.99;
      this.indexLookup["3.79"] = 0.99;
      this.indexLookup["3.80"] = 0.99;
      this.indexLookup["3.81"] = 0.99;
      this.indexLookup["3.82"] = 0.99;
      this.indexLookup["3.83"] = 0.99;
      this.indexLookup["3.84"] = 0.99;
      this.indexLookup["3.85"] = 0.99;
      this.indexLookup["3.86"] = 0.99;
      this.indexLookup["3.87"] = 0.99;
      this.indexLookup["3.88"] = 0.99;
      this.indexLookup["3.89"] = 0.99;
      this.indexLookup["3.90"] = 0.99;
      this.indexLookup["3.91"] = 0.99;
      this.indexLookup["3.92"] = 0.99;
      this.indexLookup["3.93"] = 0.99;
      this.indexLookup["3.94"] = 0.99;
      this.indexLookup["3.95"] = 0.99;
      this.indexLookup["3.96"] = 0.99;
      this.indexLookup["3.97"] = 0.99;
      this.indexLookup["3.98"] = 0.99;
      this.indexLookup["3.99"] = 0.99;
      this.indexLookup["4.00"] = 0.99;
      this.indexLookup["4.01"] = 0.99;
      this.indexLookup["4.02"] = 0.99;
      this.indexLookup["4.03"] = 0.99;
      this.indexLookup["4.04"] = 0.99;
      this.indexLookup["4.05"] = 0.99;
      this.indexLookup["4.06"] = 0.99;
      this.indexLookup["4.07"] = 0.99;
      this.indexLookup["4.08"] = 0.99;
      this.indexLookup["4.09"] = 0.99;
      this.indexLookup["4.10"] = 0.99;
      this.indexLookup["4.11"] = 0.99;
      this.indexLookup["4.12"] = 0.99;
      this.indexLookup["4.13"] = 0.99;
      this.indexLookup["4.14"] = 0.99;
      this.indexLookup["4.15"] = 0.99;
      this.indexLookup["4.16"] = 0.99;
      this.indexLookup["4.17"] = 0.99;
      this.indexLookup["4.18"] = 0.99;
      this.indexLookup["4.19"] = 0.99;
      this.indexLookup["4.20"] = 0.99;
      this.indexLookup["4.21"] = 0.99;
      this.indexLookup["4.22"] = 0.99;
      this.indexLookup["4.23"] = 0.99;
      this.indexLookup["4.24"] = 0.99;
      this.indexLookup["4.25"] = 0.99;
      this.indexLookup["4.26"] = 0.99;
      this.indexLookup["4.27"] = 0.99;
      this.indexLookup["4.28"] = 0.99;
      this.indexLookup["4.29"] = 0.99;
      this.indexLookup["4.30"] = 0.99;
      this.indexLookup["4.31"] = 0.99;
      this.indexLookup["4.32"] = 0.99;
      this.indexLookup["4.33"] = 0.99;
      this.indexLookup["4.34"] = 0.99;
      this.indexLookup["4.35"] = 0.99;
      this.indexLookup["4.36"] = 0.99;
      this.indexLookup["4.37"] = 0.99;
      this.indexLookup["4.38"] = 0.99;
      this.indexLookup["4.39"] = 0.99;
      this.indexLookup["4.40"] = 0.99;
      this.indexLookup["4.41"] = 0.99;
    }
    /////////////////////////////////////////////////////////
    // Index Lookup Generation END
    /////////////////////////////////////////////////////////
    /**
     * Given a value from FBM, get its 'bucket' value representation.
     * @private
     * @param {number} value 
     * @returns {string}
     */
    getBucket(value2) {
      return value2.toFixed(2);
    }
    /**
     * @param {number} x
     * @param {number} y
     * @param {number} limit 
     * @returns {number}
     */
    getIndexFromFbm(x, y, limit) {
      if (limit === 1) {
        return 0;
      }
      const value2 = this.indexFbm.calculateNoise(x, y) + this.shiftValue;
      if (value2 <= 0) {
        return 0;
      }
      const bucket = this.getBucket(value2);
      let indexValue = this.indexLookup[bucket];
      if (!indexValue) {
        return 0;
      }
      return limit * indexValue | 0;
    }
  };

  // src/model/fixture/StaticFixureDescription.js
  var StaticFixtureDescription = class extends FixtureDescription {
    /**
     * @param {string} typeName 
     * @param {string} colorName 
     * @param {string} spriteName
     * @param {boolean} traversable 
     * @param {boolean} opaque 
     * @param {boolean} stateSavable 
     */
    constructor(typeName, colorName, spriteName, traversable, opaque, stateSavable) {
      super(spriteName, traversable, opaque, stateSavable);
      this.typeName = typeName;
      this.colorName = colorName;
    }
  };

  // src/model/fixture/FixtureDescriptions.js
  var FixtureDescriptions = {};
  FixtureDescriptions.getDescription = (typeName, colorName) => {
    const spriteName = StaticFixtureSpritesheet.getSpriteName(typeName, colorName);
    let desc = FixtureDescriptions[spriteName];
    if (!desc) {
      desc = new StaticFixtureDescription(typeName, colorName, spriteName, true, false, false);
      FixtureDescriptions[spriteName] = desc;
    }
    return desc;
  };

  // src/model/generator/decorator/TileDecoratorTheme.js
  var TileDecoratorTheme = class {
    /**
     * @param {Array.<string>} fixtureNames 
     * @param {Array.<string>} colorNames
     * @param {number} probabilityDenominator A value of 2 means that (1/2) tiles will be decorated. 3 means 1/3 tiles.
     */
    constructor(fixtureNames, colorNames, probabilityDenominator) {
      this.fixtureNames = fixtureNames;
      this.colorNames = colorNames;
      this.probabilityDenominator = probabilityDenominator;
    }
    /**
     * @param {MersenneTwister} rng 
     * @returns {FixtureDescription}
     */
    getFixtureDescription(rng) {
      if (this.fixtureNames.length === 0 || this.colorNames.length === 0) {
        return null;
      }
      const index = rng.randomInt(this.fixtureNames.length * this.probabilityDenominator);
      if (index >= this.fixtureNames.length) {
        return null;
      }
      const fixtureName = this.fixtureNames[index];
      const color = this.colorNames.length === 1 ? this.colorNames[0] : this.colorNames[rng.randomInt(this.colorNames.length)];
      return FixtureDescriptions.getDescription(fixtureName, color);
    }
  };

  // src/model/generator/decorator/CavernDecorator.js
  var CavernDecorator = class {
    /**
     * 
     * @param {TileDecoratorTheme} ceilingDecoratorTheme
     * @param {TileDecoratorTheme} midDecoratorTheme
     * @param {TileDecoratorTheme} floorDecoratorTheme
     */
    constructor(ceilingDecoratorTheme, midDecoratorTheme, floorDecoratorTheme) {
      this.ceilingDecoratorTheme = ceilingDecoratorTheme;
      this.midDecoratorTheme = midDecoratorTheme;
      this.floorDecoratorTheme = floorDecoratorTheme;
    }
    /**
     * Decorates the cavern tile with foliage and whatever.
     * @param {GridTile} tile 
     * @param {MersenneTwister} rng
     */
    decorateCavernTile(tile, rng) {
      const grid = tile.grid;
      const topNeighbor = tile.getNeighborTop();
      const bottomNeighbor = tile.getNeighborBottom();
      const ceilingTile = topNeighbor && !topNeighbor.open && grid === topNeighbor.grid;
      const floorTile = bottomNeighbor && !bottomNeighbor.open && grid === bottomNeighbor.grid;
      let fixtureDescription = null;
      if (ceilingTile && floorTile) {
        if (this.midDecoratorTheme) {
          fixtureDescription = this.midDecoratorTheme.getFixtureDescription(rng);
        }
      } else if (ceilingTile) {
        if (this.ceilingDecoratorTheme) {
          fixtureDescription = this.ceilingDecoratorTheme.getFixtureDescription(rng);
        }
      } else if (floorTile) {
        if (this.floorDecoratorTheme) {
          fixtureDescription = this.floorDecoratorTheme.getFixtureDescription(rng);
        }
      } else if (this.midDecoratorTheme) {
        fixtureDescription = this.midDecoratorTheme.getFixtureDescription(rng);
      }
      tile.fixtureDescription = fixtureDescription;
    }
  };

  // src/model/generator/decorator/TerrainLayerDecoratorConfig.js
  var TerrainLayerDecoratorConfig = class {
    constructor() {
    }
    /**
     * 
     * @param {MersenneTwister} rng 
     * @returns {CavernDecorator[]}
     */
    getRandomLayerDecorator(rng) {
      const colorScheme1 = this.randomColorScheme(rng);
      const colorScheme2 = this.randomColorScheme(rng);
      return [
        new CavernDecorator(this.randomCeilingTheme(rng, colorScheme1), this.randomMidTheme(rng, colorScheme2), this.randomFloorTheme(rng, colorScheme2)),
        new CavernDecorator(this.randomCeilingTheme(rng, colorScheme2), null, this.randomFloorTheme(rng, colorScheme1))
      ];
    }
    /**
     * @private
     * @param {MersenneTwister} rng 
     * @param {string[]} colorScheme 
     * @returns {TileDecoratorTheme}
     */
    randomCeilingTheme(rng, colorScheme) {
      const fixtureTypeNames = CEILING[rng.randomInt(CEILING.length)];
      return new TileDecoratorTheme(fixtureTypeNames, colorScheme, 2);
    }
    /**
     * @private
     * @param {MersenneTwister} rng 
     * @param {string[]} colorScheme 
     * @returns {TileDecoratorTheme}
     */
    randomMidTheme(rng, colorScheme) {
      const fixtureTypeNames = MID[rng.randomInt(MID.length)];
      return new TileDecoratorTheme(fixtureTypeNames, colorScheme, 8);
    }
    /**
     * @private
     * @param {MersenneTwister} rng 
     * @param {string[]} colorScheme 
     * @returns {TileDecoratorTheme}
     */
    randomFloorTheme(rng, colorScheme) {
      const fixtureTypeNames = FLOOR[rng.randomInt(FLOOR.length)];
      return new TileDecoratorTheme(fixtureTypeNames, colorScheme, 2);
    }
    /**
     * @private
     * @param {MersenneTwister} rng 
     * @returns {string[]}
     */
    randomColorScheme(rng) {
      const colorScheme = [];
      colorScheme.push(this.functionRandomColor(rng));
      colorScheme.push(this.functionRandomColor(rng));
      colorScheme.push(this.functionRandomColor(rng));
      return colorScheme;
    }
    /**
     * @private
     * @param {MersenneTwister} rng 
     * @returns {string}
     */
    functionRandomColor(rng) {
      return FixtureSpriteColorArray[rng.randomInt(FixtureSpriteColorArray.length)];
    }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getDirtLayerDecorators() {
    //     const colorSchemes = [
    //         FixtureSpriteColors.GRAY_DARK_BROWN3_DARKER_BROWN,
    //         FixtureSpriteColors.BLUE_DARK_BLUE_LIGHT_GRAY,
    //         FixtureSpriteColors.DARK_GRAY_ORANGE_RED_BLUE, 
    //         FixtureSpriteColors.TAN_GREEN_DARK_GRAY_LIGHT_PURPLE1
    //     ];
    //     const colorSchemes2 = [
    //         FixtureSpriteColors.GRAY_DARK_BROWN3_DARKER_BROWN,
    //         FixtureSpriteColors.BLUE_DARK_BLUE_LIGHT_GRAY,
    //     ];
    //     const themeVinesTop = new TileDecoratorTheme(FTN.VINES_TOP, colorSchemes, 2);
    //     const themeVinesPartial = new TileDecoratorTheme(FTN.VINES_PARTIAL, colorSchemes2, 8);
    //     const themeGrass = new TileDecoratorTheme(FTN.FLOOR_GRASS, colorSchemes, 2);
    //     const themePlants = new TileDecoratorTheme(FTN.FLOOR_PLANTS, colorSchemes2, 2);
    //     return [
    //         new CavernDecorator(themeVinesTop, themeVinesPartial, themeGrass),
    //         new CavernDecorator(themeVinesPartial, themeVinesPartial, themePlants),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getGreySandstoneLayerDecorators() {
    //     const vineColors = [
    //         FixtureSpriteColors.GREEN_BLUE_LIME_GREEN1_BLUE,
    //         FixtureSpriteColors.LIGHT_PINK_DARK_PURPLE_YELLOW
    //     ]
    //     const colorSchemes = [
    //         FixtureSpriteColors.LIGHT_BROWN2_REDDISH_BROWN_ORANGE_BROWN,
    //         FixtureSpriteColors.YELLOW_ORANGE_DARK_GREEN2,
    //         FixtureSpriteColors.LIGHT_PINK_DARK_PURPLE_YELLOW
    //     ];
    //     const themeVinesTop = new TileDecoratorTheme(FTN.VINES_TOP, vineColors, 2);
    //     const themeVinesPartial = new TileDecoratorTheme(FTN.VINES_PARTIAL, colorSchemes, 8);
    //     const themePlants = new TileDecoratorTheme(FTN.FLOOR_PLANTS, colorSchemes, 2);
    //     const themeMushrooms = new TileDecoratorTheme(FTN.FLOOR_MUSHROOM, colorSchemes, 2);
    //     return [
    //         new CavernDecorator(themeVinesTop, null, themeMushrooms),
    //         new CavernDecorator(null, themeVinesPartial, themePlants),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getBlueStoneLayerDecorators() {
    //     const stalagColors = [
    //         FixtureSpriteColors.ORANGE_ORANGE_YELLOW_DARK_ORANGE,
    //         FixtureSpriteColors.BROWNISH_GREEN_DARK_RED_SUPER_DARK_GREEN
    //     ]
    //     const flowerColors = [
    //         FixtureSpriteColors.TAN_GREEN_DARK_GRAY_LIGHT_PURPLE1,
    //         FixtureSpriteColors.GREEN_BLUE_LIME_GREEN1_BLUE
    //     ];
    //     const grassColorSchemes = [
    //         FixtureSpriteColors.DARK_BROWN_RED_DARK_RED_RED
    //     ];
    //     const themeTop = new TileDecoratorTheme(FTN.STALACTITES, stalagColors, 2);
    //     const themeMid = new TileDecoratorTheme(FTN.WALL_FLOWERS, flowerColors, 8);
    //     const themeFloor1 = new TileDecoratorTheme(FTN.STALAGMITES, stalagColors, 2);
    //     const themeFloor2 = new TileDecoratorTheme(FTN.FLOOR_GRASS, grassColorSchemes, 2);
    //     return [
    //         new CavernDecorator(themeTop, themeMid, themeFloor2),
    //         new CavernDecorator(null, themeMid, themeFloor1),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getGreyOrangeGraniteLayerDecorators() {
    //     const stalagColors = [
    //         FixtureSpriteColors.DARK_BROWN1_GREY_ORANGE_BROWN,
    //         FixtureSpriteColors.LIGHT_BROWN2_REDDISH_BROWN_ORANGE_BROWN
    //     ]
    //     const vineColors = [
    //         FixtureSpriteColors.LIME_GREEN2_BROWNISH_GREEN_DARK_RED_ORANGE,
    //         FixtureSpriteColors.LIGHT_PURPLE2_DARKER_PURPLE_LIGHT_YELLOW
    //     ];
    //     const grassColorSchemes = [
    //         FixtureSpriteColors.GREY_BLUE_GREEN_LIME_GREEN2_YELLOW_BROWN,
    //         FixtureSpriteColors.DARK_ORANGE_DARK_GRAY_LIGHTER_GRAY
    //     ];
    //     const ceilingPokies = new TileDecoratorTheme(FTN.CEILING_POKIES, stalagColors, 2);
    //     const topVines = new TileDecoratorTheme(FTN.VINES_TOP, vineColors, 2);
    //     const grassTheme = new TileDecoratorTheme(FTN.FLOOR_GRASS, grassColorSchemes, 2);
    //     return [
    //         new CavernDecorator(ceilingPokies, null, grassTheme),
    //         new CavernDecorator(topVines, null, grassTheme),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getArkoseLayerDecorators() {
    //     const stalagColors = [
    //         FixtureSpriteColors.DARK_GRAY_LIGHT_GRAY_DARK_RED_PINK,
    //         FixtureSpriteColors.GREY_BLUE_GREEN_LIME_GREEN2_YELLOW_BROWN
    //     ]
    //     const ceilingPokieColors = [
    //         FixtureSpriteColors.DARK_GRAY_LIGHT_GRAY_DARK_RED_PINK,
    //         FixtureSpriteColors.GREEN_DARK_GREEN1_DARK_GREEN2
    //     ]
    //     const holeColors = [
    //         FixtureSpriteColors.LIGHT_BROWN2_REDDISH_BROWN_ORANGE_BROWN,
    //         FixtureSpriteColors.ORANGE_BROWN_REDDISH_BROWN_LIGHT_BROWN2
    //     ];
    //     const floorPokiesColors = [
    //         FixtureSpriteColors.BLUE_DARK_BLUE_LIGHT_GRAY,
    //         FixtureSpriteColors.DARK_BROWN1_GREY_ORANGE_BROWN
    //     ];
    //     const ceilingPokies = new TileDecoratorTheme(FTN.CEILING_POKIES, ceilingPokieColors, 1);
    //     const stalactites = new TileDecoratorTheme(FTN.STALACTITES, stalagColors, 2);
    //     const wallHoles = new TileDecoratorTheme(FTN.WALL_HOLES, holeColors, 5);
    //     const floorPokies = new TileDecoratorTheme(FTN.FLOOR_POKIES, floorPokiesColors, 1);
    //     return [
    //         new CavernDecorator(ceilingPokies, wallHoles, floorPokies),
    //         new CavernDecorator(stalactites, null, floorPokies),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getPurpleGreyGraniteLayerDecorators() {
    //     const stalagColors = [
    //         FixtureSpriteColors.DARK_GRAY_LIGHT_GRAY_DARK_RED_PINK,
    //         FixtureSpriteColors.GREY_BLUE_GREEN_LIME_GREEN2_YELLOW_BROWN
    //     ]
    //     const ceilingGrassColors = [
    //         FixtureSpriteColors.BLUE_DARK_BLUE_PURPLE,
    //         FixtureSpriteColors.GREEN_DARK_GREEN1_DARK_GREEN2
    //     ]
    //     const floorSpikeColors = [
    //         FixtureSpriteColors.LIME_GREEN2_BROWNISH_GREEN_DARK_RED_ORANGE,
    //         FixtureSpriteColors.ORANGE_ORANGE_YELLOW_DARK_ORANGE
    //     ];
    //     const ceilingGrass = new TileDecoratorTheme(FTN.CEILING_GRASS, ceilingGrassColors, 1);
    //     const stalactites = new TileDecoratorTheme(FTN.STALACTITES, stalagColors, 2);
    //     const floorSpikes = new TileDecoratorTheme(FTN.FLOOR_SPIKES, floorSpikeColors, 1);
    //     return [
    //         new CavernDecorator(ceilingGrass, null, floorSpikes),
    //         new CavernDecorator(stalactites, null, floorSpikes),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getGreenQuartzLayerDecorators() {
    //     const vineColors = [
    //         FixtureSpriteColors.ORANGE_ORANGE_YELLOW_DARK_ORANGE,
    //         FixtureSpriteColors.TEAL_LIGHT_BLUE1_PALE_AQUA
    //     ]
    //     const ceilingPokiesColors = [
    //         FixtureSpriteColors.SKY_BLUE_PALE_BLUE_LIGHT_BLUE2,
    //         FixtureSpriteColors.TEAL_LIGHT_BLUE1_PALE_AQUA
    //     ]
    //     const tallGrassColors = [
    //         FixtureSpriteColors.LIGHT_PURPLE1_ORANGE_RED_PURPLE,
    //         FixtureSpriteColors.ORANGE_RED_VERY_DARK_RED_SUPER_DARK_RED
    //     ];
    //     const ceilingPokies = new TileDecoratorTheme(FTN.CEILING_POKIES, ceilingPokiesColors, 1);
    //     const vineTops = new TileDecoratorTheme(FTN.VINES_TOP, vineColors, 2);
    //     const tallGrass = new TileDecoratorTheme(FTN.TALL_GRASS, tallGrassColors, 2);
    //     return [
    //         new CavernDecorator(ceilingPokies, null, tallGrass),
    //         new CavernDecorator(vineTops, null, tallGrass),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getDarkIronStoneLayerDecorators() {
    //     const stalactiteColors = [
    //         FixtureSpriteColors.GREEN_BLUE_LIME_GREEN1_BLUE,
    //         FixtureSpriteColors.YELLOW_ORANGE_DARK_GREEN2
    //     ]
    //     const flowerColors = [
    //         FixtureSpriteColors.SKY_BLUE_PALE_BLUE_LIGHT_BLUE2,
    //         FixtureSpriteColors.LIGHT_PINK_DARK_PURPLE_YELLOW
    //     ];
    //     const mushroomColors = [
    //         FixtureSpriteColors.TAN_GREEN_DARK_GRAY_LIGHT_PURPLE1,
    //         FixtureSpriteColors.BLUE_ORANGE_YELLOW_PURPLE
    //     ];
    //     const ceilingStalagtites = new TileDecoratorTheme(FTN.STALACTITES, stalactiteColors, 2);
    //     ///////const vineTops = new TileDecoratorTheme(FTN.VINES_TOP, vineColors, 2);
    //     const flowers = new TileDecoratorTheme(FTN.FLOWERS, flowerColors, 2);
    //     const mushrooms = new TileDecoratorTheme(FTN.FLOOR_MUSHROOM, mushroomColors, 2);
    //     return [
    //         new CavernDecorator(ceilingStalagtites, null, flowers),
    //         new CavernDecorator(ceilingStalagtites, null, mushrooms),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getRedSunstoneLayerDecorators() {
    //     const ceilingColors = [
    //         FixtureSpriteColors.LIGHT_BLUE_GREEN_BROWNISH_GREEN_LIME_GREEN2,
    //         FixtureSpriteColors.LIGHT_PINK_DARK_PURPLE_YELLOW
    //     ]
    //     const plantColors = [
    //         FixtureSpriteColors.LIGHT_YELLOW_YELLOW_ORANGE_YELLOW,
    //         FixtureSpriteColors.TEAL_LIGHT_BLUE1_PALE_AQUA
    //     ];
    //     const grassColors = [
    //         FixtureSpriteColors.SKY_BLUE_PALE_BLUE_LIGHT_BLUE2,
    //         FixtureSpriteColors.LIGHT_PURPLE1_ORANGE_RED_PURPLE
    //     ];
    //     const ceilingPokies = new TileDecoratorTheme(FTN.CEILING_POKIES, ceilingColors, 2);
    //     const ceilingSpikes = new TileDecoratorTheme(FTN.CEILING_SPIKES, ceilingColors, 2);
    //     const curvedPlants = new TileDecoratorTheme(FTN.CURVED_PLANTS, plantColors, 2);
    //     const tallGrass = new TileDecoratorTheme(FTN.TALL_GRASS, grassColors, 2);
    //     return [
    //         new CavernDecorator(ceilingPokies, null, curvedPlants),
    //         new CavernDecorator(ceilingSpikes, null, tallGrass),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getPinkGraniteLayerDecorators() {
    //     const ceilingColors = [
    //         FixtureSpriteColors.LIGHT_YELLOW_YELLOW_ORANGE_YELLOW,
    //         FixtureSpriteColors.SKY_BLUE_PALE_BLUE_LIGHT_BLUE2
    //     ]
    //     const mushroomColors = [
    //         FixtureSpriteColors.DARKER_PURPLE_LIGHT_PURPLE2_LIGHT_YELLOW,
    //         FixtureSpriteColors.PURPLE_VERY_DARK_RED_SUPER_DARK_RED
    //     ];
    //     const pokiesColors = [
    //         FixtureSpriteColors.YELLOW_ORANGE_DARK_GREEN2,
    //         FixtureSpriteColors.LIME_GREEN1_DARK_BLUE_DARK_GRAY
    //     ];
    //     const ceilingStalctites = new TileDecoratorTheme(FTN.STALACTITES, ceilingColors, 2);
    //     const ceilingVines = new TileDecoratorTheme(FTN.VINES_TOP, ceilingColors, 2);
    //     const floorMushrooms = new TileDecoratorTheme(FTN.FLOOR_MUSHROOM, mushroomColors, 2);
    //     const floorPokies = new TileDecoratorTheme(FTN.FLOOR_POKIES, pokiesColors, 2);
    //     return [
    //         new CavernDecorator(ceilingStalctites, null, floorMushrooms),
    //         new CavernDecorator(ceilingVines, null, floorPokies),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getBlueQuartzLayerDecorators() {
    //     const ceilingGrassColors = [
    //         FixtureSpriteColors.LIGHT_BROWN2_BROWN3_YELLOW_BROWN,
    //         FixtureSpriteColors.LIGHT_YELLOW_YELLOW_ORANGE_YELLOW
    //     ]
    //     const ceilingPokiesColors = [
    //         FixtureSpriteColors.DARK_GRAY_ORANGE_RED_BLUE,
    //         FixtureSpriteColors.DARK_GRAY_LIGHT_PURPLE1_TAN_GREEN
    //     ]
    //     const grassColors = [
    //         FixtureSpriteColors.DARK_GRAY_ORANGE_RED_BLUE,
    //         FixtureSpriteColors.ORANGE_BROWN_REDDISH_BROWN_LIGHT_BROWN2
    //     ];
    //     const plantsColors = [
    //         FixtureSpriteColors.YELLOW_ORANGE_DARK_GREEN2,
    //         FixtureSpriteColors.VERY_DARK_GREEN_TAN_WHITE_YELLOW
    //     ];
    //     const ceilingGrass = new TileDecoratorTheme(FTN.CEILING_GRASS, ceilingGrassColors, 2);
    //     const ceilingPokies = new TileDecoratorTheme(FTN.CEILING_POKIES, ceilingPokiesColors, 2);
    //     const floorGrass = new TileDecoratorTheme(FTN.FLOOR_GRASS, grassColors, 2);
    //     const floorPlants = new TileDecoratorTheme(FTN.FLOOR_PLANTS, plantsColors, 2);
    //     return [
    //         new CavernDecorator(ceilingGrass, null, floorGrass),
    //         new CavernDecorator(ceilingPokies, null, floorPlants),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getBrownBasaltLayerDecorators() {
    //     const ceilingSpikesColors = [
    //         FixtureSpriteColors.SKY_BLUE_BROWNISH_GREEN_LIME_GREEN2,
    //         FixtureSpriteColors.LIGHT_PURPLE1_ORANGE_RED_PURPLE
    //     ]
    //     const ceilingStalagtiteColors = [
    //         FixtureSpriteColors.LIME_GREEN2_BROWNISH_GREEN_DARK_RED_ORANGE,
    //         FixtureSpriteColors.LIGHT_BLUE_GREEN_BROWNISH_GREEN_LIME_GREEN2
    //     ]
    //     const grassColors = [
    //         FixtureSpriteColors.ORANGE_YELLOW_YELLOW_BROWN_TAN_GREEN,
    //         FixtureSpriteColors.GREY_BLUE_GREEN_LIME_GREEN2_YELLOW_BROWN
    //     ];
    //     const stalagmitesColors = [
    //         FixtureSpriteColors.PURPLE_VERY_DARK_RED_SUPER_DARK_RED,
    //         FixtureSpriteColors.ORANGE_RED_VERY_DARK_RED_SUPER_DARK_RED
    //     ];
    //     const ceilingSpikes = new TileDecoratorTheme(FTN.CEILING_SPIKES, ceilingSpikesColors, 2);
    //     const ceilingStalagtites = new TileDecoratorTheme(FTN.STALACTITES, ceilingStalagtiteColors, 2);
    //     const floorStalagmites = new TileDecoratorTheme(FTN.STALAGMITES, stalagmitesColors, 2);
    //     const floorGrass = new TileDecoratorTheme(FTN.FLOOR_GRASS, grassColors, 2);
    //     return [
    //         new CavernDecorator(ceilingSpikes, null, floorStalagmites),
    //         new CavernDecorator(ceilingStalagtites, null, floorGrass),
    //     ];
    // }
    // /**
    //  * @returns {Array.<CavernDecorator>}
    //  */
    // getDarkGreenSerpentineLayerDecorators() {
    //     const ceilingSpikesColors = [
    //         FixtureSpriteColors.DARK_GRAY_DARK_ORANGE_LIGHTER_GRAY,
    //         FixtureSpriteColors.TEAL_LIGHT_BLUE1_PALE_AQUA
    //     ]
    //     const ceilingPokiesColors = [
    //         FixtureSpriteColors.DARK_BROWN_RED_DARK_RED_RED,
    //         FixtureSpriteColors.DARK_GRAY_ORANGE_RED_BLUE
    //     ]
    //     const grassColors = [
    //         FixtureSpriteColors.SKY_BLUE_PALE_BLUE_LIGHT_BLUE2,
    //         FixtureSpriteColors.LIGHT_BROWN2_REDDISH_BROWN_ORANGE_BROWN
    //     ];
    //     const curvedPlantsColors = [
    //         FixtureSpriteColors.ORANGE_BROWN_REDDISH_BROWN_LIGHT_BROWN2,
    //         FixtureSpriteColors.DARKER_PURPLE_LIGHT_PURPLE2_LIGHT_YELLOW
    //     ];
    //     const ceilingPokies = new TileDecoratorTheme(FTN.CEILING_POKIES, ceilingPokiesColors, 2);
    //     const ceilingSpikes = new TileDecoratorTheme(FTN.CEILING_SPIKES, ceilingSpikesColors, 2);
    //     const floorGrass = new TileDecoratorTheme(FTN.FLOOR_GRASS, grassColors, 2);
    //     const floorCurvedPlants = new TileDecoratorTheme(FTN.CURVED_PLANTS, curvedPlantsColors, 2);
    //     return [
    //         new CavernDecorator(ceilingSpikes, null, floorCurvedPlants),
    //         new CavernDecorator(ceilingPokies, null, floorGrass),
    //     ];
    // }
  };

  // src/model/generator/TerrainGenerator.js
  var TerrainGenerator = class {
    constructor() {
    }
    /**
     * @abstract
     * @param {Grid} grid 
     */
    generateTerrain(grid) {
    }
    /**
     * When we load a grid from the save file, we need to generate the background,
     * because that isn't in the save file but can be derived form the tile types.
     * @param {Grid} grid 
     */
    generateTileBackgrounds(grid) {
    }
  };

  // src/model/generator/LayeredTerrainGenerator.js
  var LayeredTerrainGenerator = class extends TerrainGenerator {
    /**
     * @param {number} worldSeed 
     * @param {CharacterCreator} characterCreator
     */
    constructor(worldSeed, characterCreator) {
      super();
      let terrainSeed = worldSeed;
      this.cavernFbmA = new FractionalBrownianMotion(terrainSeed++, 0.9, 2, 1.2, 5, 41e-5);
      this.cavernValueAMin = -6;
      this.cavernValueAMax = -1.3;
      this.cavernFbmB = new FractionalBrownianMotion(terrainSeed++, 1.2, 1.25, 0.9, 5, 261e-5);
      this.cavernValueBMin = 0.8;
      this.cavernValueBMax = 4.1;
      this.oreFbm = new FractionalBrownianMotion(terrainSeed++, 1, 1.5, 1.4, 5, 2e-3);
      this.pointsFbm = new FractionalBrownianMotion(terrainSeed++, 1, 1.6, 1.3, 5, 1e-3);
      this.upgradeFbm = new FractionalBrownianMotion(terrainSeed++, 1, 1.6, 1.4, 5, 1e-3);
      this.rubyFbm = new FractionalBrownianMotion(terrainSeed++, 1, 1.6, 1.4, 5, 1e-3);
      this.backgroundFbm = new FractionalBrownianMotion(terrainSeed++, 1, 2.1, 0.7, 5, 5e-4);
      const grassAndDirtFbm = new FractionalBrownianMotion(terrainSeed++, 0.7, 3.5, 0.8, 5, 1e-5);
      this.indexGenerator = new IndexGenerator(worldSeed);
      this.characterCreator = characterCreator;
      this.terrainLayers = [];
      for (let i = 0; i < LayerDescriptionArray.length; i++) {
        const layerDescription = LayerDescriptionArray[i];
        if (layerDescription === LayerDescriptions.SKY_LAYER) {
          this.terrainLayers.push(new SkyTerrainLayer(SpecialTileTypes.SKY, layerDescription));
        } else if (layerDescription === LayerDescriptions.GRASS_LAYER) {
          this.terrainLayers.push(new GrassTerrainLayer(layerDescription, grassAndDirtFbm));
        } else if (layerDescription === LayerDescriptions.DIRT_LAYER) {
          this.terrainLayers.push(new DirtTerrainLayer(layerDescription, grassAndDirtFbm));
        } else {
          const goldGenerated = i > 10;
          const rubyGenerated = i > 20;
          this.terrainLayers.push(new BasicTerrainLayer(layerDescription, new FractionalBrownianMotion(terrainSeed++, 1, 3.5, 0.9, 5, 5e-5), goldGenerated, rubyGenerated));
        }
      }
      this.terrainLayerById = {};
      for (let i = 0; i < this.terrainLayers.length; i++) {
        const layer = this.terrainLayers[i];
        const layerDescription = layer.getLayerDescription();
        if (!layerDescription) {
          console.log("LayeredTerrainGenerator No layer description for layer index: " + i);
          continue;
        }
        this.terrainLayerById[layerDescription.id] = layer;
      }
      this.cavernDecoratorsByLayer = {};
      this.layerDecoratorConfig = new TerrainLayerDecoratorConfig();
      this.rng = new MersenneTwister(terrainSeed);
      for (let i = 0; i < LayerDescriptionArray.length; i++) {
        const layerDescription = LayerDescriptionArray[i];
        if (layerDescription === LayerDescriptions.SKY_LAYER) {
          continue;
        }
        if (layerDescription === LayerDescriptions.GRASS_LAYER) {
          this.cavernDecoratorsByLayer[layerDescription.id] = [];
        } else {
          this.cavernDecoratorsByLayer[layerDescription.id] = this.layerDecoratorConfig.getRandomLayerDecorator(this.rng);
        }
      }
    }
    /**
     * @override
     * @param {Grid} grid 
     */
    generateTerrain(grid) {
      const gridTerrainLayers = this.findApplicableTerrainLayersForGrid(grid);
      const zones = grid.zones;
      for (let i = 0; i < zones.length; i++) {
        const zone = zones[i];
        const regions = zone.regions;
        for (let r = 0; r < regions.length; r++) {
          const tiles = regions[r].tiles;
          for (let t = 0; t < tiles.length; t++) {
            this.assignTileTerrain(tiles[t], gridTerrainLayers);
          }
        }
      }
      for (let i = 0; i < zones.length; i++) {
        const zone = zones[i];
        const regions = zone.regions;
        for (let r = 0; r < regions.length; r++) {
          const tiles = regions[r].tiles;
          for (let t = 0; t < tiles.length; t++) {
            const tile = tiles[t];
            if (!tile.open || tile.fixtureDescription) {
              continue;
            }
            this.assignCavernDecorationToTile(tile);
          }
        }
      }
    }
    /**
     * When we load a grid from the save file, we need to generate the background,
     * because that isn't in the save file but can be derived form the tile types.
     * @param {Grid} grid 
     */
    generateTileBackgrounds(grid) {
      this.generateBackground(grid);
    }
    /**
     * @param {GridTile} tile
     * @returns {boolean}
     */
    isTileCavern(tile) {
      const tileType = tile.tileType;
      if (!tileType) {
        console.log("LayeredTerrainGenerator.isTileCavern() no tile type");
        return;
      }
      const layerDescription = tileType.layerDescription;
      if (!layerDescription) {
        console.log("LayeredTerrainGenerator.isTileCavern() no layer desc. tileType.icon=" + tileType.iconFileName);
        return;
      }
      const terrainLayer = this.terrainLayerById[layerDescription.id];
      if (!terrainLayer) {
        console.log("LayeredTerrainGenerator.isTileCavern() no terrain layer. id=" + layerDescription.id);
        return;
      }
      const origin = tile.origin;
      const cavernValueA = this.cavernFbmA.calculateNoise(origin.x, origin.y);
      if (cavernValueA > this.cavernValueAMin && cavernValueA < this.cavernValueAMax) {
        return true;
      }
      const cavernValueB = this.cavernFbmB.calculateNoise(origin.x / 2, origin.y * 2);
      return cavernValueB > this.cavernValueBMin && cavernValueB < this.cavernValueBMax;
    }
    /////////////////////////////////////////
    // Tile Background
    /////////////////////////////////////////
    /**
     * @private
     * @param {Grid} grid 
     */
    generateBackground(grid) {
      const thisRef = this;
      GridInversionOfControl.allTilesInGrid(
        grid,
        /** 
         * @param {GridTile} tile 
         */
        function(tile) {
          thisRef.assignTileBackgroundSprite(tile);
        }
      );
    }
    /**
     * Assign a background sprite to the tile based on the primary tile type of the terrain layer that the tile is associated with.
     * @private
     * @param {GridTile} tile 
     */
    assignTileBackgroundSprite(tile) {
      const tileType = tile.tileType;
      if (!tileType) {
        console.log("LayeredTerrainGenerator.setTileBackground() ERROR Tile has no TileType!");
        return;
      }
      const layerDescription = tileType.layerDescription;
      if (layerDescription) {
        tile.backgroundSprite = this.getBackgroundSprite(tile.origin, layerDescription.primaryTileType.tileTypeBackground);
      } else if (tileType.tileTypeBackground) {
        tile.backgroundSprite = this.getBackgroundSprite(tile.origin, tileType.tileTypeBackground);
      }
    }
    /**
     * @private
     * @param {Vector} origin 
     * @param {TileTypeBackground} tileTypeBackground
     * @returns {Sprite}
     */
    getBackgroundSprite(origin, tileTypeBackground) {
      const value2 = Math.abs(this.backgroundFbm.calculateNoise(origin.x, origin.y) + 1);
      const x = Math.min(Math.max(0, value2 / 3.25), 1);
      const index = x * (tileTypeBackground.sprites.length - 1) | 0;
      return tileTypeBackground.sprites[index];
    }
    /////////////////////////////////////////
    // Cavern Decoration
    /////////////////////////////////////////
    /**
     * @private
     * @param {GridTile} tile 
     */
    assignCavernDecorationToTile(tile) {
      const tileType = tile.tileType;
      if (!tileType) {
        return;
      }
      const layerDescription = tileType.layerDescription;
      if (!layerDescription) {
        return;
      }
      const cavernDecorators = this.cavernDecoratorsByLayer[layerDescription.id];
      if (!cavernDecorators || cavernDecorators.length === 0) {
        return;
      }
      const origin = tile.origin;
      const cavernDecorator = cavernDecorators[this.indexGenerator.getIndexFromFbm(origin.x, origin.y, cavernDecorators.length)];
      cavernDecorator.decorateCavernTile(tile, this.rng);
      if (layerDescription.monsterDescriptions.length > 0 && this.rng.random() < 0.01) {
        const monsterDescription = layerDescription.monsterDescriptions[this.rng.randomInt(layerDescription.monsterDescriptions.length)];
        this.characterCreator.createMonsterAtTile(monsterDescription, tile);
      }
    }
    /////////////////////////////////////////
    // Tile Terrain
    /////////////////////////////////////////
    /**
     * @private
     * @param {GridTile} tile 
     * @param {Array.<TerrainLayer>} gridTerrainLayers
     */
    assignTileTerrain(tile, gridTerrainLayers) {
      const terrainLayer = this.findTerrainLayerForTile(tile, gridTerrainLayers);
      if (!terrainLayer) {
        return;
      }
      terrainLayer.assignTileTerrain(tile, false);
      if (this.isTileCavern(tile)) {
        tile.open = true;
      } else {
        this.assignTypeForNonCavernTile(tile, terrainLayer);
      }
      this.assignTileBackgroundSprite(tile);
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @param {TerrainLayer} terrainLayer 
     */
    assignTypeForNonCavernTile(tile, terrainLayer) {
      const origin = tile.origin;
      const rand = this.rng.random();
      if (rand < 0.8 && terrainLayer.isOreTileSupported()) {
        const lesserValue = this.oreFbm.calculateNoise(origin.y, origin.x / 3);
        if (lesserValue < -3.55) {
          terrainLayer.assignTileToOreType(tile);
          return;
        }
      }
      if (rand < 0.4 && terrainLayer.isGoldTileSupported()) {
        const greaterValue = this.pointsFbm.calculateNoise(origin.x, origin.y);
        if (greaterValue < -3.5) {
          terrainLayer.assignTileToGoldType(tile);
          return;
        }
      }
      if (rand < 0.02 && terrainLayer.isUpgradeTileSupported()) {
        const rareValue = this.upgradeFbm.calculateNoise(origin.x, origin.y);
        if (rareValue < -3) {
          terrainLayer.assignTileToUpgradeType(tile);
          return;
        }
      }
      if (rand < 0.01 && terrainLayer.isRubyTileSupported()) {
        const greaterValue = this.rubyFbm.calculateNoise(origin.x, origin.y);
        if (greaterValue < -3) {
          terrainLayer.assignTileToRubyType(tile);
          return;
        }
      }
    }
    /**
     * Finds the subset of the tile layers that could possibly be applied to the grid tiles.
     * @private
     * @param {Grid} grid 
     * @returns {Array.<TerrainLayer>}
     */
    findApplicableTerrainLayersForGrid(grid) {
      const minGridTileDepth = grid.origin.y / Settings.tile.size;
      const maxGridTileDepth = minGridTileDepth + Settings.grid.gridTileHeight;
      const gridLayers = [];
      for (let i = 0; i < this.terrainLayers.length; i++) {
        const layer = this.terrainLayers[i];
        if (layer.isLayerForGrid(minGridTileDepth, maxGridTileDepth)) {
          gridLayers.push(layer);
        }
      }
      return gridLayers;
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @param {Array.<TerrainLayer>} gridTileLayers
     * @returns {TerrainLayer}
     */
    findTerrainLayerForTile(tile, gridTileLayers) {
      const tileDepth = tile.origin.y / Settings.tile.size;
      for (let i = gridTileLayers.length - 1; i >= 0; i--) {
        const layer = gridTileLayers[i];
        if (layer.isLayerForTile(tile, tileDepth)) {
          return layer;
        }
      }
      if (gridTileLayers.length > 0) {
        return gridTileLayers[0];
      }
      return null;
    }
  };

  // src/model/save/GridSave.js
  var LZString = __toESM(require_lz_string());
  var GridSave = class {
    /**
     * @param {CharacterCreator} characterCreator
     */
    constructor(characterCreator) {
      this.characterCreator = characterCreator;
    }
    /**
     * @param {Grid} grid 
     * @returns {string}
     */
    getGridKey(grid) {
      const col = grid.getGridCol();
      const row = grid.getGridRow();
      const colSign = col >= 0 ? "" : "n";
      const rowSign = row >= 0 ? "" : "n";
      return "G_" + colSign + Math.abs(col) + "_" + rowSign + Math.abs(row);
    }
    /**
     * @param {Grid} grid 
     * @returns {Object}
     */
    generateGridStateForExport(grid) {
      if (!grid) {
        console.log("GridSave.generateGridStateForExport() Null grid");
        return null;
      }
      const gridJson = this.generateState(grid);
      if (!gridJson) {
        console.log("GridSave.generateGridStateForExport() Failed to generate grid state");
        return null;
      }
      const gridKey = this.getGridKey(grid);
      return {
        key: gridKey,
        origin: {
          x: grid.origin.x,
          y: grid.origin.y
        },
        state: gridJson
      };
    }
    /**
     * @param {Grid} grid 
     * @param {Object} gridState 
     * @returns {boolean}
     */
    importGridState(grid, gridState) {
      if (!grid) {
        console.log("GridSave.importGridState() FAIL. grid is null");
        return false;
      }
      const origin = gridState.origin;
      grid.origin.set(origin.x, origin.y);
      grid.initializeZonesForGrid();
      this.loadStateInternal(grid, gridState.state);
      return true;
    }
    /**
     * @param {Grid} grid 
     * @returns {boolean}
     */
    saveGridState(grid) {
      if (grid.gridChangeCount === 0) {
        return;
      }
      const gridJson = this.generateState(grid);
      if (!gridJson) {
        console.log("GridSave.saveGridState() Failed to generate grid state");
        return false;
      }
      const gridKey = this.getGridKey(grid);
      const gridJsonString = JSON.stringify(gridJson);
      if (!gridJsonString) {
        console.log("GridSave.saveGridState() Failed to stringify state for grid: " + gridKey);
        return false;
      }
      const compressedStateString = LZString.compressToUTF16(gridJsonString);
      if (!compressedStateString) {
        console.log("GridSave.saveGridState() Failed to compress state for grid: " + gridKey);
        return false;
      }
      localStorage.setItem(gridKey, compressedStateString);
      return true;
    }
    /**
     * Removes the save state for the grid.
     * @param {string} gridKey 
     */
    removeGridState(gridKey) {
      localStorage.removeItem(gridKey);
    }
    /**
     * @param {Grid} grid 
     * @returns {boolean} True if the grid has save data, false otherwise.
     */
    loadGridState(grid) {
      const gridKey = this.getGridKey(grid);
      const compressedStateString = localStorage.getItem(gridKey);
      if (compressedStateString) {
        const gridJsonString = LZString.decompressFromUTF16(compressedStateString);
        if (gridJsonString) {
          const gridJson = JSON.parse(gridJsonString);
          if (gridJson) {
            this.loadStateInternal(grid, gridJson);
            return true;
          } else {
            console.log("GridSave.loadGridState() Failed to parse grid json.  grid: " + gridKey);
          }
        } else {
          console.log("GridSave.loadGridState() Failed to decompress grid save state. grid: " + gridKey);
        }
      }
      return false;
    }
    /**
     * @private
     * @param {Grid} grid 
     * @return {Object}
     */
    generateState(grid) {
      const gridState = {};
      gridState.tiles = this.generateTileStateArray(grid);
      gridState.characters = this.generateCharacterStateArray(grid);
      return gridState;
    }
    /**
     * @private
     * @param {Grid} grid 
     * @param {Object} gridState 
     */
    loadStateInternal(grid, gridState) {
      this.loadTileStateArray(grid, gridState.tiles);
      this.loadCharacterStateArray(grid, gridState.characters);
    }
    /**
     * @private
     * @param {Grid} grid 
     * @returns {Array.<Object>}
     */
    generateTileStateArray(grid) {
      const thisRef = this;
      const stateArray = [];
      GridInversionOfControl.allTilesInGrid(
        grid,
        /**
         * @param {GridTile} tile 
         */
        (tile) => {
          stateArray.push(thisRef.generateTileState(tile));
        }
      );
      return stateArray;
    }
    /**
     * @private
     * @param {Grid} grid 
     * @param {Array.<Object>} tilesStateArray
     */
    loadTileStateArray(grid, tilesStateArray) {
      if (!tilesStateArray) {
        console.log("GridSave.loadTileStateArray() no tile state array");
        return;
      }
      let i = 0;
      const thisRef = this;
      GridInversionOfControl.allTilesInGrid(
        grid,
        /**
         * @param {GridTile} tile 
         */
        (tile) => {
          thisRef.loadTileState(tile, tilesStateArray[i]);
          i++;
        }
      );
    }
    /**
     * @private
     * @param {Grid} grid 
     * @returns {Array.<Object>}
     */
    generateCharacterStateArray(grid) {
      const stateArray = [];
      if (grid.characters.length === 0) {
        return stateArray;
      }
      const tileCol = grid.getOriginTileCol();
      const tileRow = grid.getOriginTileRow();
      for (let i = 0; i < grid.characters.length; i++) {
        const character = grid.characters[i];
        if (!character.isMonster()) {
          continue;
        }
        const characterState = this.generateCharacterState(tileCol, tileRow, character);
        if (characterState) {
          stateArray.push(characterState);
        }
      }
      return stateArray;
    }
    /**
     * @private
     * @param {Grid} grid 
     * @param {Array.<Object>} characterStateArray 
     */
    loadCharacterStateArray(grid, characterStateArray) {
      if (!characterStateArray || characterStateArray.length === 0) {
        return;
      }
      for (let i = 0; i < characterStateArray.length; i++) {
        this.loadCharacterState(grid, characterStateArray[i]);
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @returns {Object}
     */
    generateTileState(tile) {
      const tileState = {};
      let tileBits = 0;
      if (tile.open) {
        tileBits += 1;
      }
      if (tile.lighting.sunlightFull) {
        tileBits += 2;
      }
      if (tile.lighting.sunlightPartial) {
        tileBits += 4;
      }
      if (tile.lighting.everVisibleToCharacter) {
        tileBits += 8;
      }
      tileState.a = tileBits;
      tileState.b = tile.tileType.id;
      if (tile.fixtureDescription) {
        tileState.f = {
          t: tile.fixtureDescription.typeName,
          c: tile.fixtureDescription.colorName
        };
      }
      return tileState;
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @param {Object} tileState 
     */
    loadTileState(tile, tileState) {
      if (!tileState) {
        console.log("GridSave.loadTileState() no tile state");
        return;
      }
      const tileBits = tileState.a;
      const tileTypeId = tileState.b;
      const open = (tileBits & 1) === 1;
      const tileType = TileTypeMap[tileTypeId];
      tile.tileInit(open, tileType);
      const sunlightFull = (tileBits & 2) === 2;
      const sunlightPartial = (tileBits & 4) === 4;
      const everVisibleToCharacter = (tileBits & 8) === 8;
      tile.lighting.sunlightPartial = sunlightPartial;
      if (sunlightFull) {
        tile.markAsSunlightFull();
      }
      if (everVisibleToCharacter) {
        tile.markTileAsEverVisible();
      }
      if (tileState.f) {
        const typeName = tileState.f.t;
        const colorName = tileState.f.c;
        tile.fixtureDescription = FixtureDescriptions.getDescription(typeName, colorName);
      }
    }
    /**
     * @private
     * @param {number} gridTileCol
     * @param {number} gridTileRow
     * @param {Character} character 
     * @returns {Object}
     */
    generateCharacterState(gridTileCol, gridTileRow, character) {
      const tile = character.position.tile;
      if (!tile) {
        console.log("GridSave.generateCharacterState() character tile is null");
        return null;
      }
      const characterState = {};
      characterState.c = tile.getTileCol() - gridTileCol;
      characterState.r = tile.getTileRow() - gridTileRow;
      characterState.d = character.getMonsterDescriptionId();
      return characterState;
    }
    /**
     * @private
     * @param {Grid} grid
     * @param {Object} characterState 
     * @returns {Character}
     */
    loadCharacterState(grid, characterState) {
      if (!characterState) {
        return;
      }
      const tileCol = characterState.c;
      const tileRow = characterState.r;
      const monsterDescriptionId = characterState.d;
      const tile = grid.getGridTileLocal(tileCol, tileRow);
      if (!tile) {
        console.log("GridSave.loadCharacterState() Failed to find tile for character.  tileCol=" + tileCol + " tileRow=" + tileRow);
        return;
      }
      const monsterDescription = MonsterDescriptionMap[monsterDescriptionId];
      if (!monsterDescription) {
        console.log("GridSave.loadCharacterState() Failed to find monster description: " + monsterDescriptionId);
        return;
      }
      this.characterCreator.createMonsterAtTile(monsterDescription, tile);
    }
  };

  // src/model/save/GridSaveMeta.js
  var GridSaveMeta = class {
    /**
     * @param {string} gridKey
     * @param {number} gridCol
     * @param {number} gridRow
     */
    constructor(gridKey, gridCol, gridRow) {
      this.gridKey = gridKey;
      this.gridCol = gridCol;
      this.gridRow = gridRow;
    }
  };

  // src/model/save/GridSaveManager.js
  var GridSaveManager = class extends GameModel {
    /**
     * 
     * @param {GridSave} gridSave 
     */
    constructor(gridSave) {
      super();
      this.metadataByKey = /* @__PURE__ */ new Map();
      this.gridSave = gridSave;
      this.maxSizeThreshold = 50;
      this.farColThreshold = 8;
      this.farRowThreshold = 6;
    }
    /**
     * @param {WorldGrid} worldGrid 
     * @returns {Object}
     */
    generateGridStateForExport(worldGrid) {
      const worldGridState = {
        grids: []
      };
      const grids = worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const gridSave = this.gridSave.generateGridStateForExport(grids[i]);
        worldGridState.grids.push(gridSave);
      }
      return worldGridState;
    }
    /**
     * @param {WorldGrid} worldGrid 
     * @param {Object} worldGridState 
     * @returns {boolean}
     */
    importGridState(worldGrid, worldGridState) {
      if (!worldGridState) {
        console.log("GridSaveManager.importGridState() No world grid state");
        return false;
      }
      if (!worldGridState.grids || worldGridState.grids.length < worldGrid.grids.length) {
        console.log("GridSaveManager.importGridState() Invalid grids array.");
        return false;
      }
      const grids = worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const grid = grids[i];
        const gridState = worldGridState.grids[i];
        if (!this.gridSave.importGridState(grid, gridState)) {
          console.log("GridSaveManager.importGridState() Failed to import grid index: " + i);
          return false;
        }
        const gridKey = gridState.key;
        if (!this.metadataByKey.has(gridKey)) {
          const metadata = new GridSaveMeta(gridKey, grid.getGridCol(), grid.getGridRow());
          this.metadataByKey.set(gridKey, metadata);
        } else {
          console.log("GridSaveManager.importGridState() NOT UPDATING METADATA FOR KEY BECAUSE IT WAS ALREADY THERE.");
        }
      }
      return true;
    }
    /**
     * @param {GridSaveMeta} gridSaveMeta 
     */
    addGridSaveMetaFromSave(gridSaveMeta) {
      if (this.metadataByKey.has(gridSaveMeta.gridKey)) {
        console.log("GridSaveManager.addGridSaveMetaFromSave() added duplicate! key=" + gridSaveMeta.gridKey);
        console.trace();
        return;
      }
      this.metadataByKey.set(gridSaveMeta.gridKey, gridSaveMeta);
    }
    /**
     * @param {Grid} grid 
     */
    saveGridState(grid) {
      if (!grid) {
        return;
      }
      if (grid.gridChangeCount === 0) {
        return;
      }
      const gridKey = this.gridSave.getGridKey(grid);
      PerformanceMetrics.startTime("SaveGrid");
      if (this.gridSave.saveGridState(grid)) {
        if (!this.metadataByKey.has(gridKey)) {
          const metadata = new GridSaveMeta(gridKey, grid.getGridCol(), grid.getGridRow());
          this.metadataByKey.set(gridKey, metadata);
        }
      } else {
        console.log("GridSaveManager.saveGridState() Failed to save grid state. key=" + gridKey);
      }
      PerformanceMetrics.endTime("SaveGrid");
    }
    deleteAllGrids() {
      const gridKeys = [];
      for (const [gridKey] of this.metadataByKey.entries()) {
        gridKeys.push(gridKey);
      }
      for (let i = 0; i < gridKeys.length; i++) {
        this.removeGridState(gridKeys[i]);
      }
    }
    /**
     * Removes the save state for the grid.
     * @param {string} gridKey 
     */
    removeGridState(gridKey) {
      this.gridSave.removeGridState(gridKey);
      this.metadataByKey.delete(gridKey);
    }
    /**
     * @param {Grid} grid 
     * @returns {boolean} True if the grid has save data, false otherwise.
     */
    loadGridState(grid) {
      const gridKey = this.gridSave.getGridKey(grid);
      const saveExists = this.metadataByKey.has(gridKey);
      if (!saveExists) {
        return false;
      }
      PerformanceMetrics.startTime("LoadGrid");
      const loadResult = this.gridSave.loadGridState(grid);
      PerformanceMetrics.endTime("LoadGrid");
      if (!loadResult) {
        console.log("GridSaveManager.loadGridState() failed to load grid state. gridKey=" + gridKey);
        return false;
      }
      return true;
    }
    /**
     * @param {Grid} centerGrid The grid at the center of projection.
     * @param {Grid} crewGrid  The grid where the party is.
     */
    clearDistantGrids(centerGrid, crewGrid) {
      const col1 = centerGrid.getGridCol();
      const row1 = centerGrid.getGridRow();
      const distantKeys = [];
      if (centerGrid === crewGrid) {
        for (const [gridKey, gridMeta] of this.metadataByKey.entries()) {
          if (this.isDistant(col1, row1, gridMeta)) {
            distantKeys.push(gridKey);
          }
        }
      } else {
        const col2 = crewGrid.getGridCol();
        const row2 = crewGrid.getGridRow();
        for (const [gridKey, gridMeta] of this.metadataByKey.entries()) {
          if (this.isDistant(col1, row1, gridMeta) && this.isDistant(col2, row2, gridMeta)) {
            distantKeys.push(gridKey);
          }
        }
      }
      for (let i = 0; i < distantKeys.length; i++) {
        this.removeGridState(distantKeys[i]);
      }
    }
    /**
     * @private
     * @param {number} col 
     * @param {number} row 
     * @param {GridSaveMeta} gridMeta 
     * @returns {boolean}
     */
    isDistant(col, row, gridMeta) {
      return Math.abs(col - gridMeta.gridCol) > this.farColThreshold || Math.abs(row - gridMeta.gridRow) > this.farRowThreshold;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.deleteAllGrids();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/grid/GridLoader.js
  var GridLoader = class {
    /**
     * @param {GridSaveManager} gridSaveManager
     * @param {TerrainGenerator} terrainGenerator
     * @param {WorldGrid} worldGrid
     * @param {Crew} crew
     * @param {VectorField} vectorField
     */
    constructor(gridSaveManager, terrainGenerator, worldGrid, crew, vectorField) {
      this.gridSaveManager = gridSaveManager;
      this.terrainGenerator = terrainGenerator;
      this.worldGrid = worldGrid;
      this.crew = crew;
      this.vectorField = vectorField;
    }
    /**
     * @param {Grid} grid 
     * @param {number} x The new grid origin x-coordinate.
     * @param {number} y The new grid origin y-coordinate.
     */
    loadGrid(grid, x, y) {
      if (grid.isLoaded()) {
        this.unloadGrid(grid);
      }
      grid.origin.set(x, y);
      grid.initializeZonesForGrid();
      this.loadOrGenerateTerrain(grid, false);
    }
    /**
     * @param {Grid} grid 
     */
    regenerateGrid(grid) {
      if (grid.isLoaded()) {
        this.unloadGridInternal(grid, false);
      }
      grid.initializeZonesForGrid();
      this.loadOrGenerateTerrain(grid, true);
    }
    /**
     * @param {Grid} grid 
     */
    unloadGrid(grid) {
      this.unloadGridInternal(grid, true);
    }
    /**
     * @private
     * @param {Grid} grid
     * @param {boolean} saveGridState
     */
    unloadGridInternal(grid, saveGridState) {
      if (saveGridState && grid.loaded) {
        this.gridSaveManager.saveGridState(grid);
      }
      const miners = this.crew.miners;
      for (let i = 0; i < miners.length; i++) {
        const character = miners[i];
        if (character.position.tile && character.position.tile.getGrid() === grid) {
          console.log("GridLoader.unloadGridInternal() Party character is in grid that is being unloaded.");
          character.onInvalidGrid();
        }
      }
      grid.unloadGrid();
      this.vectorField.onGridUnload(grid);
      this.crew.onGridUnload(grid);
    }
    /**
     * @private
     * @param {Grid} grid 
     * @param {boolean} forceGeneration
     */
    loadOrGenerateTerrain(grid, forceGeneration) {
      const loadGridResult = !forceGeneration && this.gridSaveManager.loadGridState(grid);
      if (!loadGridResult) {
        PerformanceMetrics.startTime("GenerateTerrain");
        grid.nullifyBorderNeighbors();
        this.terrainGenerator.generateTerrain(grid);
        PerformanceMetrics.endTime("GenerateTerrain");
        grid.markGridAsChanged();
      } else {
        this.terrainGenerator.generateTileBackgrounds(grid);
      }
    }
    /**
     * @param {Grid} grid 
     */
    onTerrainGenerationComplete(grid) {
      grid.gridChangeCount = 0;
      grid.loaded = true;
      GridInversionOfControl.allTilesInGrid(
        grid,
        /**
         * @param {GridTile} tile 
         */
        function(tile) {
          if (tile.open && tile.tileType === SpecialTileTypes.SKY && !tile.lighting.sunlightFull) {
            tile.handleSunlightStart();
          }
        }
      );
    }
  };

  // src/model/grid/GridLoadingManager.js
  var NORTH = 0;
  var NORTH_WEST = 1;
  var NORTH_EAST = 2;
  var WEST = 3;
  var EAST = 4;
  var SOUTH = 5;
  var SOUTH_WEST = 6;
  var SOUTH_EAST = 7;
  var GridLoadingManager = class extends GameModel {
    /**
     * @param {WorldGrid} worldGrid 
     * @param {Projection} projection 
     */
    constructor(worldGrid, projection) {
      super();
      this.worldGrid = worldGrid;
      this.projection = projection;
      this.centerGrid = null;
      this.loadedGridTurn = 0;
      this.gridLoader = null;
      this.crew = null;
      this.savedGrids = new Array(9);
    }
    /**
     * Invoked by State when the game is loading.
     * @param {GridLoader} gridLoader
     * @param {Crew} crew
     */
    initializeLoadingManager(gridLoader, crew) {
      this.gridLoader = gridLoader;
      this.crew = crew;
      const gridPixelWidth = Settings.grid.gridPixelWidth;
      const gridPixelHeight = Settings.grid.gridPixelHeight;
      const grids = this.worldGrid.grids;
      const gridCol = Fast.floor(this.projection.gridCenter.x / gridPixelWidth);
      const gridRow = Fast.floor(this.projection.gridCenter.y / gridPixelHeight);
      const cx = gridCol * gridPixelWidth;
      const cy = gridRow * gridPixelHeight;
      this.gridLoader.loadGrid(grids[0], cx - gridPixelWidth, cy - gridPixelHeight);
      this.gridLoader.loadGrid(grids[1], cx, cy - gridPixelHeight);
      this.gridLoader.loadGrid(grids[2], cx + gridPixelWidth, cy - gridPixelHeight);
      this.gridLoader.loadGrid(grids[3], cx - gridPixelWidth, cy);
      this.gridLoader.loadGrid(grids[4], cx, cy);
      this.gridLoader.loadGrid(grids[5], cx + gridPixelWidth, cy);
      this.gridLoader.loadGrid(grids[6], cx - gridPixelWidth, cy + gridPixelHeight);
      this.gridLoader.loadGrid(grids[7], cx, cy + gridPixelHeight);
      this.gridLoader.loadGrid(grids[8], cx + gridPixelWidth, cy + gridPixelHeight);
      this.performPostGridLoadOperations();
      this.worldGrid.changeCount++;
      this.worldGrid.shiftCount++;
    }
    /**
     * @private
     * @param {Grid} grid 
     */
    clearSavedGrid(grid) {
      const i = this.savedGrids.indexOf(grid);
      if (i !== -1) {
        this.savedGrids[i] = null;
      } else {
        console.log("GridLoadingManager.clearSavedGrid() did not find grid in saved grids");
      }
    }
    /**
     * @private
     * @param {Grid} centerGrid 
     * @param {number} gridIndex 
     * @param {number} direction 
     */
    setGridIfAlreadyLoaded(centerGrid, gridIndex, direction) {
      const savedGridIndex = this.findSavedGridIndex(centerGrid, direction);
      if (savedGridIndex === -1) {
        return;
      }
      const grid = this.savedGrids[savedGridIndex];
      if (!grid.loaded) {
        return;
      }
      this.savedGrids[savedGridIndex] = null;
      this.worldGrid.grids[gridIndex] = grid;
    }
    /**
     * @private
     * @returns {number}
     */
    findFirstSavedGridIndex() {
      for (let i = 0; i < this.savedGrids.length; i++) {
        if (this.savedGrids[i]) {
          return i;
        }
      }
      return -1;
    }
    /**
     * @private
     * @param {Grid} centerGrid 
     * @param {number} gridIndex 
     * @param {number} direction 
     */
    loadIfUnloaded(centerGrid, gridIndex, direction) {
      const currentGrid = this.worldGrid.grids[gridIndex];
      if (currentGrid && currentGrid.isLoaded()) {
        return;
      }
      const recycledGridIndex = this.findFirstSavedGridIndex();
      if (recycledGridIndex === -1) {
        console.log("GridLoadingManager.loadIfUnloaded() ERROR Failed to find available grid!");
        return;
      }
      const grid = this.savedGrids[recycledGridIndex];
      this.worldGrid.grids[gridIndex] = grid;
      this.savedGrids[recycledGridIndex] = null;
      const cx = centerGrid.origin.x;
      const cy = centerGrid.origin.y;
      let x = cx;
      let y = cy;
      const gridWidth = Settings.grid.gridPixelWidth;
      const gridHeight = Settings.grid.gridPixelHeight;
      switch (direction) {
        case NORTH_WEST:
          x = cx - gridWidth;
          y = cy - gridHeight;
          break;
        case NORTH:
          y = cy - gridHeight;
          break;
        case NORTH_EAST:
          x = cx + gridWidth;
          y = cy - gridHeight;
          break;
        case WEST:
          x = cx - gridWidth;
          break;
        case EAST:
          x = cx + gridWidth;
          break;
        case SOUTH_WEST:
          y = cy + gridHeight;
          x = cx - gridWidth;
          break;
        case SOUTH:
          y = cy + gridHeight;
          break;
        case SOUTH_EAST:
          y = cy + gridHeight;
          x = cx + gridWidth;
          break;
        default:
          console.log("GridLoadingManager.findSavedGridIndex() Unknown direction: " + direction);
          return -1;
      }
      this.gridLoader.loadGrid(grid, x, y);
    }
    /**
     * @private
     * @param {Grid} centerGrid 
     * @param {number} direction 
     * @returns {number}
     */
    findSavedGridIndex(centerGrid, direction) {
      const tileCol = centerGrid.getOriginTileCol();
      const tileRow = centerGrid.getOriginTileRow();
      const tileWidth = Settings.grid.gridTileWidth;
      const tileHeight = Settings.grid.gridTileHeight;
      let targetTileCol = tileCol;
      let targetTileRow = tileRow;
      switch (direction) {
        case NORTH_WEST:
          targetTileRow = tileRow - tileHeight;
          targetTileCol = tileCol - tileWidth;
          break;
        case NORTH:
          targetTileRow = tileRow - tileHeight;
          break;
        case NORTH_EAST:
          targetTileRow = tileRow - tileHeight;
          targetTileCol = tileCol + tileWidth;
          break;
        case WEST:
          targetTileCol = tileCol - tileWidth;
          break;
        case EAST:
          targetTileCol = tileCol + tileWidth;
          break;
        case SOUTH_WEST:
          targetTileRow = tileRow + tileHeight;
          targetTileCol = tileCol - tileWidth;
          break;
        case SOUTH:
          targetTileRow = tileRow + tileHeight;
          break;
        case SOUTH_EAST:
          targetTileRow = tileRow + tileHeight;
          targetTileCol = tileCol + tileWidth;
          break;
        default:
          console.log("GridLoadingManager.findSavedGridIndex() Unknown direction: " + direction);
          return -1;
      }
      for (let i = 0; i < this.savedGrids.length; i++) {
        const current = this.savedGrids[i];
        if (!current) {
          continue;
        }
        const currentTileCol = current.getOriginTileCol();
        if (currentTileCol !== targetTileCol) {
          continue;
        }
        const currentTileRow = current.getOriginTileRow();
        if (currentTileRow === targetTileRow) {
          return i;
        }
      }
      return -1;
    }
    /**
     */
    manageLoadedGridsForFrame() {
      const gridCenter = this.projection.gridCenter;
      let newCenterGrid = this.worldGrid.findGridContaining(gridCenter);
      if (!newCenterGrid) {
        newCenterGrid = this.worldGrid.grids[4];
        if (newCenterGrid.isLoaded()) {
          this.gridLoader.unloadGrid(newCenterGrid);
        }
        const gridCol = Fast.floor(gridCenter.x / Settings.grid.gridPixelWidth);
        const gridRow = Fast.floor(gridCenter.y / Settings.grid.gridPixelHeight);
        const x = gridCol * Settings.grid.gridPixelWidth;
        const y = gridRow * Settings.grid.gridPixelHeight;
        this.gridLoader.loadGrid(newCenterGrid, x, y);
        this.centerGrid = null;
      }
      if (this.centerGrid && this.centerGrid === newCenterGrid) {
        return;
      }
      this.worldGrid.changeCount++;
      this.worldGrid.shiftCount++;
      this.centerGrid = newCenterGrid;
      const grids = this.worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        this.savedGrids[i] = grids[i];
        grids[i] = null;
      }
      grids[4] = this.centerGrid;
      this.clearSavedGrid(this.centerGrid);
      this.setGridIfAlreadyLoaded(this.centerGrid, 0, NORTH_WEST);
      this.setGridIfAlreadyLoaded(this.centerGrid, 1, NORTH);
      this.setGridIfAlreadyLoaded(this.centerGrid, 2, NORTH_EAST);
      this.setGridIfAlreadyLoaded(this.centerGrid, 3, WEST);
      this.setGridIfAlreadyLoaded(this.centerGrid, 5, EAST);
      this.setGridIfAlreadyLoaded(this.centerGrid, 6, SOUTH_WEST);
      this.setGridIfAlreadyLoaded(this.centerGrid, 7, SOUTH);
      this.setGridIfAlreadyLoaded(this.centerGrid, 8, SOUTH_EAST);
      this.loadIfUnloaded(this.centerGrid, 0, NORTH_WEST);
      this.loadIfUnloaded(this.centerGrid, 1, NORTH);
      this.loadIfUnloaded(this.centerGrid, 2, NORTH_EAST);
      this.loadIfUnloaded(this.centerGrid, 3, WEST);
      this.loadIfUnloaded(this.centerGrid, 5, EAST);
      this.loadIfUnloaded(this.centerGrid, 6, SOUTH_WEST);
      this.loadIfUnloaded(this.centerGrid, 7, SOUTH);
      this.loadIfUnloaded(this.centerGrid, 8, SOUTH_EAST);
      PerformanceMetrics.startTime("PostGridLoading");
      this.performPostGridLoadOperations();
      PerformanceMetrics.endTime("PostGridLoading");
    }
    /**
     * @private
     */
    performPostGridLoadOperations() {
      this.setAllGridNeighbors();
      this.findAllGridBorderTileNeighbors();
      this.evaulateGridTiles();
      this.onLoadingComplete();
      this.validateTileReferences();
      if (this.crew && this.crew.main) {
        let crewGrid = null;
        const crewTile = this.crew.main.position.tile;
        if (crewTile) {
          crewGrid = crewTile.getGrid();
        } else if (this.centerGrid) {
          crewGrid = this.centerGrid.getWorldGrid().findGridContaining(this.crew.main.position.worldCoordinateOrigin);
        }
        if (crewGrid) {
          this.gridLoader.gridSaveManager.clearDistantGrids(this.centerGrid, crewGrid);
        }
      }
    }
    /**
     * @private
     */
    setAllGridNeighbors() {
      const grids = this.worldGrid.grids;
      grids[0].setGridNeighbors(null, grids[3], grids[1], null);
      grids[1].setGridNeighbors(null, grids[4], grids[2], grids[0]);
      grids[2].setGridNeighbors(null, grids[5], null, grids[1]);
      grids[3].setGridNeighbors(grids[0], grids[6], grids[4], null);
      grids[4].setGridNeighbors(grids[1], grids[7], grids[5], grids[3]);
      grids[5].setGridNeighbors(grids[2], grids[8], null, grids[4]);
      grids[6].setGridNeighbors(grids[3], null, grids[7], null);
      grids[7].setGridNeighbors(grids[4], null, grids[8], grids[6]);
      grids[8].setGridNeighbors(grids[5], null, null, grids[7]);
    }
    /**
     * @private
     */
    onLoadingComplete() {
      const grids = this.worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        if (!grids[i].loaded) {
          this.gridLoader.onTerrainGenerationComplete(grids[i]);
        }
      }
    }
    /**
     * @private
     */
    findAllGridBorderTileNeighbors() {
      const grids = this.worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        grids[i].findWorldGridTileNeighbors();
      }
    }
    /**
     * @private
     */
    evaulateGridTiles() {
      const grids = this.worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const grid = grids[i];
        if (!grid.loaded) {
          grid.evaluateAllTileBorders();
        } else {
          grid.evaluateWorldGridTileNeighborBorders();
        }
      }
    }
    /**
     * @private
     */
    validateTileReferences() {
      const grids = this.worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        this.validateGridTileReferences(grids[i]);
      }
    }
    /**
     * @private
     * @param {Grid} grid;
     */
    validateGridTileReferences(grid) {
      const characters = grid.characters;
      for (let c = 0; c < characters.length; c++) {
        const position = characters[c].position;
        const valid = position.tile && position.tile.contains(position.worldCoordinateOrigin);
        if (!valid) {
          console.log("GridLoadingManager.validateGridTileReferences() found invalid character. " + position.worldCoordinateOrigin.toString());
          characters[c].onInvalidGrid();
        }
      }
    }
    regenerateGrids() {
      const grids = this.worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const grid = grids[i];
        if (grid) {
          this.gridLoader.regenerateGrid(grid);
        }
      }
      this.worldGrid.changeCount++;
    }
    // resetGameModels() {
    //     this.crew = null;
    //     this.gridLoader = null;
    // }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      const grids = this.worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const grid = grids[i];
        if (grid) {
          this.gridLoader.unloadGrid(grid);
        }
      }
      this.crew = null;
      this.gridLoader = null;
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/lighting/Arc.js
  var Arc = class {
    constructor(a0, a1) {
      this.a0 = a0;
      this.a1 = a1;
    }
  };

  // src/model/lighting/ArcCache.js
  var ArcCache = class {
    /**
     * @param {number} cacheSize 
     */
    constructor(cacheSize) {
      this.nextIndex = 0;
      this.arcs = new Array(cacheSize);
      for (let i = 0; i < cacheSize; i++) {
        this.arcs[i] = new Arc(0, 0);
      }
    }
    resetCache() {
      this.nextIndex = 0;
    }
    /**
     * @param {number} a0 
     * @param {number} a1 
     * @returns {Arc}
     */
    getArc(a0, a1) {
      let arc;
      if (this.nextIndex >= this.arcs.length) {
        arc = new Arc(a0, a1);
        this.arcs.push(arc);
      } else {
        arc = this.arcs[this.nextIndex];
        arc.a0 = a0;
        arc.a1 = a1;
      }
      this.nextIndex++;
      return arc;
    }
  };

  // src/model/lighting/ShadowCastCallback.js
  var ShadowCastCallback = class {
    /**
     * Invoked on a tile that is not in shadow.
     * @abstract
     * @param {GridTile} tile The tile.
     * @param {number} radius The radius from the center tile.
     * @param {number} lightFraction The fraction of the tile that is hit by light.
     */
    tileLighted(tile, radius, lightFraction) {
    }
  };

  // src/model/lighting/ShadowCaster.js
  var dirs = [
    [0, -1],
    [1, 0],
    [0, 1],
    [-1, 0]
  ];
  var ShadowCaster = class {
    /**
     * 
     * @param {WorldGrid} worldGrid 
     */
    constructor(worldGrid) {
      this.worldGrid = worldGrid;
    }
    /**
     * Cast shadows in the grid.
     *
     * @abstract
     * @param {GridTile} tile     The center tile.
     * @param {number} tileRadius The radius of the light (in tiles, not pixels).
     * @param {ShadowCastCallback} callback The callback that will be invoked once for every tile that has light cast upon it.
     */
    castShadows(tile, tileRadius, callback) {
    }
    /**
     * @param {number} radius 
     * @returns {number}
     */
    getNeighborCountForRadius(radius) {
      return radius * 8;
    }
    /**
     * Return all tiles in a concentric ring
     * @param {number} centerCol
     * @param {number} centerRow
     * @param {number} radius
     * @param {ShadowCastCallback} callback The callback that will be invoked once for every tile that has light cast upon it.
     */
    forEachCircleTile(centerCol, centerRow, radius, callback) {
      const countFactor = 2;
      const startOffsetCol = -1;
      const startOffsetRow = 1;
      let tileCol = centerCol + startOffsetCol * radius;
      let tileRow = centerRow + startOffsetRow * radius;
      let prevTile = null;
      const neighborCount = this.getNeighborCountForRadius(radius);
      let neighborIndex = 0;
      for (let i = 0; i < dirs.length; i++) {
        for (let j = 0; j < radius * countFactor; j++) {
          let tile;
          if (prevTile != null) {
            tile = prevTile.getNeighborColRow(tileCol, tileRow);
          } else {
            tile = this.worldGrid.getGridTile(tileCol, tileRow);
          }
          if (tile) {
            if (!this.onCircleTile(tile, neighborIndex, neighborCount, radius, callback)) {
              return;
            }
          }
          neighborIndex++;
          tileCol += dirs[i][0];
          tileRow += dirs[i][1];
          prevTile = tile;
        }
      }
    }
    /**
     * @abstract
     * @param {GridTile} tile
     * @param {number} neighborIndex
     * @param {number} neighborCount
     * @param {number} radius
     * @param {ShadowCastCallback} callback The callback that will be invoked once for every tile that has light cast upon it.
     * @returns {boolean}
     */
    onCircleTile(tile, neighborIndex, neighborCount, radius, callback) {
    }
  };

  // src/model/lighting/PreciseShadowCaster.js
  var PreciseShadowCaster = class extends ShadowCaster {
    /**
     * @param {WorldGrid} worldGrid 
     */
    constructor(worldGrid) {
      super(worldGrid);
      this.shadows = [];
      this.cache = new ArcCache(2500);
    }
    /**
     * Cast shadows in the grid.
     * @override
     * @param {GridTile} tile     The center tile.
     * @param {number} tileRadius The radius of the light (in tiles, not pixels).
     * @param {ShadowCastCallback} callback The callback that will be invoked once for every tile that has light cast upon it.
     */
    castShadows(tile, tileRadius, callback) {
      if (tile == null) {
        return;
      }
      callback.tileLighted(tile, 0, 1);
      const centerCol = tile.getTileCol();
      const centerRow = tile.getTileRow();
      this.shadows.length = 0;
      this.cache.resetCache();
      for (let r = 1; r <= tileRadius; r++) {
        this.forEachCircleTile(centerCol, centerRow, r, callback);
      }
    }
    /**
     * @override
     * @param {GridTile} tile
     * @param {number} neighborIndex
     * @param {number} neighborCount
     * @param {number} radius
     * @param {ShadowCastCallback} callback The callback that will be invoked once for every tile that has light cast upon it.
     * @returns {boolean}
     */
    onCircleTile(tile, neighborIndex, neighborCount, radius, callback) {
      if (!tile) {
        return true;
      }
      const A1 = this.cache.getArc(neighborIndex > 0 ? 2 * neighborIndex - 1 : 2 * neighborCount - 1, 2 * neighborCount);
      const A2 = this.cache.getArc(2 * neighborIndex + 1, 2 * neighborCount);
      const blocks = tile.isOpaque();
      const visibility = this.checkVisibility(A1, A2, blocks, this.shadows);
      if (visibility > 0) {
        callback.tileLighted(tile, radius, visibility);
      }
      if (this.shadows.length == 2 && this.shadows[0].a0 == 0 && this.shadows[1].a0 == this.shadows[1].a1) {
        return false;
      }
      return true;
    }
    /**
     * @private
     * @param {Arc} A1 
     * @param {Arc} A2 
     * @param {boolean} blocks 
     * @param {Array.<Arc>} shadows
     */
    checkVisibility(A1, A2, blocks, shadows) {
      if (A1.a0 > A2.a0) {
        const v1 = this.checkVisibility(A1, this.cache.getArc(A1.a1, A1.a1), blocks, shadows);
        const v2 = this.checkVisibility(this.cache.getArc(0, 1), A2, blocks, shadows);
        return (v1 + v2) / 2;
      }
      let index1 = 0;
      let edge1 = false;
      while (index1 < shadows.length) {
        const old = shadows[index1];
        const diff = old.a0 * A1.a1 - A1.a0 * old.a1;
        if (diff >= 0) {
          if (diff == 0 && index1 % 2 == 0) {
            edge1 = true;
          }
          break;
        }
        index1++;
      }
      let index2 = shadows.length;
      let edge2 = false;
      while (index2-- != 0) {
        const old = shadows[index2];
        const diff = A2.a0 * old.a1 - old.a0 * A2.a1;
        if (diff >= 0) {
          if (diff == 0 && index2 % 2 != 0) {
            edge2 = true;
          }
          break;
        }
      }
      let visible = true;
      if (index1 == index2 && (edge1 || edge2)) {
        visible = false;
      } else if (edge1 && edge2 && index1 + 1 == index2 && index2 % 2 != 0) {
        visible = false;
      } else if (index1 > index2 && index1 % 2 != 0) {
        visible = false;
      }
      if (!visible) {
        return 0;
      }
      let visibleLength;
      const remove = index2 - index1 + 1;
      if (remove % 2 != 0) {
        if (index1 % 2 != 0) {
          const P = shadows[index1];
          const denominator2 = P.a1 * A2.a1;
          const numerator2 = A2.a0 * P.a1 - P.a0 * A2.a1;
          visibleLength = numerator2 / denominator2;
          if (blocks) {
            shadows.splice(index1, remove, A2);
          }
        } else {
          const P = shadows[index2];
          const denominator2 = A1.a1 * P.a1;
          const numerator2 = P.a0 * A1.a1 - A1.a0 * P.a1;
          visibleLength = numerator2 / denominator2;
          if (blocks) {
            shadows.splice(index1, remove, A1);
          }
        }
      } else {
        if (index1 % 2 != 0) {
          const P1 = shadows[index1];
          const P2 = shadows[index2];
          const denominator2 = P1.a1 * P2.a1;
          const numerator2 = P2.a0 * P1.a1 - P1.a0 * P2.a1;
          visibleLength = numerator2 / denominator2;
          if (blocks) {
            shadows.splice(index1, remove);
          }
        } else {
          if (blocks) {
            shadows.splice(index1, remove, A1, A2);
          }
          return 1;
        }
      }
      const denominator = A1.a1 * A2.a1;
      const numerator = A2.a0 * A1.a1 - A1.a0 * A2.a1;
      const arcLength = numerator / denominator;
      if (arcLength == 0) {
        return 1;
      }
      return visibleLength / arcLength;
    }
  };

  // src/model/lighting/ColoredShadowCastCallback.js
  var ColoredShadowCastCallback = class extends ShadowCastCallback {
    /**
     * @param {Color} lightColor 
     * @param {number} lightSourceCastRadius 
     */
    constructor(lightColor, lightSourceCastRadius) {
      super();
      this.lightColor = lightColor;
      this.lightSourceCastRadius = lightSourceCastRadius;
      this.workingCalculatedLightColor = new Color(1, 1, 1, 1);
    }
    /**
     * @param {Color} lightColor 
     * @param {number} lightSourceCastRadius 
     */
    setValues(lightColor, lightSourceCastRadius) {
      this.lightColor = lightColor;
      this.lightSourceCastRadius = lightSourceCastRadius;
    }
    /**
     * @param {number} radius 
     * @param {number} lightFraction 
     * @returns {Color}
     */
    calculatedLightedColor(radius, lightFraction) {
      const lightMagnitudeAtRadius = 1 - 1 * radius / this.lightSourceCastRadius;
      this.workingCalculatedLightColor.set(this.lightColor);
      this.workingCalculatedLightColor.mul(lightMagnitudeAtRadius * lightFraction);
      return this.workingCalculatedLightColor;
    }
  };

  // src/model/lighting/DynamicLightSourceCastCallback.js
  var DynamicLightSourceCastCallback = class extends ColoredShadowCastCallback {
    /**
     * @param {Color} lightColor 
     * @param {number} lightSourceCastRadius 
     */
    constructor(lightColor, lightSourceCastRadius) {
      super(lightColor, lightSourceCastRadius);
    }
    /**
     * @override
     * @param {GridTile} tile 
     * @param {number} radius 
     * @param {number} lightFraction 
     */
    tileLighted(tile, radius, lightFraction) {
      tile.addDynamicLighting(this.calculatedLightedColor(radius, lightFraction));
    }
  };

  // src/model/lighting/PositionalLightSourceCastCallback.js
  var PositionalLightSourceCastCallback = class extends ColoredShadowCastCallback {
    /**
     * @param {Color} lightColor 
     * @param {number} lightSourceCastRadius  
     */
    constructor(lightColor, lightSourceCastRadius) {
      super(lightColor, lightSourceCastRadius);
    }
    /**
     * @override
     * @param {GridTile} tile 
     * @param {number} radius 
     * @param {number} lightFraction 
     */
    tileLighted(tile, radius, lightFraction) {
      tile.addPositionalLighting(this.calculatedLightedColor(radius, lightFraction));
    }
  };

  // src/model/lighting/EnvironmentLightSourceCastCallback.js
  var EnvironmentalLightSourceCastCallback = class extends ColoredShadowCastCallback {
    /**
     * @param {Color} lightColor 
     * @param {number} lightSourceCastRadius  
     */
    constructor(lightColor, lightSourceCastRadius) {
      super(lightColor, lightSourceCastRadius);
    }
    /**
     * @override
     * @param {GridTile} tile 
     * @param {number} radius 
     * @param {number} lightFraction 
     */
    tileLighted(tile, radius, lightFraction) {
      tile.addEnvironmentLighting(this.calculatedLightedColor(radius, lightFraction));
    }
  };

  // src/model/lighting/LightingCalculator.js
  var LightingCalculator = class extends GameModel {
    /**
     * @param {WorldGrid} worldGrid
     * @param {Projection} projection 
     */
    constructor(worldGrid, projection) {
      super();
      this.worldGrid = worldGrid;
      this.projection = projection;
      this.visibleTileRadius = 13;
      this.lightSourceRadius = 7;
      this.mainPositionalTileRadius = 7;
      this.secondaryPositionalTileRadius = 5;
      this.lightSourceRecalculationFrames = 40;
      this.maxDynamicLightSources = 10;
      this.elapsedFrameCount = this.lightSourceRecalculationFrames;
      this.dynamicLightSources = [];
      this.calculatedTile = null;
      this.shadowCaster = new PreciseShadowCaster(worldGrid);
      this.forceEnvironmentalRecalculation = false;
      this.dynamicLightSourceCastCallback = new DynamicLightSourceCastCallback(new Color(0, 0, 0, 0), 5);
      this.positionalLightSourceCastCallback = new PositionalLightSourceCastCallback(new Color(0, 0, 0, 1), this.mainPositionalTileRadius);
      this.secondaryPositionalLightSourceCastCallback = new PositionalLightSourceCastCallback(new Color(0, 0, 0, 1), this.secondaryPositionalTileRadius);
      this.environmentalLightSourceCastCallback = new EnvironmentalLightSourceCastCallback(new Color(0, 0, 0, 0), 5);
      this.regionResetLightingCallback = (region) => {
        const tiles = region.getTiles();
        for (let i = 0; i < tiles.length; i++) {
          tiles[i].lighting.resetLighting();
        }
      };
      const thisRef = this;
      this.gridEnvironmentalLightingCallback = (grid) => {
        const lightSources = grid.getLightSources();
        if (!lightSources || lightSources.length === 0) {
          return;
        }
        for (let i = 0; i < lightSources.length; i++) {
          const lightSource = lightSources[i];
          if (lightSource.isFinishedAndAvailable()) {
            continue;
          }
          const castRadius = lightSource.getTileRadius();
          thisRef.environmentalLightSourceCastCallback.setValues(lightSource.getColor(), castRadius);
          thisRef.shadowCaster.castShadows(lightSource.getTile(), castRadius, thisRef.environmentalLightSourceCastCallback);
        }
      };
    }
    resetLightingCalculator() {
      this.dynamicLightSources.length = 0;
    }
    /**
     * @param {LightSource} lightSource 
     */
    addDynamicLightSource(lightSource) {
      if (!lightSource) {
        return;
      }
      if (lightSource.getTile() == null || lightSource.isFinishedAndAvailable()) {
        return;
      }
      this.dynamicLightSources.push(lightSource);
      const toRemove = this.dynamicLightSources.length - this.maxDynamicLightSources;
      if (toRemove > 0) {
        this.dynamicLightSources.splice(this.maxDynamicLightSources - 1, toRemove);
      }
      console.log("LightingCalculator.addDynamicLightSource() size=" + this.dynamicLightSources.length);
    }
    /**
     * @param {LightSource} lightSource 
     */
    removeDynamicLightSource(lightSource) {
      if (!lightSource) {
        return;
      }
      const index = this.dynamicLightSources.indexOf(lightSource);
      if (index === -1) {
        return;
      }
      this.dynamicLightSources.splice(index, 1);
    }
    resetForFrame() {
      GridInversionOfControl.allVisibleRegions(this.worldGrid, this.projection, this.regionResetLightingCallback);
    }
    /**
     * @private
     * @param {number} frameTimeRatio 
     */
    calculateEnvironmentLighting(frameTimeRatio) {
      this.elapsedFrameCount += frameTimeRatio;
      if (this.forceEnvironmentalRecalculation || this.elapsedFrameCount >= this.lightSourceRecalculationFrames) {
        this.elapsedFrameCount = 0;
        GridInversionOfControl.allVisibleGrids(this.worldGrid, this.projection, this.gridEnvironmentalLightingCallback);
      }
    }
    /**
     * @private
     */
    calculateDynamicLighting() {
      if (this.dynamicLightSources.length === 0) {
        return;
      }
      for (let i = this.dynamicLightSources.length - 1; i >= 0; i--) {
        const lightSource = this.dynamicLightSources[i];
        if (lightSource.isFinishedAndAvailable()) {
          this.dynamicLightSources.splice(i, 1);
          continue;
        }
        const tile = lightSource.getTile();
        if (!tile) {
          this.dynamicLightSources.splice(i, 1);
          continue;
        }
        const radius = lightSource.getTileRadius();
        const lightOrigin = tile.getOrigin();
        if (!this.projection.isVisible(lightOrigin.x + Settings.tile.halfSize, lightOrigin.y + Settings.tile.halfSize, Settings.tile.size * radius)) {
          continue;
        }
        this.dynamicLightSourceCastCallback.setValues(lightSource.getColor(), radius);
        this.shadowCaster.castShadows(tile, radius, this.dynamicLightSourceCastCallback);
      }
    }
    /**
     * @param {GridTile} centerTile
     */
    calculatePrimaryPositionalLighting(centerTile) {
      if (!centerTile) {
        return;
      }
      this.shadowCaster.castShadows(centerTile, this.mainPositionalTileRadius, this.positionalLightSourceCastCallback);
    }
    /**
     * @param {GridTile} centerTile
     */
    calculateSecondaryPositionalLighting(centerTile) {
      if (!centerTile) {
        return;
      }
      this.shadowCaster.castShadows(centerTile, this.secondaryPositionalTileRadius, this.secondaryPositionalLightSourceCastCallback);
    }
    onEnvironmentalLightSourceChange() {
      this.forceEnvironmentalRecalculation = true;
    }
    /**
     * Invoked when a wall tile has been removed. This lets the field of view calculator know that
     * things need to be recalculated.
     */
    onWallBroken() {
      this.forceRecalculation();
    }
    /**
     * @private
     */
    forceRecalculation() {
      this.forceEnvironmentalRecalculation = true;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.dynamicLightSources.length = 0;
      this.calculatedTile = null;
      this.forceEnvironmentalRecalculation = false;
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/physics/Collision.js
  var Collision = class {
    constructor() {
      this.collisionVector = new Vector(0, 0);
    }
    // /**
    //  * @private
    //  * @param {number} a0 
    //  * @param {number} a1 
    //  * @param {number} b0 
    //  * @param {number} b1 
    //  * @returns {boolean}
    //  */
    // static isIntersection(a0, a1, b0, b1) {
    //     // a0 in [b0-b1]
    //     // a1 in [b0-b1]
    //     // b0 in [a0-a1]
    //     // b1 in [a0-a1]
    //     return (b0 < a0 && a0 < b1) || (b0 < a1 && a1 < b1) || (a0 < b0 && b0 < a1) || (a0 < b1 && b1 < a1);
    // }
    /**
     * @param {Character} character 
     * @returns {boolean}
     */
    static isStandingOnTileOrigin(character) {
      const tile = character.position.tile;
      if (!tile) {
        return true;
      }
      const worldCoordinate = character.position.worldCoordinateOrigin;
      const yCoordInteger = Fast.floor(worldCoordinate.y);
      return yCoordInteger === tile.origin.y;
    }
    /**
     * @param {Character} character 
     * @returns {boolean}
     */
    static isStandingOnTopOfClosedTile(character) {
      const tile = character.position.tile;
      if (!tile) {
        return true;
      }
      const worldCoordinate = character.position.worldCoordinateOrigin;
      const yCoordInteger = Fast.floor(worldCoordinate.y);
      if (yCoordInteger !== tile.origin.y) {
        return false;
      }
      const neighborBottom = tile.getNeighborBottom();
      return neighborBottom && !neighborBottom.isTraversable();
    }
    /**
     * If the character were to move N pixels down, would they collide with something?
     * @param {Character} character 
     * @param {number} movementPixels 
     * @returns {boolean}
     */
    isCollisionDown(character, movementPixels) {
      const tile = character.position.tile;
      if (!tile) {
        return true;
      }
      const bottomTile = tile.getNeighborBottom();
      if (!bottomTile) {
        return true;
      }
      if (bottomTile.open) {
        return false;
      }
      const movedY = character.position.worldCoordinateOrigin.y + Settings.tile.size + movementPixels;
      if (tile.containsXY(character.position.worldCoordinateOrigin.x, movedY)) {
        return !tile.open;
      } else if (bottomTile.containsXY(character.position.worldCoordinateOrigin.x, movedY)) {
        return !bottomTile.open;
      }
      return false;
    }
  };

  // src/model/physics/CharacterPhysics.js
  var CharacterPhysics = class {
    /**
     * @param {WorldGrid} worldGrid
     * @param {Projection} projection 
     * @param {GameTime} gameTime
     */
    constructor(worldGrid, projection, gameTime) {
      this.worldGrid = worldGrid;
      this.projection = projection;
      this.collision = new Collision();
      this.gameTime = gameTime;
      const thisRef = this;
      this.frameTimeRatio = 1;
      this.applyForcesOnCharactersFunction = /**
       * @param {Grid} grid 
       */
      function(grid) {
        for (let i = grid.characters.length - 1; i >= 0; i--) {
          const character = grid.characters[i];
          if (character.isPartyMember()) {
            continue;
          }
          if (!character.position.tile) {
            continue;
          }
          if (character.position.pathPlan.length > 0) {
            continue;
          }
          thisRef.applyGravity(character, thisRef.frameTimeRatio);
        }
      };
    }
    /**
     * @param {number} frameTimeRatio 
     */
    updatePhysicsForFrame(frameTimeRatio) {
      this.frameTimeRatio = frameTimeRatio;
      GridInversionOfControl.allVisibleGrids(this.worldGrid, this.projection, this.applyForcesOnCharactersFunction);
    }
    /**
     * @private
     * @param {Character} character 
     * @param {number} frameTimeRatio 
     */
    applyGravity(character, frameTimeRatio) {
      if (Collision.isStandingOnTopOfClosedTile(character)) {
        character.position.setPositionToTileOrigin();
        if (character.position.gravityThisFrame > 0) {
          character.position.gravityThisFrame = 0;
          character.setCharacterAction(CharacterAction.STAND);
        }
        return;
      }
      character.position.gravityThisFrame = Settings.physics.gravityRatePerFrame * frameTimeRatio;
      if (!this.collision.isCollisionDown(character, character.position.gravityThisFrame)) {
        character.position.moveY(character.position.gravityThisFrame);
        character.setCharacterAction(CharacterAction.FALL);
      } else {
        character.position.setPositionToTileOrigin();
        if (character.position.gravityThisFrame > 0) {
          character.position.gravityThisFrame = 0;
          character.setCharacterAction(CharacterAction.STAND);
        }
      }
    }
  };

  // src/model/physics/PhysicsManager.js
  var PhysicsManager = class {
    /**
     * @param {WorldGrid} worldGrid
     * @param {Projection} projection 
     * @param {GameTime} gameTime
     */
    constructor(worldGrid, projection, gameTime) {
      this.characterPhysics = new CharacterPhysics(worldGrid, projection, gameTime);
    }
    /**
     * @param {number} frameTimeRatio 
     */
    updatePhysicsForFrame(frameTimeRatio) {
      this.characterPhysics.updatePhysicsForFrame(frameTimeRatio);
    }
  };

  // src/model/save/SaveManager.js
  var LZString2 = __toESM(require_lz_string());

  // src/model/save/ProjectionSave.js
  var ProjectionSave = class {
    constructor() {
    }
    /**
     * @param {Projection} projection 
     * @returns {Object}
     */
    static generateSave(projection) {
      const saveState = {};
      saveState.gridCenter = {
        x: projection.gridCenter.x,
        y: projection.gridCenter.y
      };
      saveState.zoom = projection.zoom;
      saveState.centerOnCharacter = projection.stayCenteredOnCharacter;
      return saveState;
    }
    /**
     * @param {Projection} projection 
     * @param {Object} saveState 
     */
    static loadSave(projection, saveState) {
      if (!saveState) {
        return;
      }
      projection.setGridCenter(saveState.gridCenter.x, saveState.gridCenter.y);
      projection.setZoom(saveState.zoom);
      projection.stayCenteredOnCharacter = false;
      if (saveState.centerOnCharacter) {
        projection.stayCenteredOnCharacter = true;
      }
    }
  };

  // src/model/save/StateSave.js
  var StateSave = class {
    constructor() {
    }
    /**
     * @param {State} state 
     * @returns {Object}
     */
    static generateSave(state) {
      const saveState = {};
      saveState.v = 1;
      saveState.seed = state.worldSeed;
      return saveState;
    }
    /**
     * @param {State} state 
     * @param {Object} saveState 
     */
    static loadSave(state, saveState) {
      if (!saveState) {
        return;
      }
      state.worldSeed = saveState.seed;
    }
  };

  // src/model/save/BigNumSave.js
  var BigNumSave = class {
    constructor() {
    }
    /**
     * @param {BigNum} bigNumValue 
     * @returns {number[]}
     */
    static save(bigNumValue) {
      if (!bigNumValue) {
        return [0, 0];
      }
      return [
        bigNumValue.m,
        bigNumValue.e
      ];
    }
    /**
     * @param {number[]} bigNumState 
     * @param {BigNum} bigNumOutput 
     */
    static load(bigNumState, bigNumOutput) {
      if (!bigNumState) {
        return;
      }
      bigNumOutput.set(bigNumState[0], bigNumState[1]);
    }
  };

  // src/model/save/ValuePerTurnSave.js
  var ValuePerTurnSave = class {
    constructor() {
    }
    /**
     * @param {ValuePerTurnCalculator} calculator
     * @returns {Object}
     */
    static generateSave(calculator) {
      const saveState = {};
      saveState.sum = BigNumSave.save(calculator.sum);
      saveState.startTurn = calculator.startTurn;
      saveState.valuePerTurn = BigNumSave.save(calculator.valuePerTurn);
      saveState.rateIndex = calculator.rateIndex;
      saveState.rates = [];
      for (let i = 0; i < calculator.rates.length; i++) {
        saveState.rates.push(BigNumSave.save(calculator.rates[i]));
      }
      return saveState;
    }
    /**
     * @param {ValuePerTurnCalculator} calculator
     * @param {Object} saveState 
     */
    static loadSave(calculator, saveState) {
      if (!saveState) {
        return;
      }
      BigNumSave.load(saveState.sum, calculator.sum);
      if (saveState.startTurn) {
        calculator.startTurn = saveState.startTurn;
      }
      BigNumSave.load(saveState.valuePerTurn, calculator.valuePerTurn);
      calculator.rateIndex = 0;
      if (saveState.rateIndex) {
        calculator.rateIndex = saveState.rateIndex;
      }
      if (saveState.rates) {
        calculator.rates.length = 0;
        for (let i = 0; i < saveState.rates.length; i++) {
          const rate = new BigNum(0);
          BigNumSave.load(saveState.rates[i], rate);
          calculator.rates.push(rate);
        }
      }
    }
  };

  // src/model/save/TotalsSave.js
  var TotalsSave = class {
    constructor() {
    }
    /**
     * @param {Totals} totals
     * @returns {Object}
     */
    static generateSave(totals) {
      const saveState = {};
      saveState.ore = BigNumSave.save(totals.ore);
      saveState.gold = BigNumSave.save(totals.gold);
      saveState.ruby = BigNumSave.save(totals.ruby);
      saveState.prestige = BigNumSave.save(totals.prestige);
      saveState.prestigeSum = BigNumSave.save(totals.prestigePointsSum);
      saveState.unclaimed = BigNumSave.save(totals.unclaimedPrestige);
      saveState.prestigePerTurn = BigNumSave.save(totals.prestigePerTurn);
      saveState.goldPerTurn = BigNumSave.save(totals.goldPerTurn);
      saveState.orePerTurn = BigNumSave.save(totals.orePerTurn);
      saveState.rubyPerTurn = BigNumSave.save(totals.rubyPerTurn);
      saveState.offlinePrestige = BigNumSave.save(totals.offlinePrestige);
      saveState.offlineGold = BigNumSave.save(totals.offlineGold);
      saveState.offlineOre = BigNumSave.save(totals.offlineOre);
      saveState.offlineRuby = BigNumSave.save(totals.offlineRuby);
      saveState.offlineSeconds = totals.offlineSeconds;
      saveState.countedOfflineSeconds = totals.countedOfflineSeconds;
      saveState.prestigePerTurnCalc = ValuePerTurnSave.generateSave(totals.prestigeRatePerTurnCalculator);
      saveState.goldPerTurnCalc = ValuePerTurnSave.generateSave(totals.goldRatePerTurnCalculator);
      saveState.orePerTurnCalc = ValuePerTurnSave.generateSave(totals.oreRatePerTurnCalculator);
      saveState.rubyPerTurnCalc = ValuePerTurnSave.generateSave(totals.rubyRatePerTurnCalculator);
      return saveState;
    }
    /**
     * @param {Totals} totals
     * @param {Object} saveState 
     */
    static loadSave(totals, saveState) {
      if (!saveState) {
        return;
      }
      BigNumSave.load(saveState.ore, totals.ore);
      BigNumSave.load(saveState.gold, totals.gold);
      BigNumSave.load(saveState.ruby, totals.ruby);
      BigNumSave.load(saveState.prestige, totals.prestige);
      BigNumSave.load(saveState.prestigeSum, totals.prestigePointsSum);
      BigNumSave.load(saveState.unclaimed, totals.unclaimedPrestige);
      BigNumSave.load(saveState.prestigePerTurn, totals.prestigePerTurn);
      BigNumSave.load(saveState.goldPerTurn, totals.goldPerTurn);
      BigNumSave.load(saveState.orePerTurn, totals.orePerTurn);
      BigNumSave.load(saveState.rubyPerTurn, totals.rubyPerTurn);
      BigNumSave.load(saveState.offlinePrestige, totals.offlinePrestige);
      BigNumSave.load(saveState.offlineGold, totals.offlineGold);
      BigNumSave.load(saveState.offlineOre, totals.offlineOre);
      BigNumSave.load(saveState.offlineRuby, totals.offlineRuby);
      if (saveState.offlineSeconds) {
        totals.offlineSeconds = saveState.offlineSeconds;
      }
      if (saveState.countedOfflineSeconds) {
        totals.countedOfflineSeconds = saveState.countedOfflineSeconds;
      }
      ValuePerTurnSave.loadSave(totals.prestigeRatePerTurnCalculator, saveState.prestigePerTurnCalc);
      ValuePerTurnSave.loadSave(totals.goldRatePerTurnCalculator, saveState.goldPerTurnCalc);
      ValuePerTurnSave.loadSave(totals.oreRatePerTurnCalculator, saveState.orePerTurnCalc);
      ValuePerTurnSave.loadSave(totals.rubyRatePerTurnCalculator, saveState.rubyPerTurnCalc);
    }
  };

  // src/model/save/GameTimeSave.js
  var GameTimeSave = class {
    constructor() {
    }
    /**
     * @param {GameTime} gameTime 
     * @returns {Object}
     */
    static generateSave(gameTime) {
      const saveState = {};
      saveState.turn = gameTime.turnNumber;
      saveState.time = Date.now();
      return saveState;
    }
    /**
     * @param {GameTime} gameTime 
     * @param {Object} saveState 
     */
    static loadSave(gameTime, saveState) {
      if (!saveState) {
        return;
      }
      gameTime.turnNumber = saveState.turn;
      gameTime.saveTime = saveState.time;
    }
  };

  // src/model/save/ValuesSave.js
  var ValuesSave = class {
    constructor() {
    }
    /**
     * @param {Values} values
     * @returns {Object}
     */
    static generateSave(values) {
      const saveState = {};
      saveState.mineDamageMultiplier = BigNumSave.save(values.minedDamageBonusMultiplier.getValue());
      saveState.mineOreBonus = BigNumSave.save(values.minedOreBonus.getValue());
      return saveState;
    }
    /**
     * @param {Values} values
     * @param {Object} saveState 
     */
    static loadSave(values, saveState) {
      if (!saveState) {
        return;
      }
      BigNumSave.load(saveState.mineDamageMultiplier, values.minedDamageBonusMultiplier.getValue());
      BigNumSave.load(saveState.mineOreBonus, values.minedOreBonus.getValue());
    }
  };

  // src/model/save/MinedUpgradeCollectionSave.js
  var MinedUpgradeCollectionSave = class {
    constructor() {
    }
    /**
     * @param {MinedUpgradeCollection} upgradeCollection
     * @returns {Object}
     */
    static generateSave(upgradeCollection) {
      const saveState = {};
      saveState.upgrades = [];
      for (let i = 0; i < upgradeCollection.upgrades.length; i++) {
        if (!upgradeCollection.upgrades[i]) {
          continue;
        }
        saveState.upgrades.push(this.generateUpgradeSave(upgradeCollection.upgrades[i]));
      }
      return saveState;
    }
    /**
     * @param {MinedUpgradeCollection} upgradeCollection
     * @param {UpgradeCreators} upgradeCreators
     * @param {Object} saveState 
     */
    static loadSave(upgradeCollection, upgradeCreators, saveState) {
      if (!saveState) {
        console.log("MinedUpgradeCollectionSave.loadSave no save state");
        return;
      }
      const upgradeSaves = saveState.upgrades;
      if (!upgradeSaves) {
        console.log("MinedUpgradeCollectionSave.loadSave state empty");
        return;
      }
      for (let i = 0; i < upgradeSaves.length; i++) {
        const upgrade = this.loadUpgradeSave(upgradeCreators, upgradeSaves[i]);
        if (upgrade) {
          upgradeCollection.addBulk(upgrade);
        }
      }
      upgradeCollection.addBulkCompleted();
    }
    /**
     * @private
     * @param {Upgrade} upgrade 
     * @returns {Object}
     */
    static generateUpgradeSave(upgrade) {
      const creatorId = upgrade.getCreatorId();
      const saveState = {};
      saveState.creatorId = creatorId;
      if (creatorId === UpgadeCreatorIds.mineDamage) {
        this.generateFreeValueUpgradeSave(upgrade, saveState);
      } else if (creatorId === UpgadeCreatorIds.mineOre) {
        this.generateMinedOreUpgradeSave(upgrade, saveState);
      } else {
        console.log("MinedUpgradeCollectionSave.generateUpgradeSave() No save logic associated with creatorId: " + creatorId);
      }
      return saveState;
    }
    /**
     * @private
     * @param {UpgradeCreators} upgradeCreators 
     * @param {Object} upgradeSave 
     * @returns {Upgrade}
     */
    static loadUpgradeSave(upgradeCreators, upgradeSave) {
      if (!upgradeSave) {
        return null;
      }
      const creatorId = upgradeSave.creatorId;
      if (!creatorId) {
        return null;
      }
      const upgradeCreator = upgradeCreators.getUpgradeCreatorById(creatorId);
      if (!upgradeCreator) {
        console.log("MinedUpgradeCollectionSave.loadUpgradeSave() Failed to find upgrade creator ID=" + creatorId);
        return null;
      }
      if (creatorId === UpgadeCreatorIds.mineDamage) {
        return this.loadFreeValueUpgradeSave(upgradeCreator, upgradeSave);
      } else if (creatorId === UpgadeCreatorIds.mineOre) {
        return this.loadMinedOreUpgradeSave(upgradeCreator, upgradeSave);
      } else {
        console.log("MinedUpgradeCollectionSave.loadUpgradeSave() No save logic associated with creatorId: " + creatorId);
        return null;
      }
    }
    /////////////////////////////////////////////////////
    /**
     * @private
     * @param {MinedUpgrade} minedUpgrade 
     * @param {Object} saveState
     */
    static generateFreeValueUpgradeSave(minedUpgrade, saveState) {
      if (minedUpgrade.cost) {
        saveState.cost = BigNumSave.save(minedUpgrade.cost);
      }
      saveState.value = BigNumSave.save(minedUpgrade.valueDelta);
    }
    /**
     * @private
     * @param {UpgradeCreator} upgradeCreator
     * @param {Object} upgradeSave 
     * @returns {Upgrade}
     */
    static loadFreeValueUpgradeSave(upgradeCreator, upgradeSave) {
      let valueDelta = new BigNum(0);
      BigNumSave.load(upgradeSave.value, valueDelta);
      return upgradeCreator.createFreeValueUpgradeFromSave(valueDelta);
    }
    /**
     * @private
     * @param {MinedOreUpgrade} minedUpgrade 
     * @param {Object} saveState
     */
    static generateMinedOreUpgradeSave(minedUpgrade, saveState) {
      if (minedUpgrade.cost) {
        saveState.cost = BigNumSave.save(minedUpgrade.cost);
      }
      saveState.value = BigNumSave.save(minedUpgrade.ore);
    }
    /**
     * @private
     * @param {UpgradeCreator} upgradeCreator
     * @param {Object} upgradeSave 
     * @returns {Upgrade}
     */
    static loadMinedOreUpgradeSave(upgradeCreator, upgradeSave) {
      let valueDelta = new BigNum(0);
      BigNumSave.load(upgradeSave.value, valueDelta);
      return upgradeCreator.createFreeValueUpgradeFromSave(valueDelta);
    }
  };

  // src/model/save/CharacterSave.js
  var CharacterSave = class {
    constructor() {
    }
    /**
     * @param {PartyCharacter} character
     * @returns {Object}
     */
    static generateSave(character) {
      const saveState = {};
      saveState.position = {
        x: character.position.worldCoordinateOrigin.x,
        y: character.position.worldCoordinateOrigin.y
      };
      saveState.facingLeft = character.position.facingLeft;
      if (character.skillId) {
        saveState.skillId = character.skillId;
      }
      return saveState;
    }
    /**
     * @param {PartyCharacter} character
     * @param {Object} saveState 
     */
    static loadSave(character, saveState) {
      if (!saveState) {
        return;
      }
      character.position.setWorldCoordinateOriginXY(saveState.position.x, saveState.position.y);
      character.position.facingLeft = saveState.facingLeft;
      if (saveState.skillId) {
        character.skillId = saveState.skillId;
      }
    }
  };

  // src/model/save/CrewSave.js
  var CrewSave = class {
    constructor() {
    }
    /**
     * @param {Crew} crew
     * @returns {Object}
     */
    static generateSave(crew) {
      const saveState = {};
      saveState.miners = [];
      for (let i = 0; i < crew.miners.length; i++) {
        saveState.miners.push(CharacterSave.generateSave(crew.miners[i]));
      }
      return saveState;
    }
    /**
     * @param {Crew} crew
     * @param {Object} saveState 
     */
    static loadSave(crew, saveState) {
      if (!saveState) {
        console.log("CrewSave.loadSave() No save state. Not loading crew!");
        return;
      }
      const minerStates = saveState.miners;
      if (!minerStates || minerStates.length === 0) {
        console.log("CrewSave.loadSave() No miners data found");
        return;
      }
      console.log("CrewSave.loadSave() create main miner");
      const mainMiner = crew.createMainMiner();
      CharacterSave.loadSave(mainMiner, minerStates[0]);
      for (let i = 1; i < minerStates.length; i++) {
        const character = crew.addNewMinerForSaveLoad();
        CharacterSave.loadSave(character, minerStates[i]);
      }
    }
  };

  // src/model/character/PartyTarget.js
  var PartyTarget = class extends GameModel {
    /**
     * @param {Totals} totals 
     * @param {Damage} damage
     */
    constructor(totals, damage) {
      super();
      this.totals = totals;
      this.damage = damage;
      this.layerDescription = LayerDescriptions.DIRT_LAYER;
      this.nextLayerDescription = this.findNextLayerDescription();
      this.defaultMineSeconds = 1;
      this.targetMineSeconds = 1;
      this.targetRow = 0;
      this.workingBrickHealth = new BigNum(0);
      this.halfDeltaRows = 15;
    }
    /**
     * Update the target mine seconds to match the specified row.
     * @param {number} rowNumber 
     */
    deriveTargetSecondsForRow(rowNumber) {
      if (this.layerDescription.containsRow(rowNumber)) {
        this.deriveTargetSecondsInternal(this.layerDescription, rowNumber);
        return;
      }
      const prevLayer = this.layerDescription.prevLayer;
      if (prevLayer && prevLayer.containsRow(rowNumber)) {
        this.deriveTargetSecondsInternal(prevLayer, rowNumber);
        return;
      }
      const nextLayer = this.layerDescription.nextLayer;
      if (nextLayer && nextLayer.containsRow(rowNumber)) {
        this.deriveTargetSecondsInternal(nextLayer, rowNumber);
        return;
      }
      const layerDescription = getLayerDescriptionForRow(rowNumber);
      if (layerDescription) {
        this.deriveTargetSecondsInternal(layerDescription, rowNumber);
        return;
      }
      console.log("PartyTarget.deriveTargetSecondsForRow() Failed to update target mine seconds");
    }
    /**
     * @private
     * @param {LayerDescription} layerDescription 
     * @param {number} rowNumber 
     */
    deriveTargetSecondsInternal(layerDescription, rowNumber) {
      layerDescription.calculateTileHealth(rowNumber, this.workingBrickHealth);
      this.targetMineSeconds = this.damage.calculateMineSeconds(this.workingBrickHealth);
    }
    /**
     * This should be invoked before we generate a new vector field.
     */
    calculateTargetRow() {
      this.damage.calculateMaxBrickHealth(this.targetMineSeconds, this.workingBrickHealth);
      const layer = findLayerForHealth(this.layerDescription, this.workingBrickHealth);
      this.targetRow = Math.max(Settings.target.minTargetRow, layer.calculateTileDepth(this.workingBrickHealth));
    }
    /**
     * @param {LayerDescription} layerDescription 
     */
    setLayerDescriptionFromSave(layerDescription) {
      this.layerDescription = layerDescription;
      this.nextLayerDescription = this.findNextLayerDescription();
      this.calculateTargetRow();
    }
    /**
     * @returns {LayerDescription}
     */
    findNextLayerDescription() {
      for (let i = 0; i < LayerDescriptionArray.length; i++) {
        const layerDescription = LayerDescriptionArray[i];
        if (layerDescription.prevLayer === this.layerDescription) {
          return layerDescription;
        }
      }
      return null;
    }
    unlockNextLayer() {
      if (!this.nextLayerDescription) {
        console.log("PartyTarget.unlockNextLayer() No next layer!");
        return;
      }
      this.layerDescription = this.nextLayerDescription;
      this.calculateTargetRow();
      this.nextLayerDescription = this.findNextLayerDescription();
      this.totals.onTerrainLayerUnlocked();
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.layerDescription = LayerDescriptions.DIRT_LAYER;
      this.nextLayerDescription = this.findNextLayerDescription();
      this.targetMineSeconds = this.defaultMineSeconds;
      this.calculateTargetRow();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/save/PartyTargetSave.js
  var PartyTargetSave = class {
    constructor() {
    }
    /**
     * @param {PartyTarget} partyTarget 
     * @returns {Object}
     */
    static generateSave(partyTarget) {
      const saveState = {};
      saveState.layerId = partyTarget.layerDescription.id;
      saveState.targetMineSeconds = partyTarget.targetMineSeconds;
      return saveState;
    }
    /**
     * @param {PartyTarget} partyTarget 
     * @param {Object} saveState 
     */
    static loadSave(partyTarget, saveState) {
      if (!saveState) {
        return;
      }
      if (saveState.targetMineSeconds) {
        partyTarget.targetMineSeconds = saveState.targetMineSeconds;
      }
      const layerId = saveState.layerId;
      const layerDescription = LayerDescriptionMap[layerId];
      if (layerDescription) {
        partyTarget.setLayerDescriptionFromSave(layerDescription);
      } else {
        console.log("PartyTargetSave.loadSave() Failed to find layer description: " + layerId);
      }
    }
  };

  // src/model/save/GridSaveManagerSave.js
  var GridSaveManagerSave = class {
    constructor() {
    }
    /**
     * @param {GridSaveManager} gridSaveManager 
     * @returns {Object}
     */
    static generateSave(gridSaveManager) {
      const saveState = {};
      saveState.metaArray = [];
      for (const gridMeta of gridSaveManager.metadataByKey.values()) {
        const metaState = this.generateMetaState(gridMeta);
        if (metaState) {
          saveState.metaArray.push(metaState);
        }
      }
      return saveState;
    }
    /**
     * @param {GridSaveManager} gridSaveManager 
     * @param {Object} saveState 
     */
    static loadSave(gridSaveManager, saveState) {
      if (!saveState) {
        console.log("GridSaveManagerSave.loadSave() no data found in save 1");
        return;
      }
      const metaArray = saveState.metaArray;
      if (!metaArray || metaArray.length === 0) {
        console.log("GridSaveManagerSave.loadSave() no data found in save 2");
        return;
      }
      for (let i = 0; i < metaArray.length; i++) {
        const gridSaveMeta = this.loadMetaState(metaArray[i]);
        if (gridSaveMeta) {
          gridSaveManager.addGridSaveMetaFromSave(gridSaveMeta);
        }
      }
    }
    /**
     * @private
     * @param {GridSaveMeta} gridMeta 
     * @returns {Object}
     */
    static generateMetaState(gridMeta) {
      const metaState = {};
      metaState.k = gridMeta.gridKey;
      metaState.c = gridMeta.gridCol;
      metaState.r = gridMeta.gridRow;
      return metaState;
    }
    /**
     * @private
     * @param {Object} metaState 
     * @returns {GridSaveMeta}
     */
    static loadMetaState(metaState) {
      if (!metaState) {
        return null;
      }
      return new GridSaveMeta(metaState.k, metaState.c, metaState.r);
    }
  };

  // src/model/upgrade/classic/UpgradeCostCalculator.js
  var UpgradeCostCalculator = class {
    /**
     */
    constructor() {
    }
    /**
     * @abstract
     * @param {number} currentPurchaseCount 
     * @param {BigNum} out The output param
     */
    getNextPurchaseCost(currentPurchaseCount, out) {
    }
    /**
     * @abstract
     * @param {BigNum} singlePurchaseCost The cost of purchasing a single building.
     * @param {number} numberToPurchase   Must be greater than 1.
     * @param {BigNum} out The output param
     * @returns {BigNum}
     */
    calculateBulkPurchaseCost(singlePurchaseCost, numberToPurchase, out) {
    }
    /**
     * Returns the number of upgrades that can be purchased based on how much money we have.
     * @abstract
     * @param {BigNum} money The total amount of money the player has.
     * @param {BigNum} singlePurchaseCost The cost of purchasing a single upgrade.
     * @return {number}
     */
    calculateMaxAffordable(money, singlePurchaseCost) {
      return 0;
    }
  };

  // src/model/upgrade/classic/CountToPurchase.js
  var CountToPurchase = {
    /**
     * @constant
     * @type {number}
     */
    purchaseOne: 1,
    /**
     * @constant
     * @type {number}
     */
    purchaseFive: 5,
    /**
     * @constant
     * @type {number}
     */
    purchaseTen: 10,
    /**
     * @constant
     * @type {number}
     */
    purchaseMax: -1
  };

  // src/model/upgrade/classic/ClassicUpgrade.js
  var ClassicUpgrade = class extends Upgrade {
    /**
     * @abstract
     * @param {string} id
     * @param {string} title
     * @param {string} iconFileName
     * @param {UpgradeCostCalculator} costCalculator 
     * @param {number} maxCount Set to -1 for no max count.
     */
    constructor(id, title, iconFileName, costCalculator, maxCount) {
      super(title, iconFileName);
      this.id = id;
      this.costCalculator = costCalculator;
      this.maxCount = maxCount;
      this.singlePurchaseCost = new BigNum(0);
      this.cost = new BigNum(0);
      this.countToPurchase = CountToPurchase.purchaseOne;
      this.countToPurchaseUsedInCalculation = CountToPurchase.purchaseOne;
      this.maxAffordableCount = 0;
      this.nextActualPurchaseCount = 0;
      this.workingCost = new BigNum(0);
    }
    initializeCosts() {
      this.calculateCostsAfterCountChange();
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isVisible() {
      return true;
    }
    /**
     * @returns {boolean}
     */
    isMaxCountReached() {
      const maxCount = this.getMaxPurchaseCount();
      return maxCount > 0 && this.purchasedCount >= maxCount;
    }
    /**
     * @returns {number}
     */
    getMaxPurchaseCount() {
      return this.maxCount;
    }
    /**
     * @override
     * @returns {number}
     */
    getPurchasedCount() {
      return this.purchasedCount;
    }
    /**
     * @override
     * @param {number} purchasedCount 
     */
    setPurchasedCount(purchasedCount) {
      this.purchasedCount = this.maxCount > 0 ? Math.min(this.maxCount, purchasedCount) : purchasedCount;
      this.calculateCostsAfterCountChange();
    }
    /**
     * @override
     * @param {number} purchasedCount The number of upgrade purchases that have been made. 
     */
    setPurchasedCountFromSave(purchasedCount) {
      this.setPurchasedCount(purchasedCount);
      this.onUpgradePurchased(0, this.purchasedCount);
    }
    /**
     * @returns {BigNum}
     */
    getSinglePurchaseCost() {
      return this.singlePurchaseCost;
    }
    // /**
    //  * @param {number} countToPurchaseSetting See CountToPurchase
    //  * @param {BigNum} out
    //  * @returns {BigNum}
    //  */
    // getCostForCount(countToPurchaseSetting, out) {
    //     return this.getCostForActualCount(this.getActualCountToPurchase(countToPurchaseSetting), out);
    // }
    /**
     * @private
     * @param {number} actualPurchaseCount 
     * @param {BigNum} out
     * @returns {BigNum}
     */
    getCostForActualCount(actualPurchaseCount, out) {
      if (actualPurchaseCount <= 0) {
        out.setZero();
        return out;
      }
      if (actualPurchaseCount === 1) {
        out.copy(this.singlePurchaseCost);
        return out;
      } else {
        return this.costCalculator.calculateBulkPurchaseCost(this.singlePurchaseCost, actualPurchaseCount, out);
      }
    }
    /**
     * Returns the number of things to purchase. taking 'max' into consideration.
     * @returns {number}
     */
    getPurchaseCountNumber() {
      return this.getActualCountToPurchase(this.getCountToPurchaseSetting());
    }
    /**
     * The number of things to purchase, taking 'CountToPurchase.max' and max purchase count into consideration
     * @private
     * @param {number} countToPurchase See CountToPurchase
     * @returns {number}
     */
    getActualCountToPurchase(countToPurchase) {
      if (countToPurchase === CountToPurchase.purchaseMax) {
        return this.maxAffordableCount;
      } else {
        const maxCount = this.getMaxPurchaseCount();
        const currentCount = this.getPurchasedCount();
        if (currentCount + countToPurchase <= maxCount) {
          return countToPurchase;
        } else {
          return maxCount - currentCount;
        }
      }
    }
    /**
     * @param {number} countToPurchase See CountToPurchase
     * @returns {boolean} true if the purchase was made.
     */
    purchaseAmount(countToPurchase) {
      return this.purchaseActualAmount(this.getActualCountToPurchase(countToPurchase));
    }
    /**
     * @param {number} purchaseCount A positive integer.
     * @returns {boolean} true if the purchase was made.
     */
    purchaseActualAmount(purchaseCount) {
      const maxCount = this.getMaxPurchaseCount();
      const currentCount = this.getPurchasedCount();
      if (maxCount > 0 && currentCount >= maxCount) {
        return false;
      }
      if (maxCount > 0 && purchaseCount + currentCount > maxCount) {
        purchaseCount = maxCount - currentCount;
      }
      const costForCount = this.getCostForActualCount(purchaseCount, this.workingCost);
      if (costForCount.lessThanEqualsZero()) {
        return false;
      }
      if (costForCount.greaterThan(this.getMoney())) {
        return false;
      }
      this.decrementMoney(costForCount);
      this.onUpgradePurchased(currentCount, purchaseCount);
      this.setPurchasedCount(currentCount + purchaseCount);
      return true;
    }
    /**
     * @private 
     */
    calculateCostsAfterCountChange() {
      this.costCalculator.getNextPurchaseCost(this.getPurchasedCount(), this.singlePurchaseCost);
      const countToPurchaseSetting = this.getCountToPurchaseSetting();
      if (countToPurchaseSetting === CountToPurchase.purchaseMax) {
        this.recalculateMaxPurchaseCount();
        this.nextActualPurchaseCount = this.maxAffordableCount;
      } else {
        this.nextActualPurchaseCount = this.getActualCountToPurchase(countToPurchaseSetting);
        this.cost = this.getCostForActualCount(this.nextActualPurchaseCount, this.cost);
      }
    }
    /**
     * Figure out how many upgrades can be purchased right now based on the total money.
     * This updates the maxAffordableCount and costMax properties.
     */
    recalculateMaxPurchaseCount() {
      const money = this.getMoney();
      this.maxAffordableCount = this.costCalculator.calculateMaxAffordable(money, this.singlePurchaseCost);
      if (this.maxAffordableCount > 0) {
        const count = this.getPurchasedCount();
        const maxCount = this.getMaxPurchaseCount();
        if (maxCount > 0 && count + this.maxAffordableCount > maxCount) {
          this.maxAffordableCount = Math.max(0, maxCount - count);
          if (this.maxAffordableCount === 0) {
            this.cost.copy(this.singlePurchaseCost);
            return;
          }
        }
        this.cost = this.costCalculator.calculateBulkPurchaseCost(this.singlePurchaseCost, this.maxAffordableCount, this.cost);
      } else {
        this.cost.copy(this.singlePurchaseCost);
      }
    }
    /////////////////////////////////////////////
    // Abstract methods for our sub-classes
    /////////////////////////////////////////////
    /**
     * Returns the setting for the count to purchase.  See the CountToPurchase enum.
     * @abstract
     * @returns {number}
     */
    getCountToPurchaseSetting() {
      return this.countToPurchase;
    }
    /**
     * @abstract
     * @returns {BigNum}
     */
    getMoney() {
    }
    /**
     * @abstract
     * @param {BigNum} money 
     */
    decrementMoney(money) {
    }
    /**
     * Invoked by the base class to let the sub-class know that a purchase has been made.
     * @abstract
     * @param {number} currentCount This is the before value.
     * @param {number} purchaseCount 
     */
    onUpgradePurchased(currentCount, purchaseCount) {
    }
    /////////////////////////////////////////////
    // Upgrade implementation
    /////////////////////////////////////////////
    /**
     * @override
     * @returns {boolean}
     */
    isPurchasable() {
      return this.isAffordable() && !this.isMaxCountReached();
    }
    /**
     * @override
     * @returns {boolean}
     */
    isAffordable() {
      return this.cost.lessThanEquals(this.getMoney());
    }
    /**
     * @override
     * @returns {BigNum}
     */
    getCost() {
      const countToPurchaseSetting = this.getCountToPurchaseSetting();
      if (this.countToPurchaseUsedInCalculation !== countToPurchaseSetting) {
        this.countToPurchaseUsedInCalculation = countToPurchaseSetting;
        this.calculateCostsAfterCountChange();
      } else if (countToPurchaseSetting === CountToPurchase.purchaseMax) {
        this.calculateCostsAfterCountChange();
      }
      return this.cost;
    }
    /**
     * @override
     * @returns {boolean} true if the purchase was made.
     */
    purchase() {
      return this.purchaseAmount(this.getCountToPurchaseSetting());
    }
    resetUpgrade() {
      super.resetUpgrade();
      this.calculateCostsAfterCountChange();
    }
  };

  // src/model/upgrade/classic/ClassicUpgradeCollection.js
  var ClassicUpgradeCollection = class extends UpgradeCollection {
    constructor() {
      super();
      this.countToPurchase = CountToPurchase.purchaseOne;
    }
    /**
     * @param {number} countToPurchase 
     */
    setCountToPurchase(countToPurchase) {
      if (this.countToPurchase === countToPurchase) {
        return;
      }
      this.countToPurchase = countToPurchase;
      for (let i = 0; i < this.upgrades.length; i++) {
        this.upgrades[i].countToPurchase = countToPurchase;
      }
    }
    /**
     * @abstract
     * @param {Totals} totals 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     */
    initializeUpgrades(totals, values, mineDamageLogic) {
    }
    /**
     * @param {string} id 
     * @returns {ClassicUpgrade}
     */
    findById(id) {
      for (let i = 0; i < this.upgrades.length; i++) {
        const upgrade = this.upgrades[i];
        if (upgrade.id === id) {
          return upgrade;
        }
      }
      return null;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      for (let i = 0; i < this.upgrades.length; i++) {
        this.upgrades[i].resetUpgrade();
      }
    }
    // /**
    //  * @override
    //  */
    // resetForPrestige() {
    //     this.resetFull();
    // }
  };

  // src/model/upgrade/classic/ClassicUpgradeCostCalculator.js
  var ClassicUpgradeCostCalculator = class extends UpgradeCostCalculator {
    /**
     * @param {BigNum} baseCost 
     * @param {number} costGrowthRate 
     */
    constructor(baseCost, costGrowthRate) {
      super();
      this.baseCost = baseCost;
      this.costGrowthRate = new BigNum(costGrowthRate);
      this.working = new BigNum(0);
      this.working2 = new BigNum(0);
      this.one = new BigNum(1);
      this.logCostFactor = Math.log(costGrowthRate);
    }
    /**
     * @override
     * @param {number} currentPurchaseCount 
     * @param {BigNum} out The output param
     */
    getNextPurchaseCost(currentPurchaseCount, out) {
      out.copy(this.costGrowthRate).pow(currentPurchaseCount).multiply(this.baseCost);
    }
    /*
    
        break_infinity:
    
      function affordGeometricSeries(resourcesAvailable, priceStart, priceRatio, currentOwned) {
        var actualStart = priceStart.mul(priceRatio.pow(currentOwned));
        return Decimal.floor(resourcesAvailable.div(actualStart).mul(priceRatio.sub(1)).add(1).log10() / priceRatio.log10());
      }
    
      function sumGeometricSeries(numItems, priceStart, priceRatio, currentOwned) {
        return priceStart.mul(priceRatio.pow(currentOwned)).mul(Decimal.sub(1, priceRatio.pow(numItems))).div(Decimal.sub(1, priceRatio));
      }
    
    */
    /**
     * @override
     * @param {BigNum} singlePurchaseCost The cost of purchasing a single building.
     * @param {number} numberToPurchase   Must be greater than 1.
     * @param {BigNum} out The output param
     * @returns {BigNum}
     */
    calculateBulkPurchaseCost(singlePurchaseCost, numberToPurchase, out) {
      this.working.copy(this.costGrowthRate);
      this.working.pow(numberToPurchase).sub(this.one);
      this.working2.copy(this.costGrowthRate);
      this.working2.sub(this.one);
      this.working.divide(this.working2);
      out.copy(singlePurchaseCost).multiply(this.working);
      return out;
    }
    /**
     * Returns the number of upgrades that can be purchased based on how much money we have.
     * @override
     * @param {BigNum} money The total amount of money the player has.
     * @param {BigNum} singlePurchaseCost The cost of purchasing a single upgrade.
     * @return {number}
     */
    calculateMaxAffordable(money, singlePurchaseCost) {
      if (singlePurchaseCost.greaterThan(money)) {
        return 0;
      }
      this.working.copy(this.costGrowthRate).sub(this.one);
      this.working.multiply(money).divide(singlePurchaseCost);
      this.working.add(this.one);
      const d = this.working.ln();
      return d / this.logCostFactor | 0;
    }
  };

  // src/model/upgrade/UpgradeCostUnit.js
  var UpgradeCostUnit = {
    /**
     * @constant
     * @type {string}
     */
    FREE: "free",
    /**
     * @constant
     * @type {string}
     */
    ORE: "Ore",
    /**
     * @constant
     * @type {string}
     */
    GOLD: "Gold",
    /**
     * @constant
     * @type {string}
     */
    PRESTIGE: "Prestige"
  };

  // src/model/upgrade/ore/PickUpgrade.js
  var PickUpgrade = class extends ClassicUpgrade {
    /**
     * @param {string} id
     * @param {string} title
     * @param {string} iconFileName
     * @param {UpgradeCostCalculator} upgradeCostCalculator 
     * @param {Totals} totals
     * @param {MineDamageLogic} mineDamageLogic
     * @param {BigNumValue} upgradeBonusValue External value holder for upgrade bonus.
     * @param {BigNum} valuePerUpgrade
     * @param {PickUpgrade} dependentUpgrade
     * @param {number} requiredPurchaseCount
     * @param {number} maxCount
     * @param {boolean} additiveUpgrade False for multiplicative
     */
    constructor(id, title, iconFileName, upgradeCostCalculator, totals, mineDamageLogic, upgradeBonusValue, valuePerUpgrade, dependentUpgrade, requiredPurchaseCount, maxCount, additiveUpgrade) {
      super(id, title, iconFileName, upgradeCostCalculator, maxCount);
      this.totals = totals;
      this.mineDamageLogic = mineDamageLogic;
      this.upgradeBonusValue = upgradeBonusValue;
      this.valuePerUpgrade = valuePerUpgrade;
      this.dependentUpgrade = dependentUpgrade;
      this.requiredPurchaseCount = requiredPurchaseCount;
      this.workingValue = new BigNum(0);
      this.additiveUpgrade = additiveUpgrade;
      this.initializeCosts();
    }
    /**
     * @override
     * @returns {boolean}
     */
    isVisible() {
      if (this.purchasedCount >= this.maxCount) {
        return false;
      }
      if (this.dependentUpgrade && this.dependentUpgrade.purchasedCount < this.requiredPurchaseCount) {
        return false;
      }
      return true;
    }
    //////////////////////////////////////
    // Upgrade overrides
    //////////////////////////////////////
    /**
     * @override
     * @returns {string} See UpgradeCostUnit
     */
    getCostUnit() {
      return UpgradeCostUnit.ORE;
    }
    //////////////////////////////////////
    // ClassicUpgrade overrides
    //////////////////////////////////////
    /**
     * @override
     * @returns {BigNum}
     */
    getMoney() {
      return this.totals.ore;
    }
    /**
     * @override
     * @param {BigNum} money 
     */
    decrementMoney(money) {
      this.totals.decrementOre(money);
    }
    /**
     * Invoked by the base class to let the sub-class know that a purchase has been made.
     * @override
     * @param {number} currentCount This is the before value.
     * @param {number} purchaseCount 
     */
    onUpgradePurchased(currentCount, purchaseCount) {
      this.workingValue.copy(this.valuePerUpgrade);
      if (purchaseCount > 1) {
        this.workingValue.mulNumber(purchaseCount);
      }
      this.upgradeBonusValue.incrementValue(this.workingValue);
      this.mineDamageLogic.calculateTotalMineDamagePerTurn();
    }
  };

  // src/model/upgrade/ore/PickUpgradeCollection.js
  var PickUpgradeCollection = class extends ClassicUpgradeCollection {
    /**
     * @param {Totals} totals 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     */
    constructor(totals, values, mineDamageLogic) {
      super();
      this.initializeUpgrades(totals, values, mineDamageLogic);
    }
    /**
     * @override
     * @param {Totals} totals 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     */
    initializeUpgrades(totals, values, mineDamageLogic) {
      let prevUpgrade = null;
      for (let i = 0; i < 100; i++) {
        const upgrade = this.generateBaseDamageUpgrade(i, totals, values, mineDamageLogic, prevUpgrade);
        prevUpgrade = upgrade;
      }
      prevUpgrade = null;
      for (let i = 1; i < 100; i++) {
        const upgrade = this.generateMultiplicativeUpgrade(i, totals, values, mineDamageLogic, prevUpgrade);
        prevUpgrade = upgrade;
      }
      this.addBulkCompleted();
    }
    /**
     * @private
     * @param {number} i 
     * @param {Totals} totals 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     * @param {PickUpgrade} prevUpgrade
     * @returns {PickUpgrade}
     */
    generateMultiplicativeUpgrade(i, totals, values, mineDamageLogic, prevUpgrade) {
      const multiplier = i < 10 ? 0.05 : i < 20 ? 0.1 : i < 30 ? 0.2 : i < 40 ? 0.35 : i < 50 ? 0.45 : i < 60 ? 0.7 : i < 70 ? 1 : i < 80 ? 1.35 : i < 90 ? 1.75 : 2;
      const upgradeValue = new BigNum(multiplier * i);
      const costCalculator = this.createCostCalculator(i);
      const label = "Multiplier: +" + NumberFormatter.formatBigNum(upgradeValue);
      const upgrade = new PickUpgrade(
        "m" + i,
        label,
        Images.pick,
        costCalculator,
        totals,
        mineDamageLogic,
        values.baseMultiplicativeBonusValue,
        upgradeValue,
        prevUpgrade,
        20,
        150,
        false
      );
      this.addBulk(upgrade);
      return upgrade;
    }
    /**
     * @private
     * @param {number} i 
     * @param {Totals} totals 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     * @param {PickUpgrade} prevUpgrade
     * @returns {PickUpgrade}
     */
    generateBaseDamageUpgrade(i, totals, values, mineDamageLogic, prevUpgrade) {
      const valueBase = 1.35;
      const valueExp = 2.5;
      const val = i + 0.01;
      const valuePerTurn = new BigNum(valueBase);
      valuePerTurn.pow(val * valueExp);
      const valuePerSecond = new BigNum(0);
      valuePerSecond.copy(valuePerTurn);
      valuePerSecond.mulNumber(Settings.time.turnsPerSecond);
      const formattedValuePerSecond = NumberFormatter.formatBigNum(valuePerSecond);
      const costCalculator = this.createCostCalculator(i + 1);
      console.log("PICK BASE: i=" + i + " perTurn=" + NumberFormatter.formatBigNum(valuePerTurn) + " perSec=" + formattedValuePerSecond);
      const upgrade = new PickUpgrade(
        "add" + i,
        "Base: +" + formattedValuePerSecond + "/sec",
        Images.pick,
        costCalculator,
        totals,
        mineDamageLogic,
        values.baseAdditiveBonusPerTurn,
        valuePerTurn,
        prevUpgrade,
        20,
        150,
        true
      );
      this.addBulk(upgrade);
      return upgrade;
    }
    /**
     * @private
     * @param {number} i 
     * @returns {UpgradeCostCalculator}
     */
    createCostCalculator(i) {
      const costBase = 2;
      const costExp = 4.4;
      const costGrowthRate = 1.1;
      const cost = Math.max(1, Math.floor(Math.pow(costBase, i * costExp)));
      return new ClassicUpgradeCostCalculator(new BigNum(cost), costGrowthRate);
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/save/PickUpgradeCollectionSave.js
  var PickUpgradeCollectionSave = class {
    constructor() {
    }
    /**
     * @param {PickUpgradeCollection} pickUpgradeCollection
     * @returns {Object}
     */
    static generateSave(pickUpgradeCollection) {
      const saveState = {};
      saveState.upgrades = [];
      for (let i = 0; i < pickUpgradeCollection.upgrades.length; i++) {
        const upgradeSave = this.generateUpgradeSave(pickUpgradeCollection.upgrades[i]);
        if (!upgradeSave) {
          continue;
        }
        saveState.upgrades.push(upgradeSave);
      }
      saveState.countToPurchase = pickUpgradeCollection.countToPurchase;
      return saveState;
    }
    /**
     * @param {PickUpgradeCollection} upgradeCollection
     * @param {Object} saveState 
     */
    static loadSave(upgradeCollection, saveState) {
      if (!saveState) {
        console.log("PickUpgradeCollectionSave.loadSave no save state");
        return;
      }
      const upgradeSaves = saveState.upgrades;
      if (!upgradeSaves) {
        console.log("PickUpgradeCollectionSave.loadSave state empty");
        return;
      }
      for (let i = 0; i < saveState.upgrades.length; i++) {
        this.loadUpgradeSave(upgradeCollection, saveState.upgrades[i]);
      }
      const countToPurchase = saveState.countToPurchase;
      if (countToPurchase) {
        upgradeCollection.setCountToPurchase(countToPurchase);
      }
    }
    /**
     * @private
     * @param {PickUpgrade} upgrade 
     * @returns {Object}
     */
    static generateUpgradeSave(upgrade) {
      if (upgrade.purchasedCount === 0) {
        return null;
      }
      const upgradeState = {};
      upgradeState.id = upgrade.id;
      upgradeState.c = upgrade.purchasedCount;
      return upgradeState;
    }
    /**
     * @private
     * @param {PickUpgradeCollection} pickUpgradeCollection
     * @param {Object} upgradeState
     */
    static loadUpgradeSave(pickUpgradeCollection, upgradeState) {
      if (!upgradeState) {
        return;
      }
      const id = upgradeState.id;
      const upgrade = pickUpgradeCollection.findById(id);
      if (!upgrade) {
        console.log("PickUpgradeCollectionSave.loadUpgradeSave() failed to find upgrade id=" + id);
        return;
      }
      const count = upgradeState.c;
      if (count === void 0) {
        return;
      }
      upgrade.setPurchasedCountFromSave(count);
    }
  };

  // src/model/save/StatisticsSave.js
  var StatisticsSave = class {
    constructor() {
    }
    /**
     * @param {Statistics} statistics
     * @returns {Object}
     */
    static generateSave(statistics) {
      const saveState = {};
      saveState.ore = BigNumSave.save(statistics.totalOre);
      saveState.gold = BigNumSave.save(statistics.totalGold);
      saveState.ruby = BigNumSave.save(statistics.totalRuby);
      saveState.prestige = BigNumSave.save(statistics.totalPrestigePoints);
      saveState.upgradeOre = BigNumSave.save(statistics.upgradeOre);
      saveState.maxDepth = statistics.maxDepth;
      saveState.turns = statistics.totalTurns;
      saveState.tiles = BigNumSave.save(statistics.tilesMined);
      saveState.tilesCommon = BigNumSave.save(statistics.tilesMinedCommon);
      saveState.tilesOre = BigNumSave.save(statistics.tilesMinedOre);
      saveState.tilesGold = BigNumSave.save(statistics.tilesMinedGold);
      saveState.tilesRuby = BigNumSave.save(statistics.tilesMinedRuby);
      saveState.tilesUpgrade = BigNumSave.save(statistics.tilesMinedUpgrade);
      saveState.tilesLaser = BigNumSave.save(statistics.tilesMinedLaser);
      saveState.tilesDrill = BigNumSave.save(statistics.tilesMinedDrill);
      saveState.tilesOrbit = BigNumSave.save(statistics.tilesMinedOrbit);
      saveState.tilesFissure = BigNumSave.save(statistics.tilesMinedFissure);
      saveState.tilesLightning = BigNumSave.save(statistics.tilesMinedLightning);
      saveState.tilesMissile = BigNumSave.save(statistics.tilesMinedMissile);
      return saveState;
    }
    /**
     * @param {Statistics} statistics
     * @param {Object} saveState 
     */
    static loadSave(statistics, saveState) {
      if (!saveState) {
        return;
      }
      BigNumSave.load(saveState.ore, statistics.totalOre);
      BigNumSave.load(saveState.gold, statistics.totalGold);
      BigNumSave.load(saveState.ruby, statistics.totalRuby);
      BigNumSave.load(saveState.prestige, statistics.totalPrestigePoints);
      BigNumSave.load(saveState.upgradeOre, statistics.upgradeOre);
      if (saveState.maxDepth) {
        statistics.maxDepth = saveState.maxDepth;
      }
      if (saveState.turns) {
        statistics.totalTurns = saveState.turns;
      }
      BigNumSave.load(saveState.tiles, statistics.tilesMined);
      BigNumSave.load(saveState.tilesCommon, statistics.tilesMinedCommon);
      BigNumSave.load(saveState.tilesOre, statistics.tilesMinedOre);
      BigNumSave.load(saveState.tilesGold, statistics.tilesMinedGold);
      BigNumSave.load(saveState.tilesRuby, statistics.tilesMinedRuby);
      BigNumSave.load(saveState.tilesUpgrade, statistics.tilesMinedUpgrade);
      BigNumSave.load(saveState.tilesLaser, statistics.tilesMinedLaser);
      BigNumSave.load(saveState.tilesDrill, statistics.tilesMinedDrill);
      BigNumSave.load(saveState.tilesOrbit, statistics.tilesMinedOrbit);
      BigNumSave.load(saveState.tilesFissure, statistics.tilesMinedFissure);
      BigNumSave.load(saveState.tilesLightning, statistics.tilesMinedLightning);
      BigNumSave.load(saveState.tilesMissile, statistics.tilesMinedMissile);
    }
  };

  // src/model/skillTree/SkillNodePurchaseListener.js
  var SkillNodePurchaseListener = class extends GameModel {
    constructor() {
      super();
    }
    /**
     * @abstract
     * @param {BigNum} pointsSpent
     */
    onNodePurchased(pointsSpent) {
    }
    /**
     * @abstract
     */
    onNodePurchasedFromSave() {
    }
  };

  // src/model/skillTree/SkillNode.js
  var SkillNode = class extends GameModel {
    /**
     * @param {string} id 
     * @param {string} title 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {SkillNodePurchaseListener} purchaseListener
     */
    constructor(id, title, description, totals, iconFileName, cost, purchaseListener) {
      super();
      this.parents = null;
      this.children = null;
      this.id = id;
      this.totals = totals;
      this.title = title;
      this.description = description;
      this.iconFileName = iconFileName;
      this.cost = cost;
      this.graphCoordinate = new Vector(0, 0);
      this.viewCoordinate = new Vector(0, 0);
      this.nodeVisible = true;
      this.purchaseListener = purchaseListener;
      this.parentNodePurchased = false;
      this.purchased = false;
    }
    /**
     * @returns {string}
     */
    getTitle() {
      return this.title;
    }
    /**
     * @returns {string}
     */
    getDescription() {
      return this.description;
    }
    /**
     * @param {number} cellX The x-coordinate in cells (not pixels)
     * @param {number} cellY The y-coordinate in cells (not pixels)
     */
    setPosition(cellX, cellY) {
      this.graphCoordinate.set(Settings.skillGraph.cellWidth * cellX, Settings.skillGraph.cellHeight * cellY);
    }
    /**
     * @returns {BigNum}
     */
    getCost() {
      return this.cost;
    }
    /**
     * This should only be called internally by the skill node.
     * @private
     * @param {SkillNode} node
     */
    addParentNode(node) {
      if (!this.parents) {
        this.parents = [];
      }
      this.parents.push(node);
    }
    /**
     * @param {SkillNode} node 
     */
    addChildNode(node) {
      if (!this.children) {
        this.children = [];
      }
      this.children.push(node);
      node.addParentNode(this);
    }
    /**
     * @override
     * @returns {boolean}
     */
    isAffordable() {
      return this.cost.lessThanEquals(this.totals.prestige);
    }
    /**
     * @override
     * @returns {boolean}
     */
    isPurchasable() {
      if (this.purchased) {
        return false;
      }
      if (!this.isAffordable()) {
        return false;
      }
      if (!this.parents || this.parents.length === 0) {
        return true;
      }
      return this.parentNodePurchased;
    }
    /**
     * @returns {boolean}
     */
    onPurchase() {
      if (this.purchased) {
        console.log("SkillNode.onPurchase() node already purchased");
        return false;
      }
      if (!this.isAffordable()) {
        console.log("SkillNode.onPurchase() not affordable");
        return false;
      }
      this.purchased = true;
      this.totals.decrementPrestige(this.cost);
      this.purchaseListener.onNodePurchased(this.cost);
      this.setChildrenParentNodePurchased();
      return true;
    }
    onPurchaseFromSave() {
      if (this.purchased) {
        console.log("SkillNode.onPurchaseFromSave() node already purchased");
        return false;
      }
      this.purchased = true;
      this.purchaseListener.onNodePurchasedFromSave();
      this.setChildrenParentNodePurchased();
    }
    onSaveLoad() {
      if (this.purchased) {
        this.setChildrenParentNodePurchased();
      }
    }
    /**
     * @private
     */
    setChildrenParentNodePurchased() {
      if (this.children) {
        for (let i = 0; i < this.children.length; i++) {
          this.children[i].parentNodePurchased = true;
        }
      }
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.parentNodePurchased = false;
      this.purchased = false;
    }
    /**
     * @override
     */
    resetForPrestige() {
    }
  };

  // src/model/skillTree/common/NumberValueSkillNode.js
  var NumberValueSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} title 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {SkillNodePurchaseListener} purchaseListener
     * @param {number} valuePerSkillLevel
     * @param {NumberValue} numberValue
     */
    constructor(id, title, description, totals, iconFileName, cost, purchaseListener, valuePerSkillLevel, numberValue) {
      super(id, title, description, totals, iconFileName, cost, purchaseListener);
      this.valuePerSkillLevel = valuePerSkillLevel;
      this.numberValue = numberValue;
    }
    /**
     * @override
     */
    onPurchase() {
      if (super.onPurchase()) {
        this.numberValue.incrementValue(this.valuePerSkillLevel);
        return true;
      } else {
        return false;
      }
    }
    /**
     * @override
     */
    onPurchaseFromSave() {
      this.numberValue.incrementValue(this.valuePerSkillLevel);
      super.onPurchaseFromSave();
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      super.resetFull();
      this.numberValue.reset();
    }
  };

  // src/model/skillTree/automation/UpgradeAutomationSkillNode.js
  var UpgradeAutomationSkillNode = class extends NumberValueSkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {NumberValue} automationRateUpgrades
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, automationRateUpgrades) {
      super(
        id,
        "Delay -" + Settings.automation.secondsPerRateUpgrade + " sec",
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener,
        1,
        automationRateUpgrades
      );
    }
    /**
     * @returns {string}
     */
    getDescription() {
      let delayTurns = Settings.automation.baseUpgradeDelayTurns;
      let discountTurns = Settings.automation.turnsPerRateUpgrade * this.numberValue.getValue();
      let turns = Math.max(Settings.automation.minDelayTurns, delayTurns - discountTurns);
      return "Current Delay: " + NumberFormatter.formatNumber(turns * Settings.time.secondsPerTurn) + "s";
    }
  };

  // src/model/skillTree/SkillIds.js
  var SkillIds = {
    MISSILE: "missile",
    LASER: "laser",
    DRILL: "drill",
    ORBIT: "orbit",
    FISSURE: "fissure",
    LIGHTNING: "lightning",
    CHAIN: "chain",
    DYNAMITE: "dynamite",
    ORE_BONUS: "oreBonus",
    UPGRADE_BONUS_MULTIPLICATIVE: "upgradeBonusMult",
    UPGRADE_BONUS_ADDITIVE: "upgradeBonusAdd",
    PRESTIGE_BONUS: "prestigeBonus",
    RUBY_BONUS: "rubyBonus",
    BLOCKS_BONUS: "blocksBonus",
    DEPTH_BONUS: "depthBonus",
    OFFLINE_BONUS: "offlineBonus",
    FALL_BONUS: "fallBonus",
    MINED_AUTOMATION: "minedAutomation",
    PICK_AUTOMATION: "pickAutomation",
    PRESTIGE_AUTOMATION: "prestigeAutomation"
  };

  // src/view/canvas/SkillRenderer.js
  var SkillRenderer = class {
    constructor() {
      this.screenCoordinate = new Vector(0, 0);
    }
    /**
     * @abstract
     * @param {CanvasRenderingContext2D} context 
     * @param {Projection} projection 
     */
    renderSkill(context, projection) {
    }
    /**
     * @param {CanvasRenderingContext2D} context 
     * @param {Projection} projection 
     * @param {Sprite} sprite
     * @param {Vector} canvasCoordinate The canvas coordinate.
     */
    renderSprite(context, projection, sprite, canvasCoordinate) {
      if (!sprite) {
        return;
      }
      const spriteSize = sprite.getSize();
      const scaledSize = Settings.tile.size * projection.zoom;
      context.drawImage(
        sprite.getImage(),
        sprite.spriteX,
        sprite.spriteY,
        // coords of sprite in sheet (top left corner)
        spriteSize,
        spriteSize,
        // width/height of sprite
        canvasCoordinate.x,
        canvasCoordinate.y,
        // canvas coords to render sprite (top left corner)
        scaledSize,
        scaledSize
      );
    }
  };

  // src/model/skillTree/SkillType.js
  var SkillType = class extends SkillNodePurchaseListener {
    /**
     * @abstract
     * @param {string} id
     */
    constructor(id) {
      super();
      this.id = id;
      this.rootNode = null;
      this.nodes = [];
      this.unlocked = false;
      this.durationUpgrades = new NumberValue(null, 0);
      this.coolDownUpgrades = new NumberValue(null, 0);
      this.pointsSpent = new BigNum(0);
    }
    /**
     * @param {SkillNode} node 
     * @returns {SkillNode}
     */
    addNode(node) {
      if (!this.rootNode) {
        this.rootNode = node;
      }
      this.nodes.push(node);
      return node;
    }
    /**
     * @returns {SkillNode}
     */
    getRootNode() {
      return this.rootNode;
    }
    /**
     * @returns {boolean}
     */
    isUnlocked() {
      return this.unlocked;
    }
    /**
     * @abstract
     * @returns {SkillRenderer}
     */
    getRenderer() {
      return null;
    }
    /**
     * @abstract
     * @param {PartyCharacter} miner
     * @param {number} frameTimeRatio 
     * @param {boolean} skillActive
     */
    updateSkillForFrame(miner, frameTimeRatio, skillActive) {
    }
    /**
     * @param {string} id 
     * @returns {SkillNode}
     */
    getSkillNodeById(id) {
      for (let i = 0; i < this.nodes.length; i++) {
        const skillNode = this.nodes[i];
        if (id === skillNode.id) {
          return skillNode;
        }
      }
      return null;
    }
    onSaveLoad() {
      for (let i = 0; i < this.nodes.length; i++) {
        this.nodes[i].onSaveLoad();
      }
    }
    ////////////////////////////////////
    // SkillNodePurchaseListener
    ////////////////////////////////////
    /**
     * Invoked by the skill node when it is purchased.
     * @param {BigNum} pointsSpent
     * @override
     */
    onNodePurchased(pointsSpent) {
      this.unlocked = true;
      this.pointsSpent.add(pointsSpent);
    }
    /**
     * @override
     */
    onNodePurchasedFromSave() {
      this.unlocked = true;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.unlocked = false;
      this.pointsSpent.setZero();
      for (let i = 0; i < this.nodes.length; i++) {
        this.nodes[i].resetFull();
      }
      this.coolDownUpgrades.reset();
      this.durationUpgrades.reset();
    }
    /**
     * @override
     */
    resetForPrestige() {
    }
  };

  // src/model/skillTree/common/UnlockSkillNode.js
  var UnlockSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} title 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {SkillNodePurchaseListener} purchaseListener
     */
    constructor(id, title, description, totals, iconFileName, cost, purchaseListener) {
      super(id, title, description, totals, iconFileName, cost, purchaseListener);
    }
  };

  // src/model/skillTree/automation/AutomationUnlockSkillNode.js
  var AutomationUnlockSkillNode = class extends UnlockSkillNode {
    /**
     * @param {string} id 
     * @param {string} title 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {SkillNodePurchaseListener} purchaseListener
     * @param {BooleanValue} unlockValue
     */
    constructor(id, title, description, totals, iconFileName, cost, purchaseListener, unlockValue) {
      super(id, title, description, totals, iconFileName, cost, purchaseListener);
      this.unlockValue = unlockValue;
    }
    /**
     * @override
     */
    onPurchase() {
      if (super.onPurchase()) {
        this.unlockValue.setValue(true);
        return true;
      } else {
        return false;
      }
    }
    /**
     * @override
     */
    onPurchaseFromSave() {
      super.onPurchaseFromSave();
      this.unlockValue.setValue(true);
    }
  };

  // src/model/skillTree/automation/MinedUpgradeAutomationSkill.js
  var MinedUpgradeAutomationSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     */
    constructor(totals, values) {
      super(SkillIds.MINED_AUTOMATION);
      this.values = values;
      const inc = 5;
      let cost = 5;
      const minedAutomationUnlock = this.addNode(new AutomationUnlockSkillNode(
        "minedAutomationUnlock",
        "Auto Claim",
        "Mined Upgrades",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationUnlocked
      ));
      cost += inc;
      const minedAutomationBonus1 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus1",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus2 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus2",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus3 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus3",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus4 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus4",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus5 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus5",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus6 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus6",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus7 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus7",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus8 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus8",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus9 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus9",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus10 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus10",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus11 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus11",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      cost += inc;
      const minedAutomationBonus12 = this.addNode(new UpgradeAutomationSkillNode(
        "minedAutomationBonus12",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.minedAutomationRateUpgrades
      ));
      minedAutomationUnlock.addChildNode(minedAutomationBonus1);
      minedAutomationBonus1.addChildNode(minedAutomationBonus2);
      minedAutomationBonus2.addChildNode(minedAutomationBonus3);
      minedAutomationBonus3.addChildNode(minedAutomationBonus4);
      minedAutomationBonus4.addChildNode(minedAutomationBonus5);
      minedAutomationBonus5.addChildNode(minedAutomationBonus6);
      minedAutomationBonus6.addChildNode(minedAutomationBonus7);
      minedAutomationBonus7.addChildNode(minedAutomationBonus8);
      minedAutomationBonus8.addChildNode(minedAutomationBonus9);
      minedAutomationBonus9.addChildNode(minedAutomationBonus10);
      minedAutomationBonus10.addChildNode(minedAutomationBonus11);
      minedAutomationBonus11.addChildNode(minedAutomationBonus12);
      const startX = -1;
      const startY = 5;
      minedAutomationUnlock.setPosition(startX, startY);
      minedAutomationBonus1.setPosition(startX - 1, startY);
      minedAutomationBonus2.setPosition(startX - 2, startY);
      minedAutomationBonus3.setPosition(startX - 3, startY);
      minedAutomationBonus4.setPosition(startX - 4, startY);
      minedAutomationBonus5.setPosition(startX - 5, startY);
      minedAutomationBonus6.setPosition(startX - 6, startY);
      minedAutomationBonus7.setPosition(startX - 6, startY - 1);
      minedAutomationBonus8.setPosition(startX - 5, startY - 1);
      minedAutomationBonus9.setPosition(startX - 4, startY - 1);
      minedAutomationBonus10.setPosition(startX - 3, startY - 1);
      minedAutomationBonus11.setPosition(startX - 2, startY - 1);
      minedAutomationBonus12.setPosition(startX - 1, startY - 1);
    }
  };

  // src/model/skillTree/automation/PickUpgradeAutomationSkill.js
  var PickUpgradeAutomationSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     */
    constructor(totals, values) {
      super(SkillIds.PICK_AUTOMATION);
      this.values = values;
      const inc = 5;
      let cost = 5;
      const pickAutomationUnlock = this.addNode(new AutomationUnlockSkillNode(
        "pickAutomationUnlock",
        "Auto Purchase",
        "Ore Upgrades",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationUnlocked
      ));
      cost += inc;
      const pickAutomationBonus1 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus1",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus2 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus2",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus3 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus3",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus4 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus4",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus5 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus5",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus6 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus6",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus7 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus7",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus8 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus8",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus9 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus9",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus10 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus10",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus11 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus11",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      cost += inc;
      const pickAutomationBonus12 = this.addNode(new UpgradeAutomationSkillNode(
        "pickAutomationBonus12",
        totals,
        Images.pick,
        new BigNum(cost),
        this,
        this.values.pickAutomationRateUpgrades
      ));
      pickAutomationUnlock.addChildNode(pickAutomationBonus1);
      pickAutomationBonus1.addChildNode(pickAutomationBonus2);
      pickAutomationBonus2.addChildNode(pickAutomationBonus3);
      pickAutomationBonus3.addChildNode(pickAutomationBonus4);
      pickAutomationBonus4.addChildNode(pickAutomationBonus5);
      pickAutomationBonus5.addChildNode(pickAutomationBonus6);
      pickAutomationBonus6.addChildNode(pickAutomationBonus7);
      pickAutomationBonus7.addChildNode(pickAutomationBonus8);
      pickAutomationBonus8.addChildNode(pickAutomationBonus9);
      pickAutomationBonus9.addChildNode(pickAutomationBonus10);
      pickAutomationBonus10.addChildNode(pickAutomationBonus11);
      pickAutomationBonus11.addChildNode(pickAutomationBonus12);
      const startX = -1;
      const startY = 8;
      pickAutomationUnlock.setPosition(startX, startY);
      pickAutomationBonus1.setPosition(startX - 1, startY);
      pickAutomationBonus2.setPosition(startX - 2, startY);
      pickAutomationBonus3.setPosition(startX - 3, startY);
      pickAutomationBonus4.setPosition(startX - 4, startY);
      pickAutomationBonus5.setPosition(startX - 5, startY);
      pickAutomationBonus6.setPosition(startX - 6, startY);
      pickAutomationBonus7.setPosition(startX - 6, startY - 1);
      pickAutomationBonus8.setPosition(startX - 5, startY - 1);
      pickAutomationBonus9.setPosition(startX - 4, startY - 1);
      pickAutomationBonus10.setPosition(startX - 3, startY - 1);
      pickAutomationBonus11.setPosition(startX - 2, startY - 1);
      pickAutomationBonus12.setPosition(startX - 1, startY - 1);
    }
  };

  // src/model/skillTree/automation/UpgradePrestigeAutomationSkillNode.js
  var UpgradePrestigeAutomationSkillNode = class extends NumberValueSkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {NumberValue} automationRateUpgrades
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, automationRateUpgrades) {
      super(
        id,
        "Delay -" + Settings.automation.minutesPerPrestigeRateUpgrade + " min",
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener,
        1,
        automationRateUpgrades
      );
    }
    /**
     * @returns {string}
     */
    getDescription() {
      let delayTurns = Settings.automation.prestigeUpgradeDelayTurns;
      let discountTurns = Settings.automation.prestigeTurnsPerRateUpgrade * this.numberValue.getValue();
      let turns = Math.max(Settings.automation.minDelayTurns, delayTurns - discountTurns);
      return "Current Delay: " + NumberFormatter.formatNumber(turns * Settings.time.secondsPerTurn / 60) + "m";
    }
  };

  // src/model/skillTree/automation/PrestigeAutomationSkill.js
  var PrestigeAutomationSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     */
    constructor(totals, values) {
      super(SkillIds.PRESTIGE_AUTOMATION);
      this.values = values;
      const inc = 5;
      let cost = 10;
      const prestigeAutomationUnlock = this.addNode(new AutomationUnlockSkillNode(
        "prestigeAutomationUnlock",
        "Auto Prestige",
        "Earn Prestige",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationUnlocked
      ));
      cost += inc;
      const prestigeAutomationBonus1 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus1",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus2 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus2",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus3 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus3",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus4 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus4",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus5 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus5",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus6 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus6",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus7 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus7",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus8 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus8",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus9 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus9",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus10 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus10",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus11 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus11",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      cost += inc;
      const prestigeAutomationBonus12 = this.addNode(new UpgradePrestigeAutomationSkillNode(
        "prestigeAutomationBonus12",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values.prestigeAutomationRateUpgrades
      ));
      prestigeAutomationUnlock.addChildNode(prestigeAutomationBonus1);
      prestigeAutomationBonus1.addChildNode(prestigeAutomationBonus2);
      prestigeAutomationBonus2.addChildNode(prestigeAutomationBonus3);
      prestigeAutomationBonus3.addChildNode(prestigeAutomationBonus4);
      prestigeAutomationBonus4.addChildNode(prestigeAutomationBonus5);
      prestigeAutomationBonus5.addChildNode(prestigeAutomationBonus6);
      prestigeAutomationBonus6.addChildNode(prestigeAutomationBonus7);
      prestigeAutomationBonus7.addChildNode(prestigeAutomationBonus8);
      prestigeAutomationBonus8.addChildNode(prestigeAutomationBonus9);
      prestigeAutomationBonus9.addChildNode(prestigeAutomationBonus10);
      prestigeAutomationBonus10.addChildNode(prestigeAutomationBonus11);
      prestigeAutomationBonus11.addChildNode(prestigeAutomationBonus12);
      const startX = -1;
      const startY = 11;
      prestigeAutomationUnlock.setPosition(startX, startY);
      prestigeAutomationBonus1.setPosition(startX - 1, startY);
      prestigeAutomationBonus2.setPosition(startX - 2, startY);
      prestigeAutomationBonus3.setPosition(startX - 3, startY);
      prestigeAutomationBonus4.setPosition(startX - 4, startY);
      prestigeAutomationBonus5.setPosition(startX - 5, startY);
      prestigeAutomationBonus6.setPosition(startX - 6, startY);
      prestigeAutomationBonus7.setPosition(startX - 6, startY - 1);
      prestigeAutomationBonus8.setPosition(startX - 5, startY - 1);
      prestigeAutomationBonus9.setPosition(startX - 4, startY - 1);
      prestigeAutomationBonus10.setPosition(startX - 3, startY - 1);
      prestigeAutomationBonus11.setPosition(startX - 2, startY - 1);
      prestigeAutomationBonus12.setPosition(startX - 1, startY - 1);
    }
  };

  // src/model/skillTree/bonus/DepthBonusSkillNode.js
  var DepthBonusSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     * @param {number} purchaseIndex Starts at 0
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, values, mineDamageLogic, purchaseIndex) {
      super(
        id,
        "Depth Damage +" + NumberFormatter.formatNumber(Settings.depth.baseBonusPerUpgrade + Settings.depth.incrementBonusPerUpgrade * purchaseIndex),
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener
      );
      this.values = values;
      this.mineDamageLogic = mineDamageLogic;
      this.purchaseIndex = purchaseIndex;
    }
    /**
     * @returns {string}
     */
    getDescription() {
      const bonusMultiplier = this.values.skillDepthBonusMultiplier.getValue();
      if (bonusMultiplier === 0) {
        return "Damage / Max Depth: 0";
      } else {
        return "Damage / Max Depth: x" + NumberFormatter.formatNumber(bonusMultiplier);
      }
    }
    /**
     * @override
     */
    onPurchase() {
      if (super.onPurchase()) {
        this.applyUpgrade();
        this.mineDamageLogic.calculateTotalMineDamagePerTurn();
        return true;
      } else {
        return false;
      }
    }
    /**
     * @override
     */
    onPurchaseFromSave() {
      this.applyUpgrade();
      super.onPurchaseFromSave();
    }
    /**
     * @private
     */
    applyUpgrade() {
      const bonus = Settings.depth.baseBonusPerUpgrade + Settings.depth.incrementBonusPerUpgrade * this.purchaseIndex;
      this.values.skillDepthBonusMultiplier.incrementValue(bonus);
    }
  };

  // src/model/skillTree/bonus/DepthBonusSkill.js
  var DepthBonusSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     */
    constructor(totals, values, mineDamageLogic) {
      super(SkillIds.DEPTH_BONUS);
      this.values = values;
      const inc = 20;
      let cost = 20;
      let purchaseIndex = 0;
      const depthBonus1 = this.addNode(new DepthBonusSkillNode(
        "depthBonus1",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus2 = this.addNode(new DepthBonusSkillNode(
        "depthBonus2",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus3 = this.addNode(new DepthBonusSkillNode(
        "depthBonus3",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus4 = this.addNode(new DepthBonusSkillNode(
        "depthBonus4",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus5 = this.addNode(new DepthBonusSkillNode(
        "depthBonus5",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus6 = this.addNode(new DepthBonusSkillNode(
        "depthBonus6",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus7 = this.addNode(new DepthBonusSkillNode(
        "depthBonus7",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus8 = this.addNode(new DepthBonusSkillNode(
        "depthBonus8",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus9 = this.addNode(new DepthBonusSkillNode(
        "depthBonus9",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus10 = this.addNode(new DepthBonusSkillNode(
        "depthBonus10",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus11 = this.addNode(new DepthBonusSkillNode(
        "depthBonus11",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus12 = this.addNode(new DepthBonusSkillNode(
        "depthBonus12",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus13 = this.addNode(new DepthBonusSkillNode(
        "depthBonus13",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus14 = this.addNode(new DepthBonusSkillNode(
        "depthBonus14",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus15 = this.addNode(new DepthBonusSkillNode(
        "depthBonus15",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus16 = this.addNode(new DepthBonusSkillNode(
        "depthBonus16",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus17 = this.addNode(new DepthBonusSkillNode(
        "depthBonus17",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus18 = this.addNode(new DepthBonusSkillNode(
        "depthBonus18",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus19 = this.addNode(new DepthBonusSkillNode(
        "depthBonus19",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus20 = this.addNode(new DepthBonusSkillNode(
        "depthBonus20",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const depthBonus21 = this.addNode(new DepthBonusSkillNode(
        "depthBonus21",
        totals,
        Images.currency.depth,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      depthBonus1.addChildNode(depthBonus2);
      depthBonus2.addChildNode(depthBonus3);
      depthBonus3.addChildNode(depthBonus4);
      depthBonus4.addChildNode(depthBonus5);
      depthBonus5.addChildNode(depthBonus6);
      depthBonus6.addChildNode(depthBonus7);
      depthBonus7.addChildNode(depthBonus8);
      depthBonus8.addChildNode(depthBonus9);
      depthBonus9.addChildNode(depthBonus10);
      depthBonus10.addChildNode(depthBonus11);
      depthBonus11.addChildNode(depthBonus12);
      depthBonus12.addChildNode(depthBonus13);
      depthBonus13.addChildNode(depthBonus14);
      depthBonus14.addChildNode(depthBonus15);
      depthBonus15.addChildNode(depthBonus16);
      depthBonus16.addChildNode(depthBonus17);
      depthBonus17.addChildNode(depthBonus18);
      depthBonus18.addChildNode(depthBonus19);
      depthBonus19.addChildNode(depthBonus20);
      depthBonus20.addChildNode(depthBonus21);
      const startX = 4;
      const startY = -7;
      depthBonus1.setPosition(startX, startY);
      depthBonus2.setPosition(startX + 1, startY);
      depthBonus3.setPosition(startX + 2, startY);
      depthBonus4.setPosition(startX + 3, startY);
      depthBonus5.setPosition(startX + 4, startY);
      depthBonus6.setPosition(startX + 5, startY);
      depthBonus7.setPosition(startX + 6, startY);
      depthBonus8.setPosition(startX + 6, startY - 1);
      depthBonus9.setPosition(startX + 5, startY - 1);
      depthBonus10.setPosition(startX + 4, startY - 1);
      depthBonus11.setPosition(startX + 3, startY - 1);
      depthBonus12.setPosition(startX + 2, startY - 1);
      depthBonus13.setPosition(startX + 1, startY - 1);
      depthBonus14.setPosition(startX, startY - 1);
      depthBonus15.setPosition(startX, startY - 2);
      depthBonus16.setPosition(startX + 1, startY - 2);
      depthBonus17.setPosition(startX + 2, startY - 2);
      depthBonus18.setPosition(startX + 3, startY - 2);
      depthBonus19.setPosition(startX + 4, startY - 2);
      depthBonus20.setPosition(startX + 5, startY - 2);
      depthBonus21.setPosition(startX + 6, startY - 2);
    }
  };

  // src/util/TimeFormatter.js
  var millisPerHour = 1e3 * 60 * 60;
  var TimeFormatter = class {
    constructor() {
    }
    /**
     * @param {number} milliseconds
     * @returns {string}
     */
    static formatElapsedTime(milliseconds) {
      if (milliseconds < 0) {
        return "Error: negative time";
      }
      const hours = milliseconds / millisPerHour | 0, minutes = milliseconds / 6e4 % 60 | 0, seconds = milliseconds / 1e3 % 60 | 0;
      return (hours < 10 ? "0" : "") + hours + ":" + (minutes < 10 ? "0" : "") + minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
    }
    /**
     * @param {number} milliseconds
     * @returns {string}
     */
    static formatElapsedTimeNoHours(milliseconds) {
      if (milliseconds < 0) {
        return "Error: negative time";
      }
      const hours = milliseconds / millisPerHour | 0, minutes = milliseconds / 6e4 % 60 | 0, seconds = milliseconds / 1e3 % 60 | 0;
      if (hours > 0) {
        return (hours < 10 ? "0" : "") + hours + ":" + (minutes < 10 ? "0" : "") + minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
      } else {
        return (minutes < 10 ? "0" : "") + minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
      }
    }
  };

  // src/model/skillTree/bonus/OfflineBonusSkillNode.js
  var OfflineBonusSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {Values} values
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, values) {
      super(
        id,
        "Offline +" + Settings.offline.minutesPerUpgrade + " min",
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener
      );
      this.values = values;
    }
    /**
     * @returns {string}
     */
    getDescription() {
      const minutes = Settings.offline.defaultOfflineMinutes + this.values.offlineTimeUpgrades.getValue() * Settings.offline.minutesPerUpgrade;
      const millis = minutes * 60 * 1e3;
      return "Offline Time: " + TimeFormatter.formatElapsedTime(millis);
    }
    /**
     * @override
     */
    onPurchase() {
      if (super.onPurchase()) {
        this.applyUpgrade();
        return true;
      } else {
        return false;
      }
    }
    /**
     * @override
     */
    onPurchaseFromSave() {
      this.applyUpgrade();
      super.onPurchaseFromSave();
    }
    /**
     * @private
     */
    applyUpgrade() {
      this.values.offlineTimeUpgrades.incrementValue(1);
    }
  };

  // src/model/skillTree/bonus/OfflineBonusSkill.js
  var OfflineBonusSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     */
    constructor(totals, values) {
      super(SkillIds.OFFLINE_BONUS);
      this.values = values;
      const inc = 10;
      let cost = 10;
      const offlineBonus1 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus1",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus2 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus2",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus3 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus3",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus4 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus4",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus5 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus5",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus6 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus6",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus7 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus7",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus8 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus8",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus9 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus9",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus10 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus10",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus11 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus11",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus12 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus12",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus13 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus13",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus14 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus14",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus15 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus15",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus16 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus16",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus17 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus17",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus18 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus18",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus19 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus19",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus20 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus20",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const offlineBonus21 = this.addNode(new OfflineBonusSkillNode(
        "offlineBonus21",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      offlineBonus1.addChildNode(offlineBonus2);
      offlineBonus2.addChildNode(offlineBonus3);
      offlineBonus3.addChildNode(offlineBonus4);
      offlineBonus4.addChildNode(offlineBonus5);
      offlineBonus5.addChildNode(offlineBonus6);
      offlineBonus6.addChildNode(offlineBonus7);
      offlineBonus7.addChildNode(offlineBonus8);
      offlineBonus8.addChildNode(offlineBonus9);
      offlineBonus9.addChildNode(offlineBonus10);
      offlineBonus10.addChildNode(offlineBonus11);
      offlineBonus11.addChildNode(offlineBonus12);
      offlineBonus12.addChildNode(offlineBonus13);
      offlineBonus13.addChildNode(offlineBonus14);
      offlineBonus14.addChildNode(offlineBonus15);
      offlineBonus15.addChildNode(offlineBonus16);
      offlineBonus16.addChildNode(offlineBonus17);
      offlineBonus17.addChildNode(offlineBonus18);
      offlineBonus18.addChildNode(offlineBonus19);
      offlineBonus19.addChildNode(offlineBonus20);
      offlineBonus20.addChildNode(offlineBonus21);
      const startX = 4;
      const startY = -11;
      offlineBonus1.setPosition(startX, startY);
      offlineBonus2.setPosition(startX + 1, startY);
      offlineBonus3.setPosition(startX + 2, startY);
      offlineBonus4.setPosition(startX + 3, startY);
      offlineBonus5.setPosition(startX + 4, startY);
      offlineBonus6.setPosition(startX + 5, startY);
      offlineBonus7.setPosition(startX + 6, startY);
      offlineBonus8.setPosition(startX + 6, startY - 1);
      offlineBonus9.setPosition(startX + 5, startY - 1);
      offlineBonus10.setPosition(startX + 4, startY - 1);
      offlineBonus11.setPosition(startX + 3, startY - 1);
      offlineBonus12.setPosition(startX + 2, startY - 1);
      offlineBonus13.setPosition(startX + 1, startY - 1);
      offlineBonus14.setPosition(startX, startY - 1);
      offlineBonus15.setPosition(startX, startY - 2);
      offlineBonus16.setPosition(startX + 1, startY - 2);
      offlineBonus17.setPosition(startX + 2, startY - 2);
      offlineBonus18.setPosition(startX + 3, startY - 2);
      offlineBonus19.setPosition(startX + 4, startY - 2);
      offlineBonus20.setPosition(startX + 5, startY - 2);
      offlineBonus21.setPosition(startX + 6, startY - 2);
    }
  };

  // src/model/skillTree/bonus/OreBonusSkillNode.js
  var OreBonusSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {Values} values
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, values) {
      super(
        id,
        "Ore x" + Settings.skill.bonus.oreBonusMultiplierPerUpgrade,
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener
      );
      this.values = values;
    }
    /**
     * @returns {string}
     */
    getDescription() {
      return "Bonus: x" + NumberFormatter.formatBigNum(this.values.skillOreBonusMultiplier.getValue());
    }
    /**
     * @override
     */
    onPurchase() {
      if (super.onPurchase()) {
        this.applyMultipliers();
        return true;
      } else {
        return false;
      }
    }
    /**
     * @override
     */
    onPurchaseFromSave() {
      this.applyMultipliers();
      super.onPurchaseFromSave();
    }
    /**
     * @private
     */
    applyMultipliers() {
      const val = this.values.skillOreBonusMultiplier.getValue();
      if (val.lessThanEqualsNumber(1)) {
        val.setValue(1);
      }
      val.mulNumber(Settings.skill.bonus.oreBonusMultiplierPerUpgrade);
    }
  };

  // src/model/skillTree/bonus/OreBonusSkill.js
  var OreBonusSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     */
    constructor(totals, values) {
      super(SkillIds.ORE_BONUS);
      this.values = values;
      const inc = 5;
      let cost = 5;
      const oreBonus1 = this.addNode(new OreBonusSkillNode(
        "oreBonus1",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus2 = this.addNode(new OreBonusSkillNode(
        "oreBonus2",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus3 = this.addNode(new OreBonusSkillNode(
        "oreBonus3",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus4 = this.addNode(new OreBonusSkillNode(
        "oreBonus4",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus5 = this.addNode(new OreBonusSkillNode(
        "oreBonus5",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus6 = this.addNode(new OreBonusSkillNode(
        "oreBonus6",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus7 = this.addNode(new OreBonusSkillNode(
        "oreBonus7",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus8 = this.addNode(new OreBonusSkillNode(
        "oreBonus8",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus9 = this.addNode(new OreBonusSkillNode(
        "oreBonus9",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus10 = this.addNode(new OreBonusSkillNode(
        "oreBonus10",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus11 = this.addNode(new OreBonusSkillNode(
        "oreBonus11",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus12 = this.addNode(new OreBonusSkillNode(
        "oreBonus12",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus13 = this.addNode(new OreBonusSkillNode(
        "oreBonus13",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus14 = this.addNode(new OreBonusSkillNode(
        "oreBonus14",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus15 = this.addNode(new OreBonusSkillNode(
        "oreBonus15",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus16 = this.addNode(new OreBonusSkillNode(
        "oreBonus16",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus17 = this.addNode(new OreBonusSkillNode(
        "oreBonus17",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus18 = this.addNode(new OreBonusSkillNode(
        "oreBonus18",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus19 = this.addNode(new OreBonusSkillNode(
        "oreBonus19",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus20 = this.addNode(new OreBonusSkillNode(
        "oreBonus20",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus21 = this.addNode(new OreBonusSkillNode(
        "oreBonus21",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus22 = this.addNode(new OreBonusSkillNode(
        "oreBonus22",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus23 = this.addNode(new OreBonusSkillNode(
        "oreBonus23",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus24 = this.addNode(new OreBonusSkillNode(
        "oreBonus24",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus25 = this.addNode(new OreBonusSkillNode(
        "oreBonus25",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus26 = this.addNode(new OreBonusSkillNode(
        "oreBonus26",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus27 = this.addNode(new OreBonusSkillNode(
        "oreBonus27",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const oreBonus28 = this.addNode(new OreBonusSkillNode(
        "oreBonus28",
        totals,
        Images.currency.ore,
        new BigNum(cost),
        this,
        this.values
      ));
      oreBonus1.addChildNode(oreBonus2);
      oreBonus2.addChildNode(oreBonus3);
      oreBonus3.addChildNode(oreBonus4);
      oreBonus4.addChildNode(oreBonus5);
      oreBonus5.addChildNode(oreBonus6);
      oreBonus6.addChildNode(oreBonus7);
      oreBonus7.addChildNode(oreBonus8);
      oreBonus8.addChildNode(oreBonus9);
      oreBonus9.addChildNode(oreBonus10);
      oreBonus10.addChildNode(oreBonus11);
      oreBonus11.addChildNode(oreBonus12);
      oreBonus12.addChildNode(oreBonus13);
      oreBonus13.addChildNode(oreBonus14);
      oreBonus14.addChildNode(oreBonus15);
      oreBonus15.addChildNode(oreBonus16);
      oreBonus16.addChildNode(oreBonus17);
      oreBonus17.addChildNode(oreBonus18);
      oreBonus18.addChildNode(oreBonus19);
      oreBonus19.addChildNode(oreBonus20);
      oreBonus20.addChildNode(oreBonus21);
      oreBonus21.addChildNode(oreBonus22);
      oreBonus22.addChildNode(oreBonus23);
      oreBonus23.addChildNode(oreBonus24);
      oreBonus24.addChildNode(oreBonus25);
      oreBonus25.addChildNode(oreBonus26);
      oreBonus26.addChildNode(oreBonus27);
      oreBonus27.addChildNode(oreBonus28);
      const startX = -1;
      const startY = 2;
      oreBonus1.setPosition(startX, startY);
      oreBonus2.setPosition(startX - 1, startY);
      oreBonus3.setPosition(startX - 2, startY);
      oreBonus4.setPosition(startX - 3, startY);
      oreBonus5.setPosition(startX - 4, startY);
      oreBonus6.setPosition(startX - 5, startY);
      oreBonus7.setPosition(startX - 6, startY);
      oreBonus8.setPosition(startX - 6, startY - 1);
      oreBonus9.setPosition(startX - 5, startY - 1);
      oreBonus10.setPosition(startX - 4, startY - 1);
      oreBonus11.setPosition(startX - 3, startY - 1);
      oreBonus12.setPosition(startX - 2, startY - 1);
      oreBonus13.setPosition(startX - 1, startY - 1);
      oreBonus14.setPosition(startX, startY - 1);
      oreBonus15.setPosition(startX, startY - 2);
      oreBonus16.setPosition(startX - 1, startY - 2);
      oreBonus17.setPosition(startX - 2, startY - 2);
      oreBonus18.setPosition(startX - 3, startY - 2);
      oreBonus19.setPosition(startX - 4, startY - 2);
      oreBonus20.setPosition(startX - 5, startY - 2);
      oreBonus21.setPosition(startX - 6, startY - 2);
      oreBonus22.setPosition(startX - 6, startY - 3);
      oreBonus23.setPosition(startX - 5, startY - 3);
      oreBonus24.setPosition(startX - 4, startY - 3);
      oreBonus25.setPosition(startX - 3, startY - 3);
      oreBonus26.setPosition(startX - 2, startY - 3);
      oreBonus27.setPosition(startX - 1, startY - 3);
      oreBonus28.setPosition(startX, startY - 3);
    }
  };

  // src/model/skillTree/bonus/PrestigeBonusSkillNode.js
  var PrestigeBonusSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     * @param {number} purchaseIndex Starts at 0
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, values, mineDamageLogic, purchaseIndex) {
      super(
        id,
        "Prestige +" + NumberFormatter.formatNumber(Settings.prestige.baseBonusPerUpgrade + Settings.prestige.incrementBonusPerUpgrade * purchaseIndex),
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener
      );
      this.values = values;
      this.mineDamageLogic = mineDamageLogic;
      this.purchaseIndex = purchaseIndex;
    }
    // 
    /**
     * @returns {string}
     */
    getDescription() {
      const bonus = this.values.skillPrestigeBonusMultiplier.getValue() + Settings.prestige.multiplierPerPrestige;
      return "Damage / Prestige: x" + NumberFormatter.formatNumber(bonus);
    }
    /**
     * @override
     */
    onPurchase() {
      if (super.onPurchase()) {
        this.applyUpgrade();
        this.mineDamageLogic.calculateTotalMineDamagePerTurn();
        return true;
      } else {
        return false;
      }
    }
    /**
     * @override
     */
    onPurchaseFromSave() {
      this.applyUpgrade();
      super.onPurchaseFromSave();
    }
    /**
     * @private
     */
    applyUpgrade() {
      const bonus = Settings.prestige.baseBonusPerUpgrade + Settings.prestige.incrementBonusPerUpgrade * this.purchaseIndex;
      this.values.skillPrestigeBonusMultiplier.incrementValue(bonus);
    }
  };

  // src/model/skillTree/bonus/PrestigeBonusSkill.js
  var PrestigeBonusSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     */
    constructor(totals, values, mineDamageLogic) {
      super(SkillIds.PRESTIGE_BONUS);
      this.values = values;
      const inc = 10;
      let cost = 10;
      let purchaseIndex = 0;
      const prestigeBonus1 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus1",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus2 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus2",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus3 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus3",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus4 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus4",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus5 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus5",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus6 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus6",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus7 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus7",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus8 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus8",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus9 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus9",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus10 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus10",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus11 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus11",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus12 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus12",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus13 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus13",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus14 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus14",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus15 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus15",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus16 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus16",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus17 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus17",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus18 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus18",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus19 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus19",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus20 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus20",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const prestigeBonus21 = this.addNode(new PrestigeBonusSkillNode(
        "prestigeBonus21",
        totals,
        Images.currency.prestige,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      prestigeBonus1.addChildNode(prestigeBonus2);
      prestigeBonus2.addChildNode(prestigeBonus3);
      prestigeBonus3.addChildNode(prestigeBonus4);
      prestigeBonus4.addChildNode(prestigeBonus5);
      prestigeBonus5.addChildNode(prestigeBonus6);
      prestigeBonus6.addChildNode(prestigeBonus7);
      prestigeBonus7.addChildNode(prestigeBonus8);
      prestigeBonus8.addChildNode(prestigeBonus9);
      prestigeBonus9.addChildNode(prestigeBonus10);
      prestigeBonus10.addChildNode(prestigeBonus11);
      prestigeBonus11.addChildNode(prestigeBonus12);
      prestigeBonus12.addChildNode(prestigeBonus13);
      prestigeBonus13.addChildNode(prestigeBonus14);
      prestigeBonus14.addChildNode(prestigeBonus15);
      prestigeBonus15.addChildNode(prestigeBonus16);
      prestigeBonus16.addChildNode(prestigeBonus17);
      prestigeBonus17.addChildNode(prestigeBonus18);
      prestigeBonus18.addChildNode(prestigeBonus19);
      prestigeBonus19.addChildNode(prestigeBonus20);
      prestigeBonus20.addChildNode(prestigeBonus21);
      const startX = -1;
      const startY = -3;
      prestigeBonus1.setPosition(startX, startY);
      prestigeBonus2.setPosition(startX - 1, startY);
      prestigeBonus3.setPosition(startX - 2, startY);
      prestigeBonus4.setPosition(startX - 3, startY);
      prestigeBonus5.setPosition(startX - 4, startY);
      prestigeBonus6.setPosition(startX - 5, startY);
      prestigeBonus7.setPosition(startX - 6, startY);
      prestigeBonus8.setPosition(startX - 6, startY - 1);
      prestigeBonus9.setPosition(startX - 5, startY - 1);
      prestigeBonus10.setPosition(startX - 4, startY - 1);
      prestigeBonus11.setPosition(startX - 3, startY - 1);
      prestigeBonus12.setPosition(startX - 2, startY - 1);
      prestigeBonus13.setPosition(startX - 1, startY - 1);
      prestigeBonus14.setPosition(startX, startY - 1);
      prestigeBonus15.setPosition(startX, startY - 2);
      prestigeBonus16.setPosition(startX - 1, startY - 2);
      prestigeBonus17.setPosition(startX - 2, startY - 2);
      prestigeBonus18.setPosition(startX - 3, startY - 2);
      prestigeBonus19.setPosition(startX - 4, startY - 2);
      prestigeBonus20.setPosition(startX - 5, startY - 2);
      prestigeBonus21.setPosition(startX - 6, startY - 2);
    }
  };

  // src/model/skillTree/bonus/MinedDamageBonusSkillNode.js
  var MinedDamageBonusSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {Values} values
     * @param {number} purchaseIndex Starts at 0
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, values, purchaseIndex) {
      super(
        id,
        "Mined Damage +" + NumberFormatter.formatNumber(Settings.minedDamage.baseBonusPerUpgrade + Settings.minedDamage.incrementBonusPerUpgrade * purchaseIndex),
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener
      );
      this.values = values;
      this.purchaseIndex = purchaseIndex;
    }
    /**
     * @returns {string}
     */
    getDescription() {
      const bonus = this.values.skillMinedDamageBonus.getValue();
      return "Bonus: +" + NumberFormatter.formatNumber(bonus);
    }
    /**
     * @override
     */
    onPurchase() {
      if (super.onPurchase()) {
        this.applyUpgrade();
        return true;
      } else {
        return false;
      }
    }
    /**
     * @override
     */
    onPurchaseFromSave() {
      this.applyUpgrade();
      super.onPurchaseFromSave();
    }
    /**
     * @private
     */
    applyUpgrade() {
      const bonus = Settings.minedDamage.baseBonusPerUpgrade + Settings.minedDamage.incrementBonusPerUpgrade * this.purchaseIndex;
      this.values.skillMinedDamageBonus.incrementValue(bonus);
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      super.resetFull();
      this.values.skillMinedDamageBonus.reset();
    }
  };

  // src/model/skillTree/bonus/MinedDamageBonusSkill.js
  var MinedDamageBonusSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     */
    constructor(totals, values) {
      super(SkillIds.UPGRADE_BONUS_MULTIPLICATIVE);
      this.values = values;
      const inc = 5;
      let cost = 5;
      let purchaseIndex = 0;
      const bonus1 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult1",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus2 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult2",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus3 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult3",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus4 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult4",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus5 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult5",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus6 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult6",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus7 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult7",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus8 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult8",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus9 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult9",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus10 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult10",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus11 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult11",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus12 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult12",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus13 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult13",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus14 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult14",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus15 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult15",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus16 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult16",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus17 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult17",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus18 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult18",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus19 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult19",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus20 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult20",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus21 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult21",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus22 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult22",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus23 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult23",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus24 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult24",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus25 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult25",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus26 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult26",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus27 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult27",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const bonus28 = this.addNode(new MinedDamageBonusSkillNode(
        "upgradeBonusMult28",
        totals,
        Images.currency.upgrades,
        new BigNum(cost),
        this,
        this.values,
        purchaseIndex
      ));
      bonus1.addChildNode(bonus2);
      bonus2.addChildNode(bonus3);
      bonus3.addChildNode(bonus4);
      bonus4.addChildNode(bonus5);
      bonus5.addChildNode(bonus6);
      bonus6.addChildNode(bonus7);
      bonus7.addChildNode(bonus8);
      bonus8.addChildNode(bonus9);
      bonus9.addChildNode(bonus10);
      bonus10.addChildNode(bonus11);
      bonus11.addChildNode(bonus12);
      bonus12.addChildNode(bonus13);
      bonus13.addChildNode(bonus14);
      bonus14.addChildNode(bonus15);
      bonus15.addChildNode(bonus16);
      bonus16.addChildNode(bonus17);
      bonus17.addChildNode(bonus18);
      bonus18.addChildNode(bonus19);
      bonus19.addChildNode(bonus20);
      bonus20.addChildNode(bonus21);
      bonus21.addChildNode(bonus22);
      bonus22.addChildNode(bonus23);
      bonus23.addChildNode(bonus24);
      bonus24.addChildNode(bonus25);
      bonus25.addChildNode(bonus26);
      bonus26.addChildNode(bonus27);
      bonus27.addChildNode(bonus28);
      const startX = -1;
      const startY = -7;
      bonus1.setPosition(startX, startY);
      bonus2.setPosition(startX - 1, startY);
      bonus3.setPosition(startX - 2, startY);
      bonus4.setPosition(startX - 3, startY);
      bonus5.setPosition(startX - 4, startY);
      bonus6.setPosition(startX - 5, startY);
      bonus7.setPosition(startX - 6, startY);
      bonus8.setPosition(startX - 6, startY - 1);
      bonus9.setPosition(startX - 5, startY - 1);
      bonus10.setPosition(startX - 4, startY - 1);
      bonus11.setPosition(startX - 3, startY - 1);
      bonus12.setPosition(startX - 2, startY - 1);
      bonus13.setPosition(startX - 1, startY - 1);
      bonus14.setPosition(startX, startY - 1);
      bonus15.setPosition(startX, startY - 2);
      bonus16.setPosition(startX - 1, startY - 2);
      bonus17.setPosition(startX - 2, startY - 2);
      bonus18.setPosition(startX - 3, startY - 2);
      bonus19.setPosition(startX - 4, startY - 2);
      bonus20.setPosition(startX - 5, startY - 2);
      bonus21.setPosition(startX - 6, startY - 2);
      bonus22.setPosition(startX - 6, startY - 3);
      bonus23.setPosition(startX - 5, startY - 3);
      bonus24.setPosition(startX - 4, startY - 3);
      bonus25.setPosition(startX - 3, startY - 3);
      bonus26.setPosition(startX - 2, startY - 3);
      bonus27.setPosition(startX - 1, startY - 3);
      bonus28.setPosition(startX, startY - 3);
    }
  };

  // src/model/skillTree/LineBasedSkill.js
  var LineBasedSkill = class {
    /**
     * @abstract
     * @param {WorldGrid} worldGrid
     */
    constructor(worldGrid) {
      this.worldGrid = worldGrid;
      this.startPoint = new Vector(0, 0);
      this.endPoint = new Vector(0, 0);
      this.workingPosition = new Vector(0, 0);
    }
    /**
     * @param {GridTile} prevTile
     * @param {Vector} projectedPosition
     * @returns {GridTile}
     */
    getProjectedTile(prevTile, projectedPosition) {
      if (prevTile && prevTile.contains(projectedPosition)) {
        return prevTile;
      }
      return this.worldGrid.findGridTile(projectedPosition);
    }
  };

  // src/model/skillTree/SkillUtil.js
  var SkillUtil = class {
    constructor() {
    }
    /**
     * @param {Vector} center 
     * @param {number} radius 
     * @param {number} radians 
     * @returns {Vector}
     */
    static projectPosition(center, radius, radians, outputPosition) {
      outputPosition.copy(center);
      outputPosition.x += Math.cos(radians) * radius;
      outputPosition.y += Math.sin(radians) * radius;
      return outputPosition;
    }
    /**
     * @param {Vector} position 
     * @param {GridTile[]} tiles 
     * @param {number} pixelRange2 
     */
    static findClosestTileInRange(position, tiles, pixelRange2) {
      if (tiles.length === 0) {
        return null;
      }
      let closestTile = null;
      let closestDist2 = 1e4;
      for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        if (!tile || tile.open) {
          continue;
        }
        const dist2 = position.distanceSquared(tile.origin);
        if (dist2 > pixelRange2) {
          continue;
        }
        if (!closestTile || dist2 < closestDist2) {
          closestTile = tile;
          closestDist2 = dist2;
        }
      }
      return closestTile;
    }
    /**
     * @param {Vector} position 
     * @param {GridTile[]} tiles 
     */
    static findClosestTile(position, tiles) {
      if (tiles.length === 0) {
        return null;
      }
      let closestTile = null;
      let closestDist2 = 1e4;
      for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        if (!tile || tile.open) {
          continue;
        }
        const dist2 = position.distanceSquared(tile.origin);
        if (!closestTile || dist2 < closestDist2) {
          closestTile = tile;
          closestDist2 = dist2;
        }
      }
      return closestTile;
    }
  };

  // src/model/skillTree/drill/Drill.js
  var HALF_PI = Math.PI / 2;
  var Drill = class extends LineBasedSkill {
    /**
     * @param {WorldGrid} worldGrid
     * @param {TileMinedLogic} tileMinedLogic
     * @param {NumberValue} depthUpgrades
     */
    constructor(worldGrid, tileMinedLogic, depthUpgrades) {
      super(worldGrid);
      this.tileMinedLogic = tileMinedLogic;
      this.depthUpgradeCount = depthUpgrades;
      this.drillTile = null;
      this.goalTile = null;
      this.skillActive = false;
    }
    onSkillActivation() {
      this.skillActive = true;
    }
    onSkillDeactivation() {
      this.skillActive = false;
      this.drillTile = null;
    }
    /**
     * @param {Character} miner
     * @param {number} frameTimeRatio
     */
    updateForFrame(miner, frameTimeRatio) {
      this.startPoint.copy(miner.position.worldCoordinateOrigin);
      this.startPoint.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
      const pixelRange = (Settings.skill.drill.minRange + Settings.skill.drill.tilesPerUpgrade * this.depthUpgradeCount.getValue()) * Settings.tile.size;
      this.workingPosition.copy(this.startPoint);
      this.workingPosition.y += pixelRange;
      this.goalTile = this.worldGrid.findGridTile(this.workingPosition);
      this.drillTile = this.goalTile;
      if (!this.goalTile) {
        return;
      }
      this.drillTile = this.findFirstClosedTileOnLine(this.startPoint, HALF_PI, pixelRange);
      if (!this.drillTile) {
        this.endPoint.copy(this.goalTile.origin);
        this.endPoint.x = this.startPoint.x;
        this.endPoint.y += Settings.tile.halfSize;
        return;
      }
      this.drillTile.markTileAsCurrentlyVisible();
      this.endPoint.copy(this.drillTile.origin);
      this.endPoint.x = this.startPoint.x;
      this.endPoint.y += Settings.tile.halfSize;
      if (!this.drillTile.open) {
        this.tileMinedLogic.drillTileForFrame(this.drillTile, frameTimeRatio);
      }
    }
    /**
     * @private
     * @param {Vector} startPoint 
     * @param {number} radians 
     * @param {number} pixelRange 
     * @returns {GridTile}
     */
    findFirstClosedTileOnLine(startPoint, radians, pixelRange) {
      let prevTile = null;
      for (let radius = Settings.tile.halfSize; radius <= pixelRange; radius += Settings.tile.halfSize) {
        const position = SkillUtil.projectPosition(startPoint, radius, radians, this.workingPosition);
        const projectedTile = this.getProjectedTile(prevTile, position);
        if (!projectedTile) {
          break;
        }
        if (prevTile === projectedTile) {
          continue;
        }
        if (!projectedTile.lighting.everVisibleToCharacter) {
          projectedTile.markTileAsCurrentlyVisible();
        }
        if (!projectedTile.open) {
          return projectedTile;
        }
        prevTile = projectedTile;
      }
      return prevTile && !prevTile.open ? prevTile : null;
    }
  };

  // src/view/canvas/DrillSkillRenderer.js
  var DrillSkillRenderer = class extends SkillRenderer {
    /**
     * @param {Drill[]} drillArray
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet
     */
    constructor(drillArray, spellFxSpritesheet) {
      super();
      this.drillArray = drillArray;
      this.spellFxSpritesheet = spellFxSpritesheet;
      this.skillAnimation = null;
      this.skillStart = Date.now();
    }
    /**
     * @override
     * @param {CanvasRenderingContext2D} context 
     * @param {Projection} projection 
     */
    renderSkill(context, projection) {
      if (this.drillArray.length === 0) {
        return;
      }
      for (let i = 0; i < this.drillArray.length; i++) {
        this.renderDrill(context, projection, this.drillArray[i]);
      }
    }
    /**
     * @override
     * @param {CanvasRenderingContext2D} context 
     * @param {Projection} projection 
     * @param {Drill} drill
     */
    renderDrill(context, projection, drill) {
      if (!drill.skillActive || !drill.goalTile) {
        return;
      }
      const now = Date.now();
      if (now - this.skillStart > 1e5) {
        this.skillStart = now;
      }
      if (!this.skillAnimation) {
        this.skillAnimation = this.spellFxSpritesheet.getSpriteAnimation(GervaisSpriteNames.EFFECT_NAME_SPARKLE_BLUE);
      }
      const startPoint = drill.startPoint;
      const endPoint = drill.endPoint;
      const safeLineWidth = context.lineWidth;
      context.lineWidth = 5;
      context.strokeStyle = "#00F";
      context.beginPath();
      projection.worldToScreen(startPoint, this.screenCoordinate);
      context.moveTo(this.screenCoordinate.x, this.screenCoordinate.y);
      projection.worldToScreen(endPoint, this.screenCoordinate);
      context.lineTo(this.screenCoordinate.x, this.screenCoordinate.y);
      context.stroke();
      context.lineWidth = 1;
      context.strokeStyle = "#FFF";
      context.beginPath();
      projection.worldToScreen(startPoint, this.screenCoordinate);
      context.moveTo(this.screenCoordinate.x, this.screenCoordinate.y);
      projection.worldToScreen(endPoint, this.screenCoordinate);
      context.lineTo(this.screenCoordinate.x, this.screenCoordinate.y);
      context.stroke();
      context.lineWidth = safeLineWidth;
      if (projection.isVisible(endPoint, Settings.tile.size)) {
        this.screenCoordinate.copy(endPoint);
        this.screenCoordinate.x -= Settings.tile.halfSize;
        this.screenCoordinate.y -= Settings.tile.halfSize;
        projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        const sprite = this.skillAnimation.getSpriteAsOf(Date.now(), this.skillStart);
        this.renderSprite(context, projection, sprite, this.screenCoordinate);
      }
    }
  };

  // src/model/skillTree/common/AddMInerSkillNode.js
  var AddMinerSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} title 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {SkillNodePurchaseListener} purchaseListener
     * @param {Crew} crew
     * @param {string} skillId
     */
    constructor(id, title, description, totals, iconFileName, cost, purchaseListener, crew, skillId) {
      super(id, title, description, totals, iconFileName, cost, purchaseListener);
      this.crew = crew;
      this.skillId = skillId;
    }
    /**
     * @override
     * @returns {boolean}
     */
    onPurchase() {
      if (!super.onPurchase()) {
        return false;
      }
      this.crew.addNewMinerNearMain(this.skillId);
      return true;
    }
    // Node: No need to add miner in onPurchaseFromSave() because all miners will be added when the Crew object
    // is loaded
  };

  // src/model/skillTree/common/CoolDownSkillNode.js
  var CoolDownSkillNode = class extends NumberValueSkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {SkillNodePurchaseListener} purchaseListener
     * @param {number} valuePerSkillLevel
     * @param {NumberValue} numberValue
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, valuePerSkillLevel, numberValue) {
      super(
        id,
        "Cool Down - " + Settings.skill.common.coolDownSecondsPerUpgrade + " sec",
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener,
        valuePerSkillLevel,
        numberValue
      );
    }
    /**
     * @override
     * @returns {string}
     */
    getDescription() {
      return ValueCalculator.getSkillCoolDownSeconds(this.numberValue) + " seconds";
    }
  };

  // src/model/skillTree/common/DurationSkillNode.js
  var DurationSkillNode = class extends NumberValueSkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {SkillNodePurchaseListener} purchaseListener
     * @param {number} valuePerSkillLevel
     * @param {NumberValue} numberValue
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, valuePerSkillLevel, numberValue) {
      super(
        id,
        "Duration + " + Settings.skill.common.activationSecondsPerUpgrade + " sec",
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener,
        valuePerSkillLevel,
        numberValue
      );
    }
    /**
     * @returns {string}
     */
    getDescription() {
      return ValueCalculator.getSkillActivationSeconds(this.numberValue) + " seconds";
    }
  };

  // src/model/skillTree/common/TileRangeSkillNode.js
  var TileRangeSkillNode = class extends NumberValueSkillNode {
    /**
     * @param {string} id 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {SkillNodePurchaseListener} purchaseListener
     * @param {number} valuePerSkillLevel
     * @param {NumberValue} numberValue
     * @param {number} minRange
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, valuePerSkillLevel, numberValue, minRange) {
      super(
        id,
        "+" + valuePerSkillLevel + " Tile",
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener,
        valuePerSkillLevel,
        numberValue
      );
      this.minRange = minRange;
    }
    /**
     * @returns {string}
     */
    getDescription() {
      const range = this.minRange + this.valuePerSkillLevel * this.numberValue.getValue();
      return "Range: " + range + " Tiles";
    }
  };

  // src/model/skillTree/drill/DrillSkill.js
  var DrillSkill = class extends SkillType {
    /**
     * @param {WorldGrid} worldGrid 
     * @param {Totals} totals
     * @param {TileMinedLogic} tileMinedLogic 
     * @param {Crew} crew
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet
     */
    constructor(worldGrid, totals, tileMinedLogic, crew, spellFxSpritesheet) {
      super(SkillIds.DRILL);
      this.worldGrid = worldGrid;
      this.tileMinedLogic = tileMinedLogic;
      this.totals = totals;
      this.crew = crew;
      this.drillArray = [];
      this.drillByCharacter = {};
      this.depthUpgrades = new NumberValue(null, 0);
      this.renderer = new DrillSkillRenderer(this.drillArray, spellFxSpritesheet);
      let cost = 1;
      const addMinerNode1 = this.addNode(new AddMinerSkillNode(
        "addDrillMiner1",
        "+1 Drill Miner",
        "Drills straight down",
        totals,
        Images.skill.drill,
        new BigNum(cost + Settings.skill.costs.addDrill1),
        this,
        crew,
        SkillIds.DRILL
      ));
      cost++;
      const drillDepth1 = this.addNode(new TileRangeSkillNode(
        "drillDepth1",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        Settings.skill.drill.tilesPerUpgrade,
        this.depthUpgrades,
        Settings.skill.drill.minRange
      ));
      const coolBonus1 = this.addNode(new CoolDownSkillNode(
        "drillCool1",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus1 = this.addNode(new DurationSkillNode(
        "drillDur1",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const drillDepth2 = this.addNode(new TileRangeSkillNode(
        "drillDepth2",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        Settings.skill.drill.tilesPerUpgrade,
        this.depthUpgrades,
        Settings.skill.drill.minRange
      ));
      const coolBonus2 = this.addNode(new CoolDownSkillNode(
        "drillCool2",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus2 = this.addNode(new DurationSkillNode(
        "drillDur2",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const drillDepth3 = this.addNode(new TileRangeSkillNode(
        "drillDepth3",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        Settings.skill.drill.tilesPerUpgrade,
        this.depthUpgrades,
        Settings.skill.drill.minRange
      ));
      const coolBonus3 = this.addNode(new CoolDownSkillNode(
        "drillCool3",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus3 = this.addNode(new DurationSkillNode(
        "drillDur3",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      const addMinerNode2 = this.addNode(new AddMinerSkillNode(
        "addDrillMiner2",
        "+1 Drill Miner",
        "Drills straight down",
        totals,
        Images.skill.drill,
        new BigNum(cost + Settings.skill.costs.addMiner2),
        this,
        crew,
        SkillIds.DRILL
      ));
      cost++;
      const drillDepth4 = this.addNode(new TileRangeSkillNode(
        "drillDepth4",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        Settings.skill.drill.tilesPerUpgrade,
        this.depthUpgrades,
        Settings.skill.drill.minRange
      ));
      const coolBonus4 = this.addNode(new CoolDownSkillNode(
        "drillCool4",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus4 = this.addNode(new DurationSkillNode(
        "drillDur4",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const drillDepth5 = this.addNode(new TileRangeSkillNode(
        "drillDepth5",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        Settings.skill.drill.tilesPerUpgrade,
        this.depthUpgrades,
        Settings.skill.drill.minRange
      ));
      const coolBonus5 = this.addNode(new CoolDownSkillNode(
        "drillCool5",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus5 = this.addNode(new DurationSkillNode(
        "drillDur5",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const drillDepth6 = this.addNode(new TileRangeSkillNode(
        "drillDepth6",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        Settings.skill.drill.tilesPerUpgrade,
        this.depthUpgrades,
        Settings.skill.drill.minRange
      ));
      const coolBonus6 = this.addNode(new CoolDownSkillNode(
        "drillCool6",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus6 = this.addNode(new DurationSkillNode(
        "drillDur6",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      const addMinerNode3 = this.addNode(new AddMinerSkillNode(
        "addDrillMiner3",
        "+1 Drill Miner",
        "Drills straight down",
        totals,
        Images.skill.drill,
        new BigNum(cost + Settings.skill.costs.addMiner3),
        this,
        crew,
        SkillIds.DRILL
      ));
      cost++;
      const drillDepth7 = this.addNode(new TileRangeSkillNode(
        "drillDepth7",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        Settings.skill.drill.tilesPerUpgrade,
        this.depthUpgrades,
        Settings.skill.drill.minRange
      ));
      const coolBonus7 = this.addNode(new CoolDownSkillNode(
        "drillCool7",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus7 = this.addNode(new DurationSkillNode(
        "drillDur7",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const drillDepth8 = this.addNode(new TileRangeSkillNode(
        "drillDepth8",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        Settings.skill.drill.tilesPerUpgrade,
        this.depthUpgrades,
        Settings.skill.drill.minRange
      ));
      const coolBonus8 = this.addNode(new CoolDownSkillNode(
        "drillCool8",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus8 = this.addNode(new DurationSkillNode(
        "drillDur8",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const drillDepth9 = this.addNode(new TileRangeSkillNode(
        "drillDepth9",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        Settings.skill.drill.tilesPerUpgrade,
        this.depthUpgrades,
        Settings.skill.drill.minRange
      ));
      const coolBonus9 = this.addNode(new CoolDownSkillNode(
        "drillCool9",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus9 = this.addNode(new DurationSkillNode(
        "drillDur9",
        totals,
        Images.skill.drill,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      const addMinerNode4 = this.addNode(new AddMinerSkillNode(
        "addDrillMiner4",
        "+1 Drill Miner",
        "Drills straight down",
        totals,
        Images.skill.drill,
        new BigNum(cost + Settings.skill.costs.addMiner4),
        this,
        crew,
        SkillIds.DRILL
      ));
      addMinerNode1.addChildNode(drillDepth1);
      drillDepth1.addChildNode(drillDepth2);
      drillDepth2.addChildNode(drillDepth3);
      drillDepth3.addChildNode(drillDepth4);
      drillDepth4.addChildNode(drillDepth5);
      drillDepth5.addChildNode(drillDepth6);
      drillDepth6.addChildNode(drillDepth7);
      drillDepth7.addChildNode(drillDepth8);
      drillDepth8.addChildNode(drillDepth9);
      drillDepth1.addChildNode(coolBonus1);
      drillDepth2.addChildNode(coolBonus2);
      drillDepth3.addChildNode(coolBonus3);
      drillDepth4.addChildNode(coolBonus4);
      drillDepth5.addChildNode(coolBonus5);
      drillDepth6.addChildNode(coolBonus6);
      drillDepth7.addChildNode(coolBonus7);
      drillDepth8.addChildNode(coolBonus8);
      drillDepth9.addChildNode(coolBonus9);
      drillDepth1.addChildNode(drillDepth2);
      drillDepth2.addChildNode(drillDepth3);
      drillDepth3.addChildNode(drillDepth4);
      drillDepth4.addChildNode(drillDepth5);
      drillDepth5.addChildNode(drillDepth6);
      drillDepth6.addChildNode(drillDepth7);
      drillDepth7.addChildNode(drillDepth8);
      drillDepth8.addChildNode(drillDepth9);
      drillDepth3.addChildNode(addMinerNode2);
      drillDepth6.addChildNode(addMinerNode3);
      drillDepth9.addChildNode(addMinerNode4);
      coolBonus1.addChildNode(durationBonus1);
      coolBonus2.addChildNode(durationBonus2);
      coolBonus3.addChildNode(durationBonus3);
      coolBonus4.addChildNode(durationBonus4);
      coolBonus5.addChildNode(durationBonus5);
      coolBonus6.addChildNode(durationBonus6);
      coolBonus7.addChildNode(durationBonus7);
      coolBonus8.addChildNode(durationBonus8);
      coolBonus9.addChildNode(durationBonus9);
      const startX = 3;
      const startY = 13;
      addMinerNode1.setPosition(startX, startY);
      drillDepth1.setPosition(startX + 1, startY);
      drillDepth2.setPosition(startX + 2, startY);
      drillDepth3.setPosition(startX + 3, startY);
      drillDepth4.setPosition(startX + 4, startY);
      drillDepth5.setPosition(startX + 5, startY);
      drillDepth6.setPosition(startX + 6, startY);
      drillDepth7.setPosition(startX + 7, startY);
      drillDepth8.setPosition(startX + 8, startY);
      drillDepth9.setPosition(startX + 9, startY);
      coolBonus1.setPosition(startX + 1, startY - 1);
      coolBonus2.setPosition(startX + 2, startY - 1);
      coolBonus3.setPosition(startX + 3, startY - 1);
      coolBonus4.setPosition(startX + 4, startY - 1);
      coolBonus5.setPosition(startX + 5, startY - 1);
      coolBonus6.setPosition(startX + 6, startY - 1);
      coolBonus7.setPosition(startX + 7, startY - 1);
      coolBonus8.setPosition(startX + 8, startY - 1);
      coolBonus9.setPosition(startX + 9, startY - 1);
      durationBonus1.setPosition(startX + 1, startY - 2);
      durationBonus2.setPosition(startX + 2, startY - 2);
      durationBonus3.setPosition(startX + 3, startY - 2);
      durationBonus4.setPosition(startX + 4, startY - 2);
      durationBonus5.setPosition(startX + 5, startY - 2);
      durationBonus6.setPosition(startX + 6, startY - 2);
      durationBonus7.setPosition(startX + 7, startY - 2);
      durationBonus8.setPosition(startX + 8, startY - 2);
      durationBonus9.setPosition(startX + 9, startY - 2);
      addMinerNode2.setPosition(startX + 3, startY + 1);
      addMinerNode3.setPosition(startX + 6, startY + 1);
      addMinerNode4.setPosition(startX + 9, startY + 1);
    }
    /**
     * @override
     * @param {PartyCharacter} miner
     * @param {number} frameTimeRatio 
     * @param {boolean} skillActive
     */
    updateSkillForFrame(miner, frameTimeRatio, skillActive) {
      let drill = this.drillByCharacter[miner.id];
      if (!drill) {
        drill = new Drill(this.worldGrid, this.tileMinedLogic, this.depthUpgrades);
        this.drillByCharacter[miner.id] = drill;
        this.drillArray.push(drill);
      }
      if (skillActive && !drill.skillActive) {
        drill.onSkillActivation();
      } else if (!skillActive && drill.skillActive) {
        drill.onSkillDeactivation();
      }
      if (skillActive) {
        drill.updateForFrame(miner, frameTimeRatio);
      }
    }
    /**
     * @override
     * @returns {SkillRenderer}
     */
    getRenderer() {
      return this.renderer;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      super.resetFull();
      this.drillArray.length = 0;
      this.drillByCharacter = {};
      this.depthUpgrades.reset();
    }
  };

  // src/model/skillTree/laser/Laser.js
  var INVALID_TARGET_RADIANS = 1e3;
  var FRAME_STEP_RADIANS = Math.PI / 32;
  var TWO_PI = Math.PI * 2;
  var RADIAN_THRESHOLD = Math.PI;
  var Laser = class extends LineBasedSkill {
    /**
     * @param {WorldGrid} worldGrid
     * @param {GameTime} gameTime
     * @param {VectorField} vectorField
     * @param {TileMinedLogic} tileMinedLogic
     * @param {NumberValue} laserRangeUpgrades
     */
    constructor(worldGrid, gameTime, vectorField, tileMinedLogic, laserRangeUpgrades) {
      super(worldGrid);
      this.vectorField = vectorField;
      this.gameTime = gameTime;
      this.tileMinedLogic = tileMinedLogic;
      this.laserRangeUpgrades = laserRangeUpgrades;
      this.prevLaserTargetTile = null;
      this.actualRadians = INVALID_TARGET_RADIANS;
      this.skillActive = false;
      this.laserVisible = false;
      this.prevTurn = 0;
    }
    onSkillActivation() {
      this.actualRadians = INVALID_TARGET_RADIANS;
      this.skillActive = true;
      this.prevLaserTargetTile = null;
    }
    onSkillDeactivation() {
      this.actualRadians = INVALID_TARGET_RADIANS;
      this.skillActive = false;
      this.laserVisible = false;
      this.prevLaserTargetTile = null;
    }
    /**
     * @param {PartyCharacter} miner
     * @param {number} frameTimeRatio
     */
    updateForFrame(miner, frameTimeRatio) {
      if (!miner.position.tile) {
        this.laserVisible = false;
        this.actualRadians = INVALID_TARGET_RADIANS;
        return;
      }
      this.startPoint.copy(miner.position.worldCoordinateOrigin);
      this.startPoint.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
      const pixelRange = (Settings.skill.laser.minRange + Settings.skill.laser.tilesPerUpgrade * this.laserRangeUpgrades.getValue()) * Settings.tile.size;
      const lineRadians = this.chooseLaserRadians(miner, pixelRange, this.startPoint);
      if (lineRadians === INVALID_TARGET_RADIANS) {
        this.laserVisible = false;
        this.actualRadians = INVALID_TARGET_RADIANS;
        return;
      }
      if (this.actualRadians === INVALID_TARGET_RADIANS) {
        this.actualRadians = lineRadians;
      } else {
        this.actualRadians = this.updateRadians(this.actualRadians, lineRadians, frameTimeRatio);
      }
      const laserTile = this.findFirstClosedTileOnLine(this.startPoint, this.actualRadians, pixelRange);
      if (!laserTile) {
        this.laserVisible = false;
        this.actualRadians = INVALID_TARGET_RADIANS;
        return;
      }
      laserTile.markTileAsCurrentlyVisible();
      this.endPoint.copy(laserTile.origin);
      this.endPoint.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
      if (!laserTile.open) {
        this.tileMinedLogic.laserTileForFrame(laserTile, frameTimeRatio);
      }
      this.laserVisible = true;
    }
    /**
     * @private
     * @param {number} currentRadians 
     * @param {number} newRadians 
     * @param {number} frameTimeRatio 
     * @returns {number}
     */
    updateRadians(currentRadians, newRadians, frameTimeRatio) {
      const radiansStep = FRAME_STEP_RADIANS * frameTimeRatio;
      const deltaPos = this.getRadiansPositiveDirection(currentRadians, newRadians);
      const deltaNeg = this.getRadiansNegativeDirection(currentRadians, newRadians);
      if (deltaPos < deltaNeg) {
        if (deltaPos < radiansStep || deltaPos >= RADIAN_THRESHOLD) {
          return newRadians;
        }
        return this.clamp(currentRadians + radiansStep);
      } else {
        if (deltaNeg < radiansStep || deltaNeg >= RADIAN_THRESHOLD) {
          return newRadians;
        }
        return this.clamp(currentRadians - radiansStep);
      }
    }
    /**
     * @private
     * @param {number} radians 
     * @returns {number}
     */
    clamp(radians) {
      if (radians < 0) {
        return radians + TWO_PI;
      } else if (radians > TWO_PI) {
        return radians - TWO_PI;
      } else {
        return radians;
      }
    }
    /**
     * Returns positive amount of radians.
     * @private
     * @param {number} currentRadians 
     * @param {number} newRadians 
     * @returns {number}
     */
    getRadiansPositiveDirection(currentRadians, newRadians) {
      if (newRadians < currentRadians) {
        return TWO_PI - currentRadians + newRadians;
      } else {
        return newRadians - currentRadians;
      }
    }
    /**
     * Returns positive amount of radians.
     * @private
     * @param {number} currentRadians 
     * @param {number} newRadians 
     * @returns {number}
     */
    getRadiansNegativeDirection(currentRadians, newRadians) {
      if (newRadians < currentRadians) {
        return currentRadians - newRadians;
      } else {
        return TWO_PI - newRadians + currentRadians;
      }
    }
    /**
     * @private
     * @param {PartyCharacter} miner
     * @param {number} pixelRange
     * @param {Vector} startPoint This is at the center of the tile
     * @returns {number}
     */
    chooseLaserRadians(miner, pixelRange, startPoint) {
      const laserTargetTile = this.chooseLaserTargetTile(miner, pixelRange);
      if (laserTargetTile) {
        this.workingPosition.copy(laserTargetTile.origin);
        this.workingPosition.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
        return this.calculateAngle(startPoint, this.workingPosition);
      } else {
        return INVALID_TARGET_RADIANS;
      }
    }
    /**
     * @private
     * @param {Character} miner 
     * @param {number} pixelRange
     */
    chooseLaserTargetTile(miner, pixelRange) {
      const pixelRange2 = pixelRange * pixelRange;
      const minerPosition = miner.position.worldCoordinateOrigin;
      const priorityTile2 = SkillUtil.findClosestTile(minerPosition, this.vectorField.priorityMiningCandidates);
      if (priorityTile2) {
        this.prevLaserTargetTile = priorityTile2;
        return priorityTile2;
      }
      const currencyTile2 = SkillUtil.findClosestTile(minerPosition, this.vectorField.currencyMiningCandidates);
      if (currencyTile2) {
        this.prevLaserTargetTile = currencyTile2;
        return currencyTile2;
      }
      const commonTile = SkillUtil.findClosestTileInRange(minerPosition, this.vectorField.commonMiningCandidates, pixelRange2);
      if (commonTile) {
        this.prevLaserTargetTile = commonTile;
        return commonTile;
      }
      const mineTarget = miner.target.mineTile;
      if (mineTarget) {
        this.prevLaserTargetTile = mineTarget;
        return mineTarget;
      }
      const targetTile = miner.target.targetTile;
      if (targetTile && miner.position.tile !== targetTile) {
        this.prevLaserTargetTile = targetTile;
        return targetTile;
      }
      if (this.prevLaserTargetTile && !this.prevLaserTargetTile.open) {
        return this.prevLaserTargetTile;
      }
      this.prevLaserTargetTile = null;
      return null;
    }
    // /**
    //  * @private
    //  * @param {Vector} minerPosition 
    //  * @param {GridTile} tile 
    //  * @param {number} pixelRange2 
    //  * @returns {boolean}
    //  */
    // isTileInLaserRange(minerPosition, tile, pixelRange2) {
    //     return minerPosition.distanceSquared(tile.origin) <= pixelRange2;
    // }
    /**
     * @private
     * @param {Vector} startPoint 
     * @param {number} radians 
     * @param {number} pixelRange 
     * @returns {GridTile}
     */
    findFirstClosedTileOnLine(startPoint, radians, pixelRange) {
      let prevTile = null;
      for (let radius = Settings.tile.halfSize; radius <= pixelRange; radius += Settings.tile.halfSize) {
        const position = SkillUtil.projectPosition(startPoint, radius, radians, this.workingPosition);
        const projectedTile = this.getProjectedTile(prevTile, position);
        if (!projectedTile) {
          break;
        }
        if (prevTile === projectedTile) {
          continue;
        }
        if (!projectedTile.lighting.everVisibleToCharacter) {
          projectedTile.markTileAsCurrentlyVisible();
        }
        if (!projectedTile.open) {
          return projectedTile;
        }
        prevTile = projectedTile;
      }
      return prevTile;
    }
    /**
     * @private
     * @param {Vector} start 
     * @param {Vector} end 
     * @returns {number} radians
     */
    calculateAngle(start, end) {
      return this.clamp(Math.atan2(end.y - start.y, end.x - start.x));
    }
  };

  // src/view/canvas/LaserSkillRenderer.js
  var LaserSkillRenderer = class extends SkillRenderer {
    /**
     * @param {Laser[]} laserArray 
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet
     */
    constructor(laserArray, spellFxSpritesheet) {
      super();
      this.laserArray = laserArray;
      this.spellFxSpritesheet = spellFxSpritesheet;
      this.skillAnimation = null;
      this.skillStart = Date.now();
    }
    /**
     * @override
     * @param {CanvasRenderingContext2D} context 
     * @param {Projection} projection 
     */
    renderSkill(context, projection) {
      if (this.laserArray.length === 0) {
        return;
      }
      for (let i = 0; i < this.laserArray.length; i++) {
        this.renderLaser(context, projection, this.laserArray[i]);
      }
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context 
     * @param {Projection} projection 
     * @param {Laser} laser 
     */
    renderLaser(context, projection, laser) {
      if (!laser.laserVisible) {
        return;
      }
      const now = Date.now();
      if (now - this.skillStart > 1e5) {
        this.skillStart = now;
      }
      if (!this.skillAnimation) {
        this.skillAnimation = this.spellFxSpritesheet.getSpriteAnimation(GervaisSpriteNames.EFFECT_NAME_SPARKLE_RED);
      }
      const startPoint = laser.startPoint;
      const endPoint = laser.endPoint;
      const safeLineWidth = context.lineWidth;
      context.lineWidth = 5;
      context.strokeStyle = "#F00";
      context.beginPath();
      projection.worldToScreen(startPoint, this.screenCoordinate);
      context.moveTo(this.screenCoordinate.x, this.screenCoordinate.y);
      projection.worldToScreen(endPoint, this.screenCoordinate);
      context.lineTo(this.screenCoordinate.x, this.screenCoordinate.y);
      context.stroke();
      context.lineWidth = 1;
      context.strokeStyle = "#FFF";
      context.beginPath();
      projection.worldToScreen(startPoint, this.screenCoordinate);
      context.moveTo(this.screenCoordinate.x, this.screenCoordinate.y);
      projection.worldToScreen(endPoint, this.screenCoordinate);
      context.lineTo(this.screenCoordinate.x, this.screenCoordinate.y);
      context.stroke();
      context.lineWidth = safeLineWidth;
      if (projection.isVisible(endPoint, Settings.tile.size)) {
        this.screenCoordinate.copy(endPoint);
        this.screenCoordinate.x -= Settings.tile.halfSize;
        this.screenCoordinate.y -= Settings.tile.halfSize;
        projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        const sprite = this.skillAnimation.getSpriteAsOf(Date.now(), this.skillStart);
        this.renderSprite(context, projection, sprite, this.screenCoordinate);
      }
    }
  };

  // src/model/skillTree/laser/LaserSkill.js
  var LaserSkill = class extends SkillType {
    /**
     * @param {WorldGrid} worldGrid 
     * @param {Totals} totals
     * @param {TileMinedLogic} tileMinedLogic 
     * @param {Crew} crew
     * @param {GameTime} gameTime
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet
     * @param {VectorField} vectorField
     */
    constructor(worldGrid, totals, tileMinedLogic, crew, gameTime, spellFxSpritesheet, vectorField) {
      super(SkillIds.LASER);
      this.worldGrid = worldGrid;
      this.tileMinedLogic = tileMinedLogic;
      this.totals = totals;
      this.crew = crew;
      this.gameTime = gameTime;
      this.vectorField = vectorField;
      this.laserRangeUpgrades = new NumberValue(null, 0);
      this.laserArray = [];
      this.laserByCharacter = {};
      this.renderer = new LaserSkillRenderer(this.laserArray, spellFxSpritesheet);
      let cost = 1;
      const addMinerNode1 = this.addNode(new AddMinerSkillNode(
        "addLaserMiner1",
        "+1 Laser Miner",
        "Blasts stone with a laser",
        totals,
        Images.skill.laser,
        new BigNum(cost + Settings.skill.costs.addLaser1),
        this,
        crew,
        SkillIds.LASER
      ));
      cost++;
      const rangeBonus1 = this.addNode(new TileRangeSkillNode(
        "laserRange1",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        Settings.skill.laser.tilesPerUpgrade,
        this.laserRangeUpgrades,
        Settings.skill.laser.minRange
      ));
      const coolBonus1 = this.addNode(new CoolDownSkillNode(
        "laserCool1",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus1 = this.addNode(new DurationSkillNode(
        "laserDur1",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const rangeBonus2 = this.addNode(new TileRangeSkillNode(
        "laserRange2",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        Settings.skill.laser.tilesPerUpgrade,
        this.laserRangeUpgrades,
        Settings.skill.laser.minRange
      ));
      const coolBonus2 = this.addNode(new CoolDownSkillNode(
        "laserCool2",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus2 = this.addNode(new DurationSkillNode(
        "laserDur2",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const rangeBonus3 = this.addNode(new TileRangeSkillNode(
        "laserRange3",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        Settings.skill.laser.tilesPerUpgrade,
        this.laserRangeUpgrades,
        Settings.skill.laser.minRange
      ));
      const coolBonus3 = this.addNode(new CoolDownSkillNode(
        "laserCool3",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus3 = this.addNode(new DurationSkillNode(
        "laserDur3",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const rangeBonus4 = this.addNode(new TileRangeSkillNode(
        "laserRange4",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        Settings.skill.laser.tilesPerUpgrade,
        this.laserRangeUpgrades,
        Settings.skill.laser.minRange
      ));
      const addMinerNode2 = this.addNode(new AddMinerSkillNode(
        "addLaserMiner2",
        "+1 Laser Miner",
        "Blasts stone with a laser",
        totals,
        Images.skill.laser,
        new BigNum(cost + Settings.skill.costs.addMiner2),
        this,
        crew,
        SkillIds.LASER
      ));
      const coolBonus4 = this.addNode(new CoolDownSkillNode(
        "laserCool4",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus4 = this.addNode(new DurationSkillNode(
        "laserDur4",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const rangeBonus5 = this.addNode(new TileRangeSkillNode(
        "laserRange5",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        Settings.skill.laser.tilesPerUpgrade,
        this.laserRangeUpgrades,
        Settings.skill.laser.minRange
      ));
      const coolBonus5 = this.addNode(new CoolDownSkillNode(
        "laserCool5",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus5 = this.addNode(new DurationSkillNode(
        "laserDur5",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const rangeBonus6 = this.addNode(new TileRangeSkillNode(
        "laserRange6",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        Settings.skill.laser.tilesPerUpgrade,
        this.laserRangeUpgrades,
        Settings.skill.laser.minRange
      ));
      const coolBonus6 = this.addNode(new CoolDownSkillNode(
        "laserCool6",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus6 = this.addNode(new DurationSkillNode(
        "laserDur6",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const rangeBonus7 = this.addNode(new TileRangeSkillNode(
        "laserRange7",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        Settings.skill.laser.tilesPerUpgrade,
        this.laserRangeUpgrades,
        Settings.skill.laser.minRange
      ));
      const addMinerNode3 = this.addNode(new AddMinerSkillNode(
        "addLaserMiner3",
        "+1 Laser Miner",
        "Blasts stone with a laser",
        totals,
        Images.skill.laser,
        new BigNum(cost + Settings.skill.costs.addMiner3),
        this,
        crew,
        SkillIds.LASER
      ));
      const coolBonus7 = this.addNode(new CoolDownSkillNode(
        "laserCool7",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus7 = this.addNode(new DurationSkillNode(
        "laserDur7",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const rangeBonus8 = this.addNode(new TileRangeSkillNode(
        "laserRange8",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        Settings.skill.laser.tilesPerUpgrade,
        this.laserRangeUpgrades,
        Settings.skill.laser.minRange
      ));
      const coolBonus8 = this.addNode(new CoolDownSkillNode(
        "laserCool8",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus8 = this.addNode(new DurationSkillNode(
        "laserDur8",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const rangeBonus9 = this.addNode(new TileRangeSkillNode(
        "laserRange9",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        Settings.skill.laser.tilesPerUpgrade,
        this.laserRangeUpgrades,
        Settings.skill.laser.minRange
      ));
      const addMinerNode4 = this.addNode(new AddMinerSkillNode(
        "addLaserMiner4",
        "+1 Laser Miner",
        "Blasts stone with a laser",
        totals,
        Images.skill.laser,
        new BigNum(cost + Settings.skill.costs.addMiner4),
        this,
        crew,
        SkillIds.LASER
      ));
      const coolBonus9 = this.addNode(new CoolDownSkillNode(
        "laserCool9",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus9 = this.addNode(new DurationSkillNode(
        "laserDur9",
        totals,
        Images.skill.laser,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      addMinerNode1.addChildNode(rangeBonus1);
      rangeBonus1.addChildNode(rangeBonus2);
      rangeBonus2.addChildNode(rangeBonus3);
      rangeBonus3.addChildNode(rangeBonus4);
      rangeBonus4.addChildNode(rangeBonus5);
      rangeBonus5.addChildNode(rangeBonus6);
      rangeBonus6.addChildNode(rangeBonus7);
      rangeBonus7.addChildNode(rangeBonus8);
      rangeBonus8.addChildNode(rangeBonus9);
      rangeBonus1.addChildNode(coolBonus1);
      rangeBonus2.addChildNode(coolBonus2);
      rangeBonus3.addChildNode(coolBonus3);
      rangeBonus4.addChildNode(coolBonus4);
      rangeBonus5.addChildNode(coolBonus5);
      rangeBonus6.addChildNode(coolBonus6);
      rangeBonus7.addChildNode(coolBonus7);
      rangeBonus8.addChildNode(coolBonus8);
      rangeBonus9.addChildNode(coolBonus9);
      coolBonus1.addChildNode(durationBonus1);
      coolBonus2.addChildNode(durationBonus2);
      coolBonus3.addChildNode(durationBonus3);
      coolBonus4.addChildNode(durationBonus4);
      coolBonus5.addChildNode(durationBonus5);
      coolBonus6.addChildNode(durationBonus6);
      coolBonus7.addChildNode(durationBonus7);
      coolBonus8.addChildNode(durationBonus8);
      coolBonus9.addChildNode(durationBonus9);
      rangeBonus3.addChildNode(addMinerNode2);
      rangeBonus7.addChildNode(addMinerNode3);
      rangeBonus9.addChildNode(addMinerNode4);
      const startX = 3;
      const startY = 8;
      addMinerNode1.setPosition(startX, startY);
      rangeBonus1.setPosition(startX + 1, startY);
      rangeBonus2.setPosition(startX + 2, startY);
      rangeBonus3.setPosition(startX + 3, startY);
      rangeBonus4.setPosition(startX + 4, startY);
      rangeBonus5.setPosition(startX + 5, startY);
      rangeBonus6.setPosition(startX + 6, startY);
      rangeBonus7.setPosition(startX + 7, startY);
      rangeBonus8.setPosition(startX + 8, startY);
      rangeBonus9.setPosition(startX + 9, startY);
      coolBonus1.setPosition(startX + 1, startY - 1);
      coolBonus2.setPosition(startX + 2, startY - 1);
      coolBonus3.setPosition(startX + 3, startY - 1);
      coolBonus4.setPosition(startX + 4, startY - 1);
      coolBonus5.setPosition(startX + 5, startY - 1);
      coolBonus6.setPosition(startX + 6, startY - 1);
      coolBonus7.setPosition(startX + 7, startY - 1);
      coolBonus8.setPosition(startX + 8, startY - 1);
      coolBonus9.setPosition(startX + 9, startY - 1);
      durationBonus1.setPosition(startX + 1, startY - 2);
      durationBonus2.setPosition(startX + 2, startY - 2);
      durationBonus3.setPosition(startX + 3, startY - 2);
      durationBonus4.setPosition(startX + 4, startY - 2);
      durationBonus5.setPosition(startX + 5, startY - 2);
      durationBonus6.setPosition(startX + 6, startY - 2);
      durationBonus7.setPosition(startX + 7, startY - 2);
      durationBonus8.setPosition(startX + 8, startY - 2);
      durationBonus9.setPosition(startX + 9, startY - 2);
      addMinerNode2.setPosition(startX + 3, startY + 1);
      addMinerNode3.setPosition(startX + 7, startY + 1);
      addMinerNode4.setPosition(startX + 9, startY + 1);
    }
    /**
     * @override
     * @param {PartyCharacter} miner
     * @param {number} frameTimeRatio 
     * @param {boolean} skillActive
     */
    updateSkillForFrame(miner, frameTimeRatio, skillActive) {
      let laser = this.laserByCharacter[miner.id];
      if (!laser) {
        laser = new Laser(this.worldGrid, this.gameTime, this.vectorField, this.tileMinedLogic, this.laserRangeUpgrades);
        this.laserByCharacter[miner.id] = laser;
        this.laserArray.push(laser);
      }
      if (skillActive && !laser.skillActive) {
        laser.onSkillActivation();
      } else if (!skillActive && laser.skillActive) {
        laser.onSkillDeactivation();
      }
      if (skillActive) {
        laser.updateForFrame(miner, frameTimeRatio);
      }
    }
    /**
     * @override
     * @returns {SkillRenderer}
     */
    getRenderer() {
      return this.renderer;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      super.resetFull();
      this.laserArray.length = 0;
      this.laserByCharacter = {};
      this.laserRangeUpgrades.reset();
    }
  };

  // src/model/skillTree/missile/Missile.js
  var Missile = class {
    /**
     * @param {WorldGrid} worldGrid
     * @param {TileMinedLogic} tileMinedLogic
     * @param {Missiles}
     */
    constructor(worldGrid, tileMinedLogic, missiles) {
      this.worldGrid = worldGrid;
      this.tileMinedLogic = tileMinedLogic;
      this.missiles = missiles;
      this.active = false;
      this.startPosition = new Vector(0, 0);
      this.position = new Vector(0, 0);
      this.movementUnitVector = new Vector(0, 0);
      this.movementVector = new Vector(0, 0);
      this.tile = null;
      this.spriteDirection = 0;
      this.distance = 0;
      this.missileDamage = new BigNum(0);
    }
    resetMissile() {
      this.active = false;
      this.tile = null;
      this.distance = 0;
    }
    /**
     * @param {Vector} startPositionOrigin 
     * @param {number} radians
     * @param {number} spriteDirection
     */
    onMissileFire(startPositionOrigin, radians, spriteDirection) {
      this.resetMissile();
      this.startPosition.copy(startPositionOrigin);
      this.startPosition.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
      const missileRadians = this.applyRandom(radians);
      this.spriteDirection = spriteDirection;
      this.active = true;
      SkillUtil.projectPosition(this.startPosition, Settings.tile.size, missileRadians, this.position);
      this.tileMinedLogic.calculateMissileDamage(this.missileDamage);
      this.movementUnitVector.copy(this.position);
      this.movementUnitVector.subtract(this.startPosition);
      Fast.nor(this.movementUnitVector);
    }
    /**
     * @private
     * @param {number} radians 
     * @returns {number}
     */
    applyRandom(radians) {
      const fudge = Math.PI / 16 * Math.random();
      if (Math.random() < 0.5) {
        return radians - fudge;
      } else {
        return radians + fudge;
      }
    }
    /**
     * @param {number} movementPerFrame
     */
    updateForFrame(movementPerFrame) {
      this.movementVector.copy(this.movementUnitVector);
      this.movementVector.scale(movementPerFrame);
      this.distance += movementPerFrame;
      this.position.add(this.movementVector);
      this.tile = this.worldGrid.findGridTile(this.position);
      if (!this.tile) {
        this.active = false;
        return;
      }
      if (this.tile) {
        if (!this.tile.lighting.everVisibleToCharacter) {
          this.tile.markTileAsCurrentlyVisible();
        }
        const collisionTile = !this.tile.open ? this.tile : this.findCollisionTile(this.position, this.tile);
        if (collisionTile) {
          if (!collisionTile.lighting.everVisibleToCharacter) {
            collisionTile.markTileAsCurrentlyVisible();
          }
          this.tileMinedLogic.missileTile(collisionTile, this.missileDamage);
          if (collisionTile.open) {
            this.missiles.addExplosion(this.position);
          }
          if (this.missileDamage.lessThanEqualsZero()) {
            this.active = false;
            return;
          }
        }
      }
      const maxPixelRange = 20 * Settings.tile.size;
      if (this.distance >= maxPixelRange) {
        this.active = false;
        return;
      }
    }
    /**
     * @private
     * @param {Vector} position 
     * @param {GridTile} tile 
     * @returns {GridTile}
     */
    findCollisionTile(position, tile) {
      const width = 3;
      for (let i = 0; i < tile.neighbors.length; i++) {
        const neighbor = tile.neighbors[i];
        if (!neighbor || neighbor.open) {
          continue;
        }
        if (neighbor.intersects(position.x, position.y, width)) {
          return neighbor;
        }
      }
      return null;
    }
  };

  // src/model/skillTree/missile/Explosion.js
  var Explosion = class {
    /**
     */
    constructor() {
      this.position = new Vector(0, 0);
      this.time = Date.now();
      this.active = false;
    }
    /**
     * @param {Vector} position 
     */
    activate(position) {
      this.position.copy(position);
      this.time = Date.now();
      this.active = true;
    }
    deactivate() {
      this.active = false;
    }
  };

  // src/model/skillTree/missile/Missiles.js
  var TWO_PI2 = Math.PI * 2;
  var Missiles = class {
    /**
     * @param {WorldGrid} worldGrid
     * @param {VectorField} vectorField
     * @param {NumberValue} missilesUpgrades
     * @param {TileMinedLogic} tileMinedLogic
     * @param {Values} values
     */
    constructor(worldGrid, vectorField, missilesUpgrades, tileMinedLogic, values) {
      this.worldGrid = worldGrid;
      this.vectorField = vectorField;
      this.values = values;
      this.missilesUpgrades = missilesUpgrades;
      this.tileMinedLogic = tileMinedLogic;
      this.missileExplosions = new Array(3);
      for (let i = 0; i < this.missileExplosions.length; i++) {
        this.missileExplosions[i] = new Explosion();
      }
      this.missiles = [];
      this.activeMissiles = 0;
      this.lastFireTime = 0;
      this.millisBetweenFires = 550;
      this.skillActive = false;
      this.burstActive = false;
      this.burstCount = 0;
      this.burstTime = 0;
      this.burstDelay = 70;
      this.radians = 0;
      this.spriteDirection = 0;
    }
    onSkillActivation() {
      this.skillActive = true;
      const now = Date.now();
      this.burstActive = false;
      this.burstTime = now - this.burstDelay;
      this.activeMissiles = 0;
      this.lastFireTime = now - this.millisBetweenFires;
      for (let i = 0; i < this.missileExplosions.length; i++) {
        this.missileExplosions[i].deactivate();
      }
      for (let i = 0; i < this.missiles.length; i++) {
        this.missiles[i].resetMissile();
      }
    }
    onSkillDeactivation() {
      this.skillActive = false;
      for (let i = 0; i < this.missileExplosions.length; i++) {
        this.missileExplosions[i].deactivate();
      }
      this.burstActive = false;
      this.activeMissiles = 0;
    }
    /**
     * @param {Character} miner
     * @param {number} frameTimeRatio
     */
    updateForFrame(miner, frameTimeRatio) {
      if (!miner.position.tile) {
        return;
      }
      const now = Date.now();
      if (!this.burstActive && this.activeMissiles === 0 && now - this.lastFireTime > this.millisBetweenFires) {
        this.burstActive = true;
        this.burstCount = 0;
        this.burstTime = now - this.burstDelay;
        this.chooseBestFireDirection(miner);
      }
      if (this.burstActive) {
        const maxCount = ValueCalculator.getMissileCount(this.missilesUpgrades);
        while (this.missiles.length < maxCount) {
          this.missiles.push(new Missile(this.worldGrid, this.tileMinedLogic, this));
        }
        if (now - this.burstTime >= this.burstDelay) {
          this.burstTime = now;
          const missile = this.missiles[this.burstCount];
          this.burstCount++;
          missile.onMissileFire(miner.position.worldCoordinateOrigin, this.radians, this.spriteDirection);
          this.activeMissiles++;
        }
        if (this.burstCount >= maxCount) {
          this.burstActive = false;
        }
      }
      if (this.activeMissiles > 0) {
        const movementPerFrame = this.getMissileMovementPerFrame(frameTimeRatio);
        this.activeMissiles = 0;
        for (let i = 0; i < this.missiles.length; i++) {
          const missile = this.missiles[i];
          if (!missile || !missile.active) {
            continue;
          }
          missile.updateForFrame(movementPerFrame);
          if (missile.active) {
            this.activeMissiles++;
          }
        }
        if (this.activeMissiles === 0) {
          this.lastFireTime = now;
        }
      }
    }
    /**
     * @private
     * @param {number} frameTimeRatio 
     * @returns {number}
     */
    getMissileMovementPerFrame(frameTimeRatio) {
      const defaultMovement = 6 * frameTimeRatio;
      if (this.values.fallSpeedBonusActive.isValue()) {
        const fallMultiplier = ValueCalculator.getFallSpeedMultiplier(this.values.fallSpeedUpgrades.getValue());
        return defaultMovement * fallMultiplier;
      } else {
        return defaultMovement;
      }
    }
    /**
     * @param {Vector} position
     */
    addExplosion(position) {
      const explosion = this.findAvailableExplosion();
      if (!explosion) {
        console.log("Missiles.addExplosion() failed to find available explosion.");
        return;
      }
      explosion.activate(position);
    }
    /**
     * @private
     * @returns {Explosion}
     */
    findAvailableExplosion() {
      const maxCount = ValueCalculator.getMissileCount(this.missilesUpgrades);
      if (this.missileExplosions.length < maxCount) {
        for (let i = 0; i < this.missileExplosions.length; i++) {
          const explosion2 = this.missileExplosions[i];
          if (!explosion2.active) {
            return explosion2;
          }
        }
        const explosion = new Explosion();
        this.missileExplosions.push(explosion);
        return explosion;
      } else {
        let oldestExplosion = null;
        let oldestTime = 0;
        for (let i = 0; i < this.missileExplosions.length; i++) {
          const explosion = this.missileExplosions[i];
          if (!explosion.active) {
            return explosion;
          }
          if (!oldestExplosion || explosion.time < oldestTime) {
            oldestExplosion = explosion;
            oldestTime = explosion.time;
          }
        }
        return oldestExplosion;
      }
    }
    /**
     * @private
     * @param {Character} miner
     */
    chooseBestFireDirection(miner) {
      const targetTile = this.chooseTargetTile(miner);
      if (targetTile && targetTile !== miner.position.tile) {
        this.radians = this.calculateAngle(miner.position.worldCoordinateOrigin, targetTile.origin);
        this.spriteDirection = this.calculateSpriteDirection(this.radians);
      } else {
        this.chooseRandomDirection();
      }
    }
    /**
     * @private
     * @param {Vector} start 
     * @param {Vector} end 
     * @returns {number} radians
     */
    calculateAngle(start, end) {
      return this.clamp(Math.atan2(end.y - start.y, end.x - start.x));
    }
    /**
     * @param {number} radians 
     * @returns {number}
     */
    clamp(radians) {
      if (radians < 0) {
        return radians + TWO_PI2;
      } else if (radians > TWO_PI2) {
        return radians - TWO_PI2;
      }
      return radians;
    }
    /**
     * @private
     * @param {Character} miner 
     */
    chooseTargetTile(miner) {
      const minerPosition = miner.position.worldCoordinateOrigin;
      const priorityTile = SkillUtil.findClosestTile(minerPosition, this.vectorField.priorityMiningCandidates);
      if (priorityTile) {
        return priorityTile;
      }
      const currencyTile = SkillUtil.findClosestTile(minerPosition, this.vectorField.currencyMiningCandidates);
      if (currencyTile) {
        return currencyTile;
      }
      const mineTarget = miner.target.mineTile;
      if (mineTarget) {
        return mineTarget;
      }
      const targetTile = miner.target.targetTile;
      if (targetTile) {
        return targetTile;
      }
      return null;
    }
    /**
     * @private
     * @param {number} radians 
     * @returns {number}
     */
    calculateSpriteDirection(radians) {
      const angleDegrees = radians * 180 / Math.PI;
      if (angleDegrees >= 337.5 || angleDegrees < 22.5) {
        return SpriteDirection.EAST;
      } else if (angleDegrees >= 22.5 && angleDegrees < 67.5) {
        return SpriteDirection.SOUTH_EAST;
      } else if (angleDegrees >= 67.5 && angleDegrees < 112.5) {
        return SpriteDirection.SOUTH;
      } else if (angleDegrees >= 112.5 && angleDegrees < 157.5) {
        return SpriteDirection.SOUTH_WEST;
      } else if (angleDegrees >= 157.5 && angleDegrees < 202.5) {
        return SpriteDirection.WEST;
      } else if (angleDegrees >= 202.5 && angleDegrees < 247.5) {
        return SpriteDirection.NORTH_WEST;
      } else if (angleDegrees >= 247.5 && angleDegrees < 292.5) {
        return SpriteDirection.NORTH;
      } else if (angleDegrees >= 292.5 && angleDegrees < 337.5) {
        return SpriteDirection.NORTH_EAST;
      }
      return SpriteDirection.NORTH;
    }
    /**
     * @private
     */
    chooseRandomDirection() {
      const twoPi2 = 2 * Math.PI;
      const dir = Rand.randomInt(8);
      switch (dir) {
        case 0:
          this.radians = 0;
          this.spriteDirection = SpriteDirection.EAST;
          break;
        case 1:
          this.radians = twoPi2 * (1 / 8);
          this.spriteDirection = SpriteDirection.SOUTH_EAST;
          break;
        case 2:
          this.radians = twoPi2 * (1 / 4);
          this.spriteDirection = SpriteDirection.SOUTH;
          break;
        case 3:
          this.radians = twoPi2 * (3 / 8);
          this.spriteDirection = SpriteDirection.SOUTH_WEST;
          break;
        case 4:
          this.radians = twoPi2 * (1 / 2);
          this.spriteDirection = SpriteDirection.WEST;
          break;
        case 5:
          this.radians = twoPi2 * (5 / 8);
          this.spriteDirection = SpriteDirection.NORTH_WEST;
          break;
        case 6:
          this.radians = twoPi2 * (3 / 4);
          this.spriteDirection = SpriteDirection.NORTH;
          break;
        case 7:
          this.radians = twoPi2 * (7 / 8);
          this.spriteDirection = SpriteDirection.NORTH_EAST;
          break;
      }
    }
  };

  // src/view/canvas/MissilesSkillRenderer.js
  var MissilesSkillRenderer = class extends SkillRenderer {
    /**
     * 
     * @param {Missiles[]} missilesArray 
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet 
     */
    constructor(missilesArray, spellFxSpritesheet) {
      super();
      this.missilesArray = missilesArray;
      this.spellFxSpritesheet = spellFxSpritesheet;
      this.missilesSkillAnimation = null;
      this.skillStart = 0;
      this.missilesExplosionAnimation = null;
    }
    /**
     * @override
     * @param {CanvasRenderingContext2D} context 
     * @param {Projection} projection 
     */
    renderSkill(context, projection) {
      if (this.missilesArray.length === 0) {
        return;
      }
      const now = Date.now();
      if (now - this.skillStart > 1e5) {
        this.skillStart = now;
      }
      if (!this.missilesSkillAnimation) {
        this.missilesSkillAnimation = this.spellFxSpritesheet.getSpriteAnimation(GervaisSpriteNames.MISSILE_EFFECT_NAME_FAT_ARROW);
        this.missilesExplosionAnimation = this.spellFxSpritesheet.getSpriteAnimation(GervaisSpriteNames.DAMAGE_EFFECT_NAME_BLUE_DAMAGE);
      }
      const safeLineWidth = context.lineWidth;
      context.lineWidth = 4;
      context.strokeStyle = "#FFA1";
      for (let i = 0; i < this.missilesArray.length; i++) {
        this.renderMissiles(context, projection, this.missilesArray[i]);
      }
      context.lineWidth = safeLineWidth;
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context 
     * @param {Projection} projection 
     * @param {Missiles} missiles 
     */
    renderMissiles(context, projection, missiles) {
      if (!missiles.skillActive) {
        return;
      }
      const missilesArray = missiles.missiles;
      for (let i = 0; i < missilesArray.length; i++) {
        const missile = missilesArray[i];
        if (!missile || !missile.active) {
          continue;
        }
        const start = missile.startPosition;
        const pos = missile.position;
        context.beginPath();
        projection.worldToScreen(start, this.screenCoordinate);
        context.moveTo(this.screenCoordinate.x, this.screenCoordinate.y);
        this.screenCoordinate.copy(pos);
        projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        context.lineTo(this.screenCoordinate.x, this.screenCoordinate.y);
        context.stroke();
        this.screenCoordinate.copy(pos);
        this.screenCoordinate.subtractXY(Settings.tile.halfSize, Settings.tile.halfSize);
        projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        const sprite = this.missilesSkillAnimation.getDirectionSprite(missile.spriteDirection);
        this.renderSprite(context, projection, sprite, this.screenCoordinate);
      }
      const current = Date.now();
      const explosions = missiles.missileExplosions;
      for (let i = 0; i < explosions.length; i++) {
        const explosion = explosions[i];
        if (!explosion.active) {
          continue;
        }
        const sprite = this.missilesExplosionAnimation.getSlowCurrentSpriteAsOfNoLooping(current, explosion.time);
        if (!sprite) {
          explosion.deactivate();
          continue;
        }
        this.screenCoordinate.copy(explosion.position);
        this.screenCoordinate.subtractXY(Settings.tile.halfSize, Settings.tile.halfSize);
        projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        this.renderSprite(context, projection, sprite, this.screenCoordinate);
      }
    }
  };

  // src/model/skillTree/missile/MoreMissilesSkillNode.js
  var MoreMissilesSkillNode = class extends NumberValueSkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {number} valuePerSkillLevel
     * @param {NumberValue} numberValue
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, valuePerSkillLevel, numberValue) {
      super(
        id,
        "Missiles + " + Settings.skill.missiles.missilesPerUpgrade,
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener,
        valuePerSkillLevel,
        numberValue
      );
    }
    /**
     * @returns {string}
     */
    getDescription() {
      return "Missiles: " + ValueCalculator.getMissileCount(this.numberValue);
    }
  };

  // src/model/skillTree/missile/MissileSkill.js
  var MissileSkill = class extends SkillType {
    /**
     * @param {WorldGrid} worldGrid 
     * @param {Totals} totals
     * @param {TileMinedLogic} tileMinedLogic 
     * @param {Crew} crew
     * @param {VectorField} vectorField
     * @param {Values} values
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet
     */
    constructor(worldGrid, totals, tileMinedLogic, crew, vectorField, values, spellFxSpritesheet) {
      super(SkillIds.MISSILE);
      this.worldGrid = worldGrid;
      this.tileMinedLogic = tileMinedLogic;
      this.vectorField = vectorField;
      this.values = values;
      this.missilesUpgrades = new NumberValue(null, 0);
      this.missilesArray = [];
      this.missilesByCharacter = {};
      this.renderer = new MissilesSkillRenderer(this.missilesArray, spellFxSpritesheet);
      let cost = 1;
      const addMinerNode1 = this.addNode(new AddMinerSkillNode(
        "addMissileMiner1",
        "+1 Missile Miner",
        "Fire volleys of missiles",
        totals,
        Images.skill.missiles,
        new BigNum(cost + Settings.skill.costs.addMissile1),
        this,
        crew,
        SkillIds.MISSILE
      ));
      cost++;
      const missileBonus1 = this.addNode(new MoreMissilesSkillNode(
        "missileBonus1",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.missilesUpgrades
      ));
      const coolBonus1 = this.addNode(new CoolDownSkillNode(
        "missileCool1",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus1 = this.addNode(new DurationSkillNode(
        "missileDur1",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const missileBonus2 = this.addNode(new MoreMissilesSkillNode(
        "missileBonus2",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.missilesUpgrades
      ));
      const coolBonus2 = this.addNode(new CoolDownSkillNode(
        "missileCool2",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus2 = this.addNode(new DurationSkillNode(
        "missileDur2",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const missileBonus3 = this.addNode(new MoreMissilesSkillNode(
        "missileBonus3",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.missilesUpgrades
      ));
      const coolBonus3 = this.addNode(new CoolDownSkillNode(
        "missileCool3",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus3 = this.addNode(new DurationSkillNode(
        "missileDur3",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      const addMinerNode2 = this.addNode(new AddMinerSkillNode(
        "addMissileMiner2",
        "+1 Missile Miner",
        "Fire volleys of missiles",
        totals,
        Images.skill.missiles,
        new BigNum(cost + Settings.skill.costs.addMiner2),
        this,
        crew,
        SkillIds.MISSILE
      ));
      cost++;
      const missileBonus4 = this.addNode(new MoreMissilesSkillNode(
        "missileBonus4",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.missilesUpgrades
      ));
      const coolBonus4 = this.addNode(new CoolDownSkillNode(
        "missileCool4",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus4 = this.addNode(new DurationSkillNode(
        "missileDur4",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const missileBonus5 = this.addNode(new MoreMissilesSkillNode(
        "missileBonus5",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.missilesUpgrades
      ));
      const coolBonus5 = this.addNode(new CoolDownSkillNode(
        "missileCool5",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus5 = this.addNode(new DurationSkillNode(
        "missileDur5",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const missileBonus6 = this.addNode(new MoreMissilesSkillNode(
        "missileBonus6",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.missilesUpgrades
      ));
      const coolBonus6 = this.addNode(new CoolDownSkillNode(
        "missileCool6",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus6 = this.addNode(new DurationSkillNode(
        "missileDur6",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      const addMinerNode3 = this.addNode(new AddMinerSkillNode(
        "addMissileMiner3",
        "+1 Missile Miner",
        "Fire volleys of missiles",
        totals,
        Images.skill.missiles,
        new BigNum(cost + Settings.skill.costs.addMiner3),
        this,
        crew,
        SkillIds.MISSILE
      ));
      cost++;
      const missileBonus7 = this.addNode(new MoreMissilesSkillNode(
        "missileBonus7",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.missilesUpgrades
      ));
      const coolBonus7 = this.addNode(new CoolDownSkillNode(
        "missileCool7",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus7 = this.addNode(new DurationSkillNode(
        "missileDur7",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const missileBonus8 = this.addNode(new MoreMissilesSkillNode(
        "missileBonus8",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.missilesUpgrades
      ));
      const coolBonus8 = this.addNode(new CoolDownSkillNode(
        "missileCool8",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus8 = this.addNode(new DurationSkillNode(
        "missileDur8",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const missileBonus9 = this.addNode(new MoreMissilesSkillNode(
        "missileBonus9",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.missilesUpgrades
      ));
      const coolBonus9 = this.addNode(new CoolDownSkillNode(
        "missileCool9",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus9 = this.addNode(new DurationSkillNode(
        "missileDur9",
        totals,
        Images.skill.missiles,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      const addMinerNode4 = this.addNode(new AddMinerSkillNode(
        "addMissileMiner4",
        "+1 Missile Miner",
        "Fire volleys of missiles",
        totals,
        Images.skill.missiles,
        new BigNum(cost + Settings.skill.costs.addMiner4),
        this,
        crew,
        SkillIds.MISSILE
      ));
      addMinerNode1.addChildNode(missileBonus1);
      missileBonus1.addChildNode(missileBonus2);
      missileBonus2.addChildNode(missileBonus3);
      missileBonus3.addChildNode(missileBonus4);
      missileBonus4.addChildNode(missileBonus5);
      missileBonus5.addChildNode(missileBonus6);
      missileBonus6.addChildNode(missileBonus7);
      missileBonus7.addChildNode(missileBonus8);
      missileBonus8.addChildNode(missileBonus9);
      missileBonus1.addChildNode(coolBonus1);
      missileBonus2.addChildNode(coolBonus2);
      missileBonus3.addChildNode(coolBonus3);
      missileBonus4.addChildNode(coolBonus4);
      missileBonus5.addChildNode(coolBonus5);
      missileBonus6.addChildNode(coolBonus6);
      missileBonus7.addChildNode(coolBonus7);
      missileBonus8.addChildNode(coolBonus8);
      missileBonus9.addChildNode(coolBonus9);
      coolBonus1.addChildNode(durationBonus1);
      coolBonus2.addChildNode(durationBonus2);
      coolBonus3.addChildNode(durationBonus3);
      coolBonus4.addChildNode(durationBonus4);
      coolBonus5.addChildNode(durationBonus5);
      coolBonus6.addChildNode(durationBonus6);
      coolBonus7.addChildNode(durationBonus7);
      coolBonus8.addChildNode(durationBonus8);
      coolBonus9.addChildNode(durationBonus9);
      missileBonus3.addChildNode(addMinerNode2);
      missileBonus6.addChildNode(addMinerNode3);
      missileBonus9.addChildNode(addMinerNode4);
      const startX = 3;
      const startY = -3;
      addMinerNode1.setPosition(startX, startY);
      missileBonus1.setPosition(startX + 1, startY);
      missileBonus2.setPosition(startX + 2, startY);
      missileBonus3.setPosition(startX + 3, startY);
      missileBonus4.setPosition(startX + 4, startY);
      missileBonus5.setPosition(startX + 5, startY);
      missileBonus6.setPosition(startX + 6, startY);
      missileBonus7.setPosition(startX + 7, startY);
      missileBonus8.setPosition(startX + 8, startY);
      missileBonus9.setPosition(startX + 9, startY);
      coolBonus1.setPosition(startX + 1, startY - 1);
      coolBonus2.setPosition(startX + 2, startY - 1);
      coolBonus3.setPosition(startX + 3, startY - 1);
      coolBonus4.setPosition(startX + 4, startY - 1);
      coolBonus5.setPosition(startX + 5, startY - 1);
      coolBonus6.setPosition(startX + 6, startY - 1);
      coolBonus7.setPosition(startX + 7, startY - 1);
      coolBonus8.setPosition(startX + 8, startY - 1);
      coolBonus9.setPosition(startX + 9, startY - 1);
      durationBonus1.setPosition(startX + 1, startY - 2);
      durationBonus2.setPosition(startX + 2, startY - 2);
      durationBonus3.setPosition(startX + 3, startY - 2);
      durationBonus4.setPosition(startX + 4, startY - 2);
      durationBonus5.setPosition(startX + 5, startY - 2);
      durationBonus6.setPosition(startX + 6, startY - 2);
      durationBonus7.setPosition(startX + 7, startY - 2);
      durationBonus8.setPosition(startX + 8, startY - 2);
      durationBonus9.setPosition(startX + 9, startY - 2);
      addMinerNode2.setPosition(startX + 3, startY + 1);
      addMinerNode3.setPosition(startX + 6, startY + 1);
      addMinerNode4.setPosition(startX + 9, startY + 1);
    }
    /**
     * @override
     * @param {PartyCharacter} miner
     * @param {number} frameTimeRatio 
     * @param {boolean} skillActive
     */
    updateSkillForFrame(miner, frameTimeRatio, skillActive) {
      let missiles = this.missilesByCharacter[miner.id];
      if (!missiles) {
        missiles = new Missiles(this.worldGrid, this.vectorField, this.missilesUpgrades, this.tileMinedLogic, this.values);
        this.missilesByCharacter[miner.id] = missiles;
        this.missilesArray.push(missiles);
      }
      if (skillActive && !missiles.skillActive) {
        missiles.onSkillActivation();
      } else if (!skillActive && missiles.skillActive) {
        missiles.onSkillDeactivation();
      }
      if (skillActive) {
        missiles.updateForFrame(miner, frameTimeRatio);
      }
    }
    /**
     * @override
     * @returns {SkillRenderer}
     */
    getRenderer() {
      return this.renderer;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      super.resetFull();
      this.missilesArray.length = 0;
      this.missilesByCharacter = {};
      this.missilesUpgrades.reset();
    }
  };

  // src/model/skillTree/orbit/OrbitPair.js
  var twoPi = 2 * Math.PI;
  var orbitRadiansPerSecond = Math.PI / 50;
  var OrbitPair = class {
    /**
     * @param {WorldGrid} worldGrid
     * @param {TileMinedLogic} tileMinedLogic
     * @param {Character} character 
     * @param {number} maxPixelRange
     */
    constructor(worldGrid, tileMinedLogic, character, maxPixelRange) {
      this.worldGrid = worldGrid;
      this.tileMinedLogic = tileMinedLogic;
      this.character = character;
      this.center = new Vector(0, 0);
      this.range = 0;
      this.radians = 0;
      this.endPoint = new Vector(0, 0);
      this.initialize(maxPixelRange);
    }
    /**
     * @param {number} maxPixelRange 
     */
    onSkillActivation(maxPixelRange) {
      this.initialize(maxPixelRange);
    }
    /**
     * @private
     * @param {number} maxPixelRange 
     */
    initialize(maxPixelRange) {
      this.center.copy(this.character.position.worldCoordinateOrigin);
      this.center.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
      this.range = maxPixelRange;
      SkillUtil.projectPosition(this.center, this.range, this.radians, this.endPoint);
    }
    /**
     * @param {number} frameTimeRatio 
     */
    updateForFrame(frameTimeRatio) {
      this.center.copy(this.character.position.worldCoordinateOrigin);
      this.center.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
      this.radians += frameTimeRatio * orbitRadiansPerSecond;
      if (this.radians > twoPi) {
        this.radians -= twoPi;
      }
      SkillUtil.projectPosition(this.center, this.range, this.radians, this.endPoint);
      const orbTile = this.worldGrid.findGridTile(this.endPoint);
      if (orbTile) {
        if (!orbTile.lighting.everVisibleToCharacter) {
          orbTile.markTileAsCurrentlyVisible();
        }
        if (!orbTile.open) {
          this.tileMinedLogic.orbitTileForFrame(orbTile, frameTimeRatio);
        }
      }
    }
  };

  // src/model/skillTree/orbit/Orbit.js
  var Orbit = class {
    /**
     * @param {WorldGrid} worldGrid
     * @param {NumberValue} orbitRangeUpgrades
     * @param {NumberValue} orbMaxUpgrades
     * @param {TileMinedLogic} tileMinedLogic
     */
    constructor(worldGrid, orbitRangeUpgrades, orbMaxUpgrades, tileMinedLogic) {
      this.worldGrid = worldGrid;
      this.orbitRangeUpgrades = orbitRangeUpgrades;
      this.orbMaxUpgrades = orbMaxUpgrades;
      this.tileMinedLogic = tileMinedLogic;
      this.orbitPairs = [];
      this.lastPairTime = 0;
      this.orbitIntervalMillis = 500;
      this.skillActive = false;
    }
    onSkillActivation() {
      this.skillActive = true;
      const maxPixelRange = Settings.skill.orbit.minRangePixels + this.orbitRangeUpgrades.getValue() * Settings.skill.orbit.rangePixelsPerUpgrade;
      for (let i = 0; i < this.orbitPairs.length; i++) {
        this.orbitPairs[i].onSkillActivation(maxPixelRange);
      }
    }
    onSkillDeactivation() {
      this.skillActive = false;
    }
    /**
     * @param {Character} miner
     * @param {number} frameTimeRatio
     */
    updateForFrame(miner, frameTimeRatio) {
      const pixelRange = Settings.skill.orbit.minRangePixels + this.orbitRangeUpgrades.getValue() * Settings.skill.orbit.rangePixelsPerUpgrade;
      let added = false;
      const maxCount = 1 + this.orbMaxUpgrades.getValue();
      while (this.orbitPairs.length < maxCount) {
        this.orbitPairs.push(new OrbitPair(this.worldGrid, this.tileMinedLogic, miner, pixelRange));
        added = true;
      }
      if (added && this.orbitPairs.length > 1) {
        const radiansStep = 2 * Math.PI / this.orbitPairs.length;
        let radians = 0;
        for (let i = 0; i < this.orbitPairs.length; i++) {
          this.orbitPairs[i].radians = radians;
          radians += radiansStep;
        }
      }
      for (let i = 0; i < this.orbitPairs.length; i++) {
        this.orbitPairs[i].range = pixelRange;
        this.orbitPairs[i].updateForFrame(frameTimeRatio);
      }
    }
  };

  // src/view/canvas/OrbitSkillRenderer.js
  var OrbitSkillRenderer = class extends SkillRenderer {
    /**
     * @param {Orbit[]} orbitArray 
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet 
     */
    constructor(orbitArray, spellFxSpritesheet) {
      super();
      this.orbitArray = orbitArray;
      this.spellFxSpritesheet = spellFxSpritesheet;
      this.skillAnimation = null;
      this.skillStart = Date.now();
    }
    /**
     * @override
     * @param {CanvasRenderingContext2D} context 
     * @param {Projection} projection 
     */
    renderSkill(context, projection) {
      if (this.orbitArray.length === 0) {
        return;
      }
      const safeLineWidth = context.lineWidth;
      context.lineWidth = 4;
      context.strokeStyle = "#AFA1";
      for (let i = 0; i < this.orbitArray.length; i++) {
        this.renderOrbit(context, projection, this.orbitArray[i]);
      }
      context.lineWidth = safeLineWidth;
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context 
     * @param {Projection} projection 
     * @param {Orbit} orbit
     */
    renderOrbit(context, projection, orbit) {
      if (!orbit.skillActive) {
        return;
      }
      const now = Date.now();
      if (now - this.skillStart > 1e5) {
        this.skillStart = now;
      }
      if (!this.skillAnimation) {
        this.skillAnimation = this.spellFxSpritesheet.getSpriteAnimation(GervaisSpriteNames.EFFECT_NAME_ORANGE_STAR);
      }
      const orbitPairs = orbit.orbitPairs;
      for (let i = 0; i < orbitPairs.length; i++) {
        const orbitPair = orbitPairs[i];
        context.beginPath();
        projection.worldToScreen(orbitPair.center, this.screenCoordinate);
        context.moveTo(this.screenCoordinate.x, this.screenCoordinate.y);
        this.screenCoordinate.copy(orbitPair.endPoint);
        this.screenCoordinate.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
        projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        context.lineTo(this.screenCoordinate.x, this.screenCoordinate.y);
        context.stroke();
        this.screenCoordinate.copy(orbitPair.endPoint);
        projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        const sprite = this.skillAnimation.getSpriteAsOf(Date.now(), this.skillStart);
        this.renderSprite(context, projection, sprite, this.screenCoordinate);
      }
    }
  };

  // src/model/skillTree/orbit/OrbitSkill.js
  var OrbitSkill = class extends SkillType {
    /**
     * @param {WorldGrid} worldGrid 
     * @param {Totals} totals
     * @param {TileMinedLogic} tileMinedLogic 
     * @param {Crew} crew
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet
     */
    constructor(worldGrid, totals, tileMinedLogic, crew, spellFxSpritesheet) {
      super(SkillIds.ORBIT);
      this.worldGrid = worldGrid;
      this.tileMinedLogic = tileMinedLogic;
      this.totals = totals;
      this.crew = crew;
      this.orbMaxUpgrades = new NumberValue(null, 0);
      this.orbitRangeUpgrades = new NumberValue(null, 0);
      this.orbitArray = [];
      this.orbitByCharacter = {};
      this.renderer = new OrbitSkillRenderer(this.orbitArray, spellFxSpritesheet);
      let cost = 1;
      const addMinerNode1 = this.addNode(new AddMinerSkillNode(
        "addOrbitMiner1",
        "+1 Orbit Miner",
        "Orbiting Damage",
        totals,
        Images.skill.orbit,
        new BigNum(cost + Settings.skill.costs.addOrbit1),
        this,
        crew,
        SkillIds.ORBIT
      ));
      cost++;
      const orbitRange1 = this.addNode(new NumberValueSkillNode(
        "orbitRange1",
        "+1/2 Tile",
        "Tile Range +0.5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbitRangeUpgrades
      ));
      const orbBonus1 = this.addNode(new NumberValueSkillNode(
        "orbBonus1",
        "+1 Orb",
        "More Orbs",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbMaxUpgrades
      ));
      const coolBonus1 = this.addNode(new CoolDownSkillNode(
        "orbCool1",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus1 = this.addNode(new DurationSkillNode(
        "orbDur1",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const orbitRange2 = this.addNode(new NumberValueSkillNode(
        "orbitRange2",
        "+1/2 Tile",
        "Tile Range +0.5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbitRangeUpgrades
      ));
      const orbBonus2 = this.addNode(new NumberValueSkillNode(
        "orbBonus2",
        "+1 Orb",
        "More Orbs",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbMaxUpgrades
      ));
      const coolBonus2 = this.addNode(new CoolDownSkillNode(
        "orbCool2",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus2 = this.addNode(new DurationSkillNode(
        "orbDur2",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const orbitRange3 = this.addNode(new NumberValueSkillNode(
        "orbitRange3",
        "+1/2 Tile",
        "Tile Range +0.5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbitRangeUpgrades
      ));
      const orbBonus3 = this.addNode(new NumberValueSkillNode(
        "orbBonus3",
        "+1 Orb",
        "More Orbs",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbMaxUpgrades
      ));
      const coolBonus3 = this.addNode(new CoolDownSkillNode(
        "orbCool3",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus3 = this.addNode(new DurationSkillNode(
        "orbDur3",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      const addMinerNode2 = this.addNode(new AddMinerSkillNode(
        "addOrbitMiner2",
        "+1 Orbit Miner",
        "Orbiting Damage",
        totals,
        Images.skill.orbit,
        new BigNum(cost + Settings.skill.costs.addMiner2),
        this,
        crew,
        SkillIds.ORBIT
      ));
      cost++;
      const orbitRange4 = this.addNode(new NumberValueSkillNode(
        "orbitRange4",
        "+1/2 Tile",
        "Tile Range +0.5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbitRangeUpgrades
      ));
      const orbBonus4 = this.addNode(new NumberValueSkillNode(
        "orbBonus4",
        "+1 Orb",
        "More Orbs",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbMaxUpgrades
      ));
      const coolBonus4 = this.addNode(new CoolDownSkillNode(
        "orbCool4",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus4 = this.addNode(new DurationSkillNode(
        "orbDur4",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const orbitRange5 = this.addNode(new NumberValueSkillNode(
        "orbitRange5",
        "+1/2 Tile",
        "Tile Range +0.5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbitRangeUpgrades
      ));
      const orbBonus5 = this.addNode(new NumberValueSkillNode(
        "orbBonus5",
        "+1 Orb",
        "More Orbs",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbMaxUpgrades
      ));
      const coolBonus5 = this.addNode(new CoolDownSkillNode(
        "orbCool5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus5 = this.addNode(new DurationSkillNode(
        "orbDur5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const orbitRange6 = this.addNode(new NumberValueSkillNode(
        "orbitRange6",
        "+1/2 Tile",
        "Tile Range +0.5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbitRangeUpgrades
      ));
      const orbBonus6 = this.addNode(new NumberValueSkillNode(
        "orbBonus6",
        "+1 Orb",
        "More Orbs",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbMaxUpgrades
      ));
      const coolBonus6 = this.addNode(new CoolDownSkillNode(
        "orbCool6",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus6 = this.addNode(new DurationSkillNode(
        "orbDur6",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      const addMinerNode3 = this.addNode(new AddMinerSkillNode(
        "addOrbitMiner3",
        "+1 Orbit Miner",
        "Orbiting Damage",
        totals,
        Images.skill.orbit,
        new BigNum(cost + Settings.skill.costs.addMiner3),
        this,
        crew,
        SkillIds.ORBIT
      ));
      cost++;
      const orbitRange7 = this.addNode(new NumberValueSkillNode(
        "orbitRange7",
        "+1/2 Tile",
        "Tile Range +0.5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbitRangeUpgrades
      ));
      const orbBonus7 = this.addNode(new NumberValueSkillNode(
        "orbBonus7",
        "+1 Orb",
        "More Orbs",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbMaxUpgrades
      ));
      const coolBonus7 = this.addNode(new CoolDownSkillNode(
        "orbCool7",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus7 = this.addNode(new DurationSkillNode(
        "orbDur7",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const orbitRange8 = this.addNode(new NumberValueSkillNode(
        "orbitRange8",
        "+1/2 Tile",
        "Tile Range +0.5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbitRangeUpgrades
      ));
      const orbBonus8 = this.addNode(new NumberValueSkillNode(
        "orbBonus8",
        "+1 Orb",
        "More Orbs",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbMaxUpgrades
      ));
      const coolBonus8 = this.addNode(new CoolDownSkillNode(
        "orbCool8",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const durationBonus8 = this.addNode(new DurationSkillNode(
        "orbDur8",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      cost++;
      const orbitRange9 = this.addNode(new NumberValueSkillNode(
        "orbitRange9",
        "+1/2 Tile",
        "Tile Range +0.5",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbitRangeUpgrades
      ));
      const coolBonus9 = this.addNode(new CoolDownSkillNode(
        "orbCool9",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.coolDownUpgrades
      ));
      const orbBonus9 = this.addNode(new NumberValueSkillNode(
        "orbBonus9",
        "+1 Orb",
        "More Orbs",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.orbMaxUpgrades
      ));
      const durationBonus9 = this.addNode(new DurationSkillNode(
        "orbDur9",
        totals,
        Images.skill.orbit,
        new BigNum(cost),
        this,
        1,
        this.durationUpgrades
      ));
      const addMinerNode4 = this.addNode(new AddMinerSkillNode(
        "addOrbitMiner4",
        "+1 Orbit Miner",
        "Orbiting Damage",
        totals,
        Images.skill.orbit,
        new BigNum(cost + Settings.skill.costs.addMiner4),
        this,
        crew,
        SkillIds.ORBIT
      ));
      addMinerNode1.addChildNode(orbBonus1);
      orbBonus1.addChildNode(orbBonus2);
      orbBonus2.addChildNode(orbBonus3);
      orbBonus3.addChildNode(orbBonus4);
      orbBonus4.addChildNode(orbBonus5);
      orbBonus5.addChildNode(orbBonus6);
      orbBonus6.addChildNode(orbBonus7);
      orbBonus7.addChildNode(orbBonus8);
      orbBonus8.addChildNode(orbBonus9);
      orbBonus1.addChildNode(coolBonus1);
      orbBonus2.addChildNode(coolBonus2);
      orbBonus3.addChildNode(coolBonus3);
      orbBonus4.addChildNode(coolBonus4);
      orbBonus5.addChildNode(coolBonus5);
      orbBonus6.addChildNode(coolBonus6);
      orbBonus7.addChildNode(coolBonus7);
      orbBonus8.addChildNode(coolBonus8);
      orbBonus9.addChildNode(coolBonus9);
      coolBonus1.addChildNode(durationBonus1);
      coolBonus2.addChildNode(durationBonus2);
      coolBonus3.addChildNode(durationBonus3);
      coolBonus4.addChildNode(durationBonus4);
      coolBonus5.addChildNode(durationBonus5);
      coolBonus6.addChildNode(durationBonus6);
      coolBonus7.addChildNode(durationBonus7);
      coolBonus8.addChildNode(durationBonus8);
      coolBonus9.addChildNode(durationBonus9);
      durationBonus1.addChildNode(orbitRange1);
      durationBonus2.addChildNode(orbitRange2);
      durationBonus3.addChildNode(orbitRange3);
      durationBonus4.addChildNode(orbitRange4);
      durationBonus5.addChildNode(orbitRange5);
      durationBonus6.addChildNode(orbitRange6);
      durationBonus7.addChildNode(orbitRange7);
      durationBonus8.addChildNode(orbitRange8);
      durationBonus9.addChildNode(orbitRange9);
      orbBonus3.addChildNode(addMinerNode2);
      orbBonus6.addChildNode(addMinerNode3);
      orbBonus9.addChildNode(addMinerNode4);
      const startX = 3;
      const startY = 3;
      addMinerNode1.setPosition(startX, startY);
      orbBonus1.setPosition(startX + 1, startY);
      orbBonus2.setPosition(startX + 2, startY);
      orbBonus3.setPosition(startX + 3, startY);
      orbBonus4.setPosition(startX + 4, startY);
      orbBonus5.setPosition(startX + 5, startY);
      orbBonus6.setPosition(startX + 6, startY);
      orbBonus7.setPosition(startX + 7, startY);
      orbBonus8.setPosition(startX + 8, startY);
      orbBonus9.setPosition(startX + 9, startY);
      coolBonus1.setPosition(startX + 1, startY - 1);
      coolBonus2.setPosition(startX + 2, startY - 1);
      coolBonus3.setPosition(startX + 3, startY - 1);
      coolBonus4.setPosition(startX + 4, startY - 1);
      coolBonus5.setPosition(startX + 5, startY - 1);
      coolBonus6.setPosition(startX + 6, startY - 1);
      coolBonus7.setPosition(startX + 7, startY - 1);
      coolBonus8.setPosition(startX + 8, startY - 1);
      coolBonus9.setPosition(startX + 9, startY - 1);
      durationBonus1.setPosition(startX + 1, startY - 2);
      durationBonus2.setPosition(startX + 2, startY - 2);
      durationBonus3.setPosition(startX + 3, startY - 2);
      durationBonus4.setPosition(startX + 4, startY - 2);
      durationBonus5.setPosition(startX + 5, startY - 2);
      durationBonus6.setPosition(startX + 6, startY - 2);
      durationBonus7.setPosition(startX + 7, startY - 2);
      durationBonus8.setPosition(startX + 8, startY - 2);
      durationBonus9.setPosition(startX + 9, startY - 2);
      orbitRange1.setPosition(startX + 1, startY - 3);
      orbitRange2.setPosition(startX + 2, startY - 3);
      orbitRange3.setPosition(startX + 3, startY - 3);
      orbitRange4.setPosition(startX + 4, startY - 3);
      orbitRange5.setPosition(startX + 5, startY - 3);
      orbitRange6.setPosition(startX + 6, startY - 3);
      orbitRange7.setPosition(startX + 7, startY - 3);
      orbitRange8.setPosition(startX + 8, startY - 3);
      orbitRange9.setPosition(startX + 9, startY - 3);
      addMinerNode2.setPosition(startX + 3, startY + 1);
      addMinerNode3.setPosition(startX + 6, startY + 1);
      addMinerNode4.setPosition(startX + 9, startY + 1);
    }
    /**
     * @override
     * @param {PartyCharacter} miner
     * @param {number} frameTimeRatio 
     * @param {boolean} skillActive
     */
    updateSkillForFrame(miner, frameTimeRatio, skillActive) {
      let orbit = this.orbitByCharacter[miner.id];
      if (!orbit) {
        orbit = new Orbit(this.worldGrid, this.orbitRangeUpgrades, this.orbMaxUpgrades, this.tileMinedLogic);
        this.orbitByCharacter[miner.id] = orbit;
        this.orbitArray.push(orbit);
      }
      if (skillActive && !orbit.skillActive) {
        orbit.onSkillActivation();
      } else if (!skillActive && orbit.skillActive) {
        orbit.onSkillDeactivation();
      }
      if (skillActive) {
        orbit.updateForFrame(miner, frameTimeRatio);
      }
    }
    /**
     * @override
     * @returns {SkillRenderer}
     */
    getRenderer() {
      return this.renderer;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      super.resetFull();
      this.orbitArray.length = 0;
      this.orbitByCharacter = {};
      this.orbMaxUpgrades.reset();
      this.orbitRangeUpgrades.reset();
    }
  };

  // src/model/skillTree/SkillActivationTimer.js
  var SkillActivationTimer = class {
    /**
     * @param {NumberValue} durationUpgrades
     * @param {NumberValue} coolDownUpgrades
     */
    constructor(durationUpgrades, coolDownUpgrades) {
      this.durationUpgrades = durationUpgrades;
      this.coolDownUpgrades = coolDownUpgrades;
      this.skillActive = false;
      this.startTurn = 0;
    }
    /**
     * @param {number} turnNumber
     * @param {number} offset 
     */
    initialize(turnNumber, offset) {
      this.skillActive = false;
      this.startTurn = turnNumber - ValueCalculator.getSkillCoolDownTurns(this.coolDownUpgrades) + offset;
    }
    /**
     * @param {number} turnNumber 
     */
    updateForTurn(turnNumber) {
      const elapsedTurns = turnNumber - this.startTurn;
      if (this.skillActive) {
        this.skillActive = elapsedTurns < ValueCalculator.getSkillActivationTurns(this.durationUpgrades);
      } else if (elapsedTurns > ValueCalculator.getSkillCoolDownTurns(this.coolDownUpgrades)) {
        this.startTurn = turnNumber;
        this.skillActive = true;
      }
    }
    /**
     * @returns {boolean}
     */
    isSkillActive() {
      return this.skillActive;
    }
  };

  // src/model/skillTree/SkillActivationTracker.js
  var SkillActivationTracker = class {
    /**
     * 
     * @param {number} groupOffset 
     * @param {NumberValue} durationUpgrades
     * @param {NumberValue} coolDownUpgrades
     */
    constructor(groupOffset, durationUpgrades, coolDownUpgrades) {
      this.groupOffset = groupOffset;
      this.durationUpgrades = durationUpgrades;
      this.coolDownUpgrades = coolDownUpgrades;
      this.staggeredTurns = Settings.time.turnsPerSecond * 20;
      this.activationTimers = [];
    }
    /**
     * @param {number} turnNumber
     * @param {number} minerCount 
     */
    setMinerCount(turnNumber, minerCount) {
      while (this.activationTimers.length < minerCount) {
        this.activationTimers.push(new SkillActivationTimer(this.durationUpgrades, this.coolDownUpgrades));
      }
      this.initializeTimers(turnNumber);
    }
    /**
     * @private
     * @param {number} turnNumber 
     */
    initializeTimers(turnNumber) {
      let minerOffset = 0;
      for (let i = 0; i < this.activationTimers.length; i++) {
        this.activationTimers[i].initialize(turnNumber, this.groupOffset + minerOffset);
        minerOffset += this.staggeredTurns;
      }
    }
    /**
     * 
     * @param {number} turnNumber 
     */
    updateForTurn(turnNumber) {
      for (let i = 0; i < this.activationTimers.length; i++) {
        this.activationTimers[i].updateForTurn(turnNumber);
      }
    }
    /**
     * @param {number} minerIndex 
     * @returns {boolean}
     */
    isSkillActive(minerIndex) {
      return this.activationTimers[minerIndex].isSkillActive();
    }
    resetForPrestige() {
      this.initializeTimers(0);
    }
  };

  // src/model/skillTree/SkillGroup.js
  var SkillGroup = class {
    /**
     * 
     * @param {GameTime} gameTime
     * @param {SkillType} skillType 
     * @param {number} groupOffset
     */
    constructor(gameTime, skillType, groupOffset) {
      this.gameTime = gameTime;
      this.skillType = skillType;
      this.miners = [];
      this.skillActivationTracker = new SkillActivationTracker(groupOffset, skillType.durationUpgrades, skillType.coolDownUpgrades);
    }
    /**
     * @param {PartyCharacter} miner 
     */
    addMiner(miner) {
      this.miners.push(miner);
      this.skillActivationTracker.setMinerCount(this.gameTime.turnNumber, this.miners.length);
    }
    /**
     * @param {number} turnNumber
     */
    updateSkillsForTurn(turnNumber) {
      this.skillActivationTracker.updateForTurn(turnNumber);
    }
    /**
     * @param {number} frameTimeRatio 
     */
    updateSkillsForFrame(frameTimeRatio) {
      for (let i = 0; i < this.miners.length; i++) {
        this.skillType.updateSkillForFrame(this.miners[i], frameTimeRatio, this.skillActivationTracker.isSkillActive(i));
      }
    }
    resetForPrestige() {
      this.skillActivationTracker.resetForPrestige();
    }
  };

  // src/model/skillTree/bonus/FallSpeedBonusSkillNode.js
  var FallSpeedBonusSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {Values} values
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, values) {
      super(
        id,
        "Fall Speed +" + NumberFormatter.formatNumber(Settings.skill.bonus.fallSpeedMuliplierPerUgrade),
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener
      );
      this.values = values;
    }
    /**
     * @returns {string}
     */
    getDescription() {
      const speedMultiplier = 1 + this.values.fallSpeedUpgrades.getValue() * Settings.skill.bonus.fallSpeedMuliplierPerUgrade;
      return "FallSpeed: x" + NumberFormatter.formatNumber(speedMultiplier);
    }
    /**
     * @override
     */
    onPurchase() {
      if (super.onPurchase()) {
        this.applyUpgrade();
        return true;
      } else {
        return false;
      }
    }
    /**
     * @override
     */
    onPurchaseFromSave() {
      this.applyUpgrade();
      super.onPurchaseFromSave();
    }
    /**
     * @private
     */
    applyUpgrade() {
      this.values.fallSpeedUpgrades.incrementValue(1);
    }
  };

  // src/model/skillTree/bonus/FallSpeedBonusSkill.js
  var FallSpeedBonusSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     */
    constructor(totals, values) {
      super(SkillIds.FALL_BONUS);
      this.values = values;
      const inc = 15;
      let cost = 75;
      const fallBonus1 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus1",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus2 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus2",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus3 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus3",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus4 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus4",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus5 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus5",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus6 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus6",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus7 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus7",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus8 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus8",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus9 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus9",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus10 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus10",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus11 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus11",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus12 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus12",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus13 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus13",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus14 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus14",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus15 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus15",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus16 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus16",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus17 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus17",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus18 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus18",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus19 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus19",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus20 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus20",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      cost += inc;
      const fallBonus21 = this.addNode(new FallSpeedBonusSkillNode(
        "fallBonus21",
        totals,
        Images.offline,
        new BigNum(cost),
        this,
        this.values
      ));
      fallBonus1.addChildNode(fallBonus2);
      fallBonus2.addChildNode(fallBonus3);
      fallBonus3.addChildNode(fallBonus4);
      fallBonus4.addChildNode(fallBonus5);
      fallBonus5.addChildNode(fallBonus6);
      fallBonus6.addChildNode(fallBonus7);
      fallBonus7.addChildNode(fallBonus8);
      fallBonus8.addChildNode(fallBonus9);
      fallBonus9.addChildNode(fallBonus10);
      fallBonus10.addChildNode(fallBonus11);
      fallBonus11.addChildNode(fallBonus12);
      fallBonus12.addChildNode(fallBonus13);
      fallBonus13.addChildNode(fallBonus14);
      fallBonus14.addChildNode(fallBonus15);
      fallBonus15.addChildNode(fallBonus16);
      fallBonus16.addChildNode(fallBonus17);
      fallBonus17.addChildNode(fallBonus18);
      fallBonus18.addChildNode(fallBonus19);
      fallBonus19.addChildNode(fallBonus20);
      fallBonus20.addChildNode(fallBonus21);
      const startX = 4;
      const startY = -15;
      fallBonus1.setPosition(startX, startY);
      fallBonus2.setPosition(startX + 1, startY);
      fallBonus3.setPosition(startX + 2, startY);
      fallBonus4.setPosition(startX + 3, startY);
      fallBonus5.setPosition(startX + 4, startY);
      fallBonus6.setPosition(startX + 5, startY);
      fallBonus7.setPosition(startX + 6, startY);
      fallBonus8.setPosition(startX + 6, startY - 1);
      fallBonus9.setPosition(startX + 5, startY - 1);
      fallBonus10.setPosition(startX + 4, startY - 1);
      fallBonus11.setPosition(startX + 3, startY - 1);
      fallBonus12.setPosition(startX + 2, startY - 1);
      fallBonus13.setPosition(startX + 1, startY - 1);
      fallBonus14.setPosition(startX, startY - 1);
      fallBonus15.setPosition(startX, startY - 2);
      fallBonus16.setPosition(startX + 1, startY - 2);
      fallBonus17.setPosition(startX + 2, startY - 2);
      fallBonus18.setPosition(startX + 3, startY - 2);
      fallBonus19.setPosition(startX + 4, startY - 2);
      fallBonus20.setPosition(startX + 5, startY - 2);
      fallBonus21.setPosition(startX + 6, startY - 2);
    }
  };

  // src/model/skillTree/bonus/RubyBonusSkillNode.js
  var RubyBonusSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     * @param {number} purchaseIndex Starts at 0
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, values, mineDamageLogic, purchaseIndex) {
      super(
        id,
        "Ruby +" + NumberFormatter.formatNumber(Settings.ruby.baseBonusPerUpgrade + Settings.ruby.incrementBonusPerUpgrade * purchaseIndex),
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener
      );
      this.values = values;
      this.mineDamageLogic = mineDamageLogic;
      this.purchaseIndex = purchaseIndex;
    }
    // 
    /**
     * @returns {string}
     */
    getDescription() {
      const bonus = this.values.skillRubyBonusMultiplier.getValue() + Settings.ruby.multiplierPerRuby;
      return "Damage / Ruby: " + NumberFormatter.formatNumber(bonus);
    }
    /**
     * @override
     */
    onPurchase() {
      if (super.onPurchase()) {
        this.applyUpgrade();
        this.mineDamageLogic.calculateTotalMineDamagePerTurn();
        return true;
      } else {
        return false;
      }
    }
    /**
     * @override
     */
    onPurchaseFromSave() {
      this.applyUpgrade();
      super.onPurchaseFromSave();
    }
    /**
     * @private
     */
    applyUpgrade() {
      const bonus = Settings.ruby.baseBonusPerUpgrade + Settings.ruby.incrementBonusPerUpgrade * this.purchaseIndex;
      this.values.skillRubyBonusMultiplier.incrementValue(bonus);
    }
  };

  // src/model/skillTree/bonus/RubyBonusSkill.js
  var RubyBonusSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     */
    constructor(totals, values, mineDamageLogic) {
      super(SkillIds.RUBY_BONUS);
      this.values = values;
      const inc = 50;
      let cost = 200;
      let purchaseIndex = 0;
      const rubyBonus1 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus1",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus2 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus2",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus3 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus3",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus4 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus4",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus5 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus5",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus6 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus6",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus7 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus7",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus8 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus8",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus9 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus9",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus10 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus10",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus11 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus11",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus12 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus12",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus13 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus13",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus14 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus14",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus15 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus15",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus16 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus16",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus17 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus17",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus18 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus18",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus19 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus19",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus20 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus20",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const rubyBonus21 = this.addNode(new RubyBonusSkillNode(
        "rubyBonus21",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      rubyBonus1.addChildNode(rubyBonus2);
      rubyBonus2.addChildNode(rubyBonus3);
      rubyBonus3.addChildNode(rubyBonus4);
      rubyBonus4.addChildNode(rubyBonus5);
      rubyBonus5.addChildNode(rubyBonus6);
      rubyBonus6.addChildNode(rubyBonus7);
      rubyBonus7.addChildNode(rubyBonus8);
      rubyBonus8.addChildNode(rubyBonus9);
      rubyBonus9.addChildNode(rubyBonus10);
      rubyBonus10.addChildNode(rubyBonus11);
      rubyBonus11.addChildNode(rubyBonus12);
      rubyBonus12.addChildNode(rubyBonus13);
      rubyBonus13.addChildNode(rubyBonus14);
      rubyBonus14.addChildNode(rubyBonus15);
      rubyBonus15.addChildNode(rubyBonus16);
      rubyBonus16.addChildNode(rubyBonus17);
      rubyBonus17.addChildNode(rubyBonus18);
      rubyBonus18.addChildNode(rubyBonus19);
      rubyBonus19.addChildNode(rubyBonus20);
      rubyBonus20.addChildNode(rubyBonus21);
      const startX = -1;
      const startY = -12;
      rubyBonus1.setPosition(startX, startY);
      rubyBonus2.setPosition(startX - 1, startY);
      rubyBonus3.setPosition(startX - 2, startY);
      rubyBonus4.setPosition(startX - 3, startY);
      rubyBonus5.setPosition(startX - 4, startY);
      rubyBonus6.setPosition(startX - 5, startY);
      rubyBonus7.setPosition(startX - 6, startY);
      rubyBonus8.setPosition(startX - 6, startY - 1);
      rubyBonus9.setPosition(startX - 5, startY - 1);
      rubyBonus10.setPosition(startX - 4, startY - 1);
      rubyBonus11.setPosition(startX - 3, startY - 1);
      rubyBonus12.setPosition(startX - 2, startY - 1);
      rubyBonus13.setPosition(startX - 1, startY - 1);
      rubyBonus14.setPosition(startX, startY - 1);
      rubyBonus15.setPosition(startX, startY - 2);
      rubyBonus16.setPosition(startX - 1, startY - 2);
      rubyBonus17.setPosition(startX - 2, startY - 2);
      rubyBonus18.setPosition(startX - 3, startY - 2);
      rubyBonus19.setPosition(startX - 4, startY - 2);
      rubyBonus20.setPosition(startX - 5, startY - 2);
      rubyBonus21.setPosition(startX - 6, startY - 2);
    }
  };

  // src/model/skillTree/bonus/BlocksBonusSkillNode.js
  var BlocksBonusSkillNode = class extends SkillNode {
    /**
     * @param {string} id 
     * @param {string} description 
     * @param {Totals} totals
     * @param {string} iconFileName 
     * @param {BigNum} cost 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     * @param {number} purchaseIndex Starts at 0
     */
    constructor(id, totals, iconFileName, cost, purchaseListener, values, mineDamageLogic, purchaseIndex) {
      super(
        id,
        "Mined Blocks +" + NumberFormatter.formatNumber(Settings.blocks.baseBonusPerUpgrade + Settings.blocks.incrementBonusPerUpgrade * purchaseIndex),
        null,
        totals,
        iconFileName,
        cost,
        purchaseListener
      );
      this.values = values;
      this.mineDamageLogic = mineDamageLogic;
      this.purchaseIndex = purchaseIndex;
    }
    // 
    /**
     * @returns {string}
     */
    getDescription() {
      const bonus = this.values.skillBlockBonusMultiplier.getValue() + Settings.blocks.multiplierPerBlock;
      return "Damage / Block: " + NumberFormatter.formatNumber(bonus);
    }
    /**
     * @override
     */
    onPurchase() {
      if (super.onPurchase()) {
        this.applyUpgrade();
        this.mineDamageLogic.calculateTotalMineDamagePerTurn();
        return true;
      } else {
        return false;
      }
    }
    /**
     * @override
     */
    onPurchaseFromSave() {
      this.applyUpgrade();
      super.onPurchaseFromSave();
    }
    /**
     * @private
     */
    applyUpgrade() {
      const bonus = Settings.blocks.baseBonusPerUpgrade + Settings.blocks.incrementBonusPerUpgrade * this.purchaseIndex;
      this.values.skillBlockBonusMultiplier.incrementValue(bonus);
    }
  };

  // src/model/skillTree/bonus/BlocksBonusSkill.js
  var BlocksBonusSkill = class extends SkillType {
    /**
     * @param {Totals} totals
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     */
    constructor(totals, values, mineDamageLogic) {
      super(SkillIds.BLOCKS_BONUS);
      this.values = values;
      const inc = 250;
      let cost = 500;
      let purchaseIndex = 0;
      const blocksBonus1 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus1",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus2 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus2",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus3 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus3",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus4 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus4",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus5 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus5",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus6 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus6",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus7 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus7",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus8 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus8",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus9 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus9",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus10 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus10",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus11 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus11",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus12 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus12",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus13 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus13",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus14 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus14",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus15 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus15",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus16 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus16",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus17 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus17",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus18 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus18",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus19 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus19",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus20 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus20",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      cost += inc;
      purchaseIndex++;
      const blocksBonus21 = this.addNode(new BlocksBonusSkillNode(
        "blocksBonus21",
        totals,
        Images.currency.ruby,
        new BigNum(cost),
        this,
        this.values,
        mineDamageLogic,
        purchaseIndex
      ));
      blocksBonus1.addChildNode(blocksBonus2);
      blocksBonus2.addChildNode(blocksBonus3);
      blocksBonus3.addChildNode(blocksBonus4);
      blocksBonus4.addChildNode(blocksBonus5);
      blocksBonus5.addChildNode(blocksBonus6);
      blocksBonus6.addChildNode(blocksBonus7);
      blocksBonus7.addChildNode(blocksBonus8);
      blocksBonus8.addChildNode(blocksBonus9);
      blocksBonus9.addChildNode(blocksBonus10);
      blocksBonus10.addChildNode(blocksBonus11);
      blocksBonus11.addChildNode(blocksBonus12);
      blocksBonus12.addChildNode(blocksBonus13);
      blocksBonus13.addChildNode(blocksBonus14);
      blocksBonus14.addChildNode(blocksBonus15);
      blocksBonus15.addChildNode(blocksBonus16);
      blocksBonus16.addChildNode(blocksBonus17);
      blocksBonus17.addChildNode(blocksBonus18);
      blocksBonus18.addChildNode(blocksBonus19);
      blocksBonus19.addChildNode(blocksBonus20);
      blocksBonus20.addChildNode(blocksBonus21);
      const startX = -1;
      const startY = -16;
      blocksBonus1.setPosition(startX, startY);
      blocksBonus2.setPosition(startX - 1, startY);
      blocksBonus3.setPosition(startX - 2, startY);
      blocksBonus4.setPosition(startX - 3, startY);
      blocksBonus5.setPosition(startX - 4, startY);
      blocksBonus6.setPosition(startX - 5, startY);
      blocksBonus7.setPosition(startX - 6, startY);
      blocksBonus8.setPosition(startX - 6, startY - 1);
      blocksBonus9.setPosition(startX - 5, startY - 1);
      blocksBonus10.setPosition(startX - 4, startY - 1);
      blocksBonus11.setPosition(startX - 3, startY - 1);
      blocksBonus12.setPosition(startX - 2, startY - 1);
      blocksBonus13.setPosition(startX - 1, startY - 1);
      blocksBonus14.setPosition(startX, startY - 1);
      blocksBonus15.setPosition(startX, startY - 2);
      blocksBonus16.setPosition(startX - 1, startY - 2);
      blocksBonus17.setPosition(startX - 2, startY - 2);
      blocksBonus18.setPosition(startX - 3, startY - 2);
      blocksBonus19.setPosition(startX - 4, startY - 2);
      blocksBonus20.setPosition(startX - 5, startY - 2);
      blocksBonus21.setPosition(startX - 6, startY - 2);
    }
  };

  // src/model/skillTree/SkillTreeGraph.js
  var SkillTreeGraph = class extends GameModel {
    /**
     * @param {GameTime} gameTime
     * @param {WorldGrid} worldGrid 
     * @param {Totals} totals
     * @param {Values} values
     * @param {TileMinedLogic} tileMinedLogic 
     * @param {MineDamageLogic} mineDamageLogic
     * @param {Crew} crew
     * @param {VectorField} vectorField
     * @param {GervaisAnimatedSpritesheet} spellFxSpritesheet
     */
    constructor(gameTime, worldGrid, totals, values, tileMinedLogic, mineDamageLogic, crew, vectorField, spellFxSpritesheet) {
      super();
      this.gameTime = gameTime;
      this.skills = [];
      this.skillById = {};
      this.skillGroups = [];
      this.skillGroupMinerCount = -1;
      this.crew = crew;
      this.centerOffset = new Vector(0, 0);
      this.zoom = 100;
      this.addSkill(new MissileSkill(worldGrid, totals, tileMinedLogic, crew, vectorField, values, spellFxSpritesheet));
      this.addSkill(new LaserSkill(worldGrid, totals, tileMinedLogic, crew, gameTime, spellFxSpritesheet, vectorField));
      this.addSkill(new DrillSkill(worldGrid, totals, tileMinedLogic, crew, spellFxSpritesheet));
      this.addSkill(new OrbitSkill(worldGrid, totals, tileMinedLogic, crew, spellFxSpritesheet));
      this.addSkill(new OreBonusSkill(totals, values));
      this.addSkill(new PrestigeBonusSkill(totals, values, mineDamageLogic));
      this.addSkill(new DepthBonusSkill(totals, values, mineDamageLogic));
      this.addSkill(new RubyBonusSkill(totals, values, mineDamageLogic));
      this.addSkill(new BlocksBonusSkill(totals, values, mineDamageLogic));
      this.addSkill(new OfflineBonusSkill(totals, values));
      this.addSkill(new FallSpeedBonusSkill(totals, values));
      this.addSkill(new MinedDamageBonusSkill(totals, values));
      this.addSkill(new MinedUpgradeAutomationSkill(totals, values));
      this.addSkill(new PickUpgradeAutomationSkill(totals, values));
      this.addSkill(new PrestigeAutomationSkill(totals, values));
    }
    /**
     * @param {number} deltaX 
     * @param {number} deltaY 
     */
    updateCenter(deltaX, deltaY) {
      const zoomFactor = this.zoom / 100;
      const dx = deltaX / zoomFactor;
      const dy = deltaY / zoomFactor;
      this.centerOffset.addXY(dx, dy);
    }
    /**
     * @private
     * @param {SkillType} skill 
     */
    addSkill(skill) {
      this.skills.push(skill);
      this.skillById[skill.id] = skill;
    }
    /**
     * @param {string} id 
     * @returns {SkillType}
     */
    findSkillById(id) {
      return this.skillById[id];
    }
    /**
     * @private
     * @param {string} skillId 
     * @returns {SkillGroup}
     */
    findSkillGroupById(skillId) {
      for (let i = 0; i < this.skillGroups.length; i++) {
        const skillGroup = this.skillGroups[i];
        if (skillId === skillGroup.skillType.id) {
          return skillGroup;
        }
      }
      return null;
    }
    /**
     * Rebuilds the skill groups.  This is invoked whenever a new miner is added to the party.
     */
    rebuildSkillGroups() {
      this.skillGroups.length = 0;
      const miners = this.crew.miners;
      let groupOffset = 0;
      for (let i = 0; i < miners.length; i++) {
        const miner = miners[i];
        const skillId = miner.skillId;
        if (!skillId) {
          continue;
        }
        let skillGroup = this.findSkillGroupById(skillId);
        if (!skillGroup) {
          const skillType = this.findSkillById(skillId);
          if (!skillType) {
            console.log("SkillTreeGraph.rebuildSkillGroups() Failed to find skill: " + skillId);
            continue;
          }
          skillGroup = new SkillGroup(this.gameTime, skillType, groupOffset);
          this.skillGroups.push(skillGroup);
          groupOffset += Settings.time.turnsPerSecond * 5;
        }
        skillGroup.addMiner(miner);
      }
    }
    updateSkillsForTurn() {
      this.assertMinerCountMatchesSkillGroups();
      const turnNumber = this.gameTime.turnNumber;
      for (let i = 0; i < this.skillGroups.length; i++) {
        this.skillGroups[i].updateSkillsForTurn(turnNumber);
      }
    }
    /**
     * @param {number} frameTimeRatio 
     */
    updateSkillsForFrame(frameTimeRatio) {
      this.assertMinerCountMatchesSkillGroups();
      for (let i = 0; i < this.skillGroups.length; i++) {
        this.skillGroups[i].updateSkillsForFrame(frameTimeRatio);
      }
    }
    /**
     * @private
     */
    assertMinerCountMatchesSkillGroups() {
      const miners = this.crew.miners;
      if (this.skillGroupMinerCount != miners.length) {
        this.skillGroupMinerCount = miners.length;
        this.rebuildSkillGroups();
      }
    }
    /**
     * @param {number} zoom 
     */
    setZoom(zoom) {
      this.zoom = zoom;
      if (this.zoom < Settings.skillGraph.minZoom) {
        this.zoom = Settings.skillGraph.minZoom;
      }
      if (this.zoom > Settings.skillGraph.maxZoom) {
        this.zoom = Settings.skillGraph.maxZoom;
      }
    }
    zoomOut() {
      this.zoom -= Settings.skillGraph.zoomStep;
      if (this.zoom < Settings.skillGraph.minZoom) {
        this.zoom = Settings.skillGraph.minZoom;
      }
    }
    zoomIn() {
      this.zoom += Settings.skillGraph.zoomStep;
      if (this.zoom > Settings.skillGraph.maxZoom) {
        this.zoom = Settings.skillGraph.maxZoom;
      }
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      for (let i = 0; i < this.skills.length; i++) {
        this.skills[i].resetFull();
      }
      this.skillGroups.length = 0;
    }
    /**
     * @override
     */
    resetForPrestige() {
      for (let i = 0; i < this.skillGroups.length; i++) {
        this.skillGroups[i].resetForPrestige();
      }
    }
  };

  // src/model/save/SkillTreeSave.js
  var SkillTreeSave = class {
    constructor() {
    }
    /**
     * @param {SkillTreeGraph} skillTree
     * @returns {Object}
     */
    static generateSave(skillTree) {
      const saveState = {};
      saveState.skills = [];
      for (let i = 0; i < skillTree.skills.length; i++) {
        saveState.skills.push(this.generateSkillSave(skillTree.skills[i]));
      }
      return saveState;
    }
    /**
     * @param {SkillTreeGraph} skillTree
     * @param {Object} saveState 
     */
    static loadSave(skillTree, saveState) {
      if (!saveState) {
        console.log("SkillTreeSave.loadSave() No save state. Not loading skills!");
        return;
      }
      const skillStates = saveState.skills;
      if (!skillStates || skillStates.length === 0) {
        console.log("SkillTreeSave.loadSave() No skill save data found");
        return;
      }
      for (let i = 0; i < skillStates.length; i++) {
        try {
          this.loadSkillSave(skillTree, skillStates[i]);
        } catch (error) {
          console.error("SkillTreeSave.loadSave() Failed to load skill.", error.message);
        }
      }
    }
    /**
     * @private
     * @param {SkillType} skill 
     * @returns {Object}
     */
    static generateSkillSave(skill) {
      const saveState = {};
      saveState.id = skill.id;
      saveState.points = BigNumSave.save(skill.pointsSpent);
      saveState.unlocked = skill.unlocked;
      saveState.nodes = [];
      for (let i = 0; i < skill.nodes.length; i++) {
        saveState.nodes.push(this.generateSkillNodeSave(skill.nodes[i]));
      }
      return saveState;
    }
    /**
     * @private
     * @param {SkillTreeGraph} skillTree 
     * @param {Object} skillState 
     */
    static loadSkillSave(skillTree, skillState) {
      if (!skillState) {
        return;
      }
      const id = skillState.id;
      if (!id) {
        console.log("SkillTreeSave.loadSkillSave() No id found for skill.");
        return;
      }
      const skill = skillTree.findSkillById(id);
      if (!skill) {
        console.log("SkillTreeSave.loadSkillSave() Failed to find skill for id=" + id);
        return;
      }
      BigNumSave.load(skillState.points, skill.pointsSpent);
      skill.unlocked = skillState.unlocked;
      const nodesSave = skillState.nodes;
      if (!nodesSave || nodesSave.length === 0) {
        console.log("SkillTreeSave.loadSkillSave() No skill nodes saved for skill id=" + id);
        return;
      }
      for (let i = 0; i < nodesSave.length; i++) {
        this.loadSkillNodeSave(skill, nodesSave[i]);
      }
      skill.onSaveLoad();
    }
    /**
     * @private
     * @param {SkillNode} skillNode 
     * @returns {Object}
     */
    static generateSkillNodeSave(skillNode) {
      const saveState = {};
      saveState.id = skillNode.id;
      saveState.purchased = skillNode.purchased;
      return saveState;
    }
    /**
     * @private
     * @param {SkillType} skill 
     * @param {Object} nodeSave 
     */
    static loadSkillNodeSave(skill, nodeSave) {
      if (!nodeSave) {
        console.log("SkillTreeSave.loadSkillNodeSave() No node save state.");
        return;
      }
      const id = nodeSave.id;
      if (!id) {
        console.log("SkillTreeSave.loadSkillNodeSave() No id found for skill node.");
        return;
      }
      const skillNode = skill.getSkillNodeById(id);
      if (!skillNode) {
        console.log("SkillTreeSave.loadSkillNodeSave() No skill node found for id=" + id);
        return;
      }
      if (nodeSave.purchased) {
        try {
          skillNode.onPurchaseFromSave();
        } catch (error) {
          console.error("SaveTreeSave.loadSkillNodeSave() Failed to load skill node: " + id, error.message);
          throw error;
        }
      }
    }
  };

  // src/model/save/DamageSave.js
  var DamageSave = class {
    constructor() {
    }
    /**
     * @param {Damage} damage
     * @returns {Object}
     */
    static generateSave(damage) {
      const saveState = {};
      saveState.basePick = BigNumSave.save(damage.basePickDamagePerTurn);
      saveState.totalPick = BigNumSave.save(damage.totalPickDamagePerTurn);
      return saveState;
    }
    /**
     * @param {Damage} damage
     * @param {Object} saveState 
     */
    static loadSave(damage, saveState) {
      if (!saveState) {
        return;
      }
      BigNumSave.load(saveState.basePick, damage.basePickDamagePerTurn);
      BigNumSave.load(saveState.totalPick, damage.totalPickDamagePerTurn);
    }
  };

  // src/model/bonus/Bonus.js
  var Bonus = class {
    /**
     * @param {string} id 
     * @param {string} title 
     * @param {string} description 
     * @param {string} spriteFileName 
     * @param {GameTime} gameTime
     * @param {Totals} totals
     * @param {BigNum} cost
     * @param {number} activationTurns
     */
    constructor(id, title, description, spriteFileName, gameTime, totals, cost, activationTurns) {
      this.id = id;
      this.title = title;
      this.description = description;
      this.spriteFileName = spriteFileName;
      this.gameTime = gameTime;
      this.totals = totals;
      this.cost = cost;
      this.activationTurns = activationTurns;
      this.activated = false;
      this.startTurn = 0;
    }
    /**
     * @returns {string}
     */
    getTitle() {
      return this.title;
    }
    /**
     * @returns {string}
     */
    getDescription() {
      return this.description;
    }
    /**
     * @override
     * @returns {boolean}
     */
    isAffordable() {
      return this.cost.lessThanEquals(this.totals.gold);
    }
    /**
     * @override
     * @returns {boolean}
     */
    isPurchasable() {
      if (this.activated) {
        return false;
      }
      if (!this.isAffordable()) {
        return false;
      }
      return true;
    }
    onPurchase() {
      if (!this.isPurchasable()) {
        return;
      }
      this.totals.decrementGold(this.cost);
      this.onActivation();
    }
    /**
     * When activated, this return the percent of the activation period completed.
     * @returns {number}
     */
    getActivationPercent() {
      if (!this.activated) {
        return 0;
      }
      const elapsedTurns = this.gameTime.turnNumber - this.startTurn;
      const ratio = Math.min(1, elapsedTurns / this.activationTurns);
      return ratio * 100;
    }
    /**
     * @returns {boolean}
     */
    onActivation() {
      if (this.activated) {
        return false;
      }
      this.startTurn = this.gameTime.turnNumber;
      this.activated = true;
      return true;
    }
    onActivationFromSave() {
      this.activated = true;
    }
    /**
     * Sub-classed should implement this if they have things they need to tear down.
     * @returns {boolean}
     */
    onDeactivation() {
      if (!this.activated) {
        return false;
      }
      this.activated = false;
      return true;
    }
    /**
     */
    updateForTurn() {
      if (this.activated) {
        const turnNumber = this.gameTime.turnNumber;
        this.activated = turnNumber - this.startTurn < this.activationTurns;
        if (!this.activated) {
          this.onDeactivation();
        }
      }
    }
    /**
     * Returns a number value that represents the bonus when activated.
     * This is used by the save logic.
     * @abstract
     * @returns {number}
     */
    getActivationValue() {
    }
    /**
     * Sub-classes must override this.
     * @abstract
     */
    reset() {
      this.activated = false;
      this.startTurn = 0;
    }
  };

  // src/model/bonus/BonusCreator.js
  var BonusCreator = class {
    /**
     * @param {string} id
     */
    constructor(id, gameTime, totals) {
      this.id = id;
      this.gameTime = gameTime;
      this.totals = totals;
    }
    // IDEAS:
    // ore multipler
    // bonus multiplier
    // damage multiplier
    // 
    // temporary skills:
    // minions
    // dynamite
    // time acceleration
    // skills longer, skill cool downs
    /**
     * @abstract
     * @returns {Bonus}
     */
    createBonus() {
    }
    /**
     * @abstract
     * @param {number} activationValue
     * @returns {Bonus}
     */
    createBonusFromSave(activationValue) {
    }
  };

  // src/model/bonus/NumberValueBonus.js
  var NumberValueBonus = class extends Bonus {
    /**
     * @param {string} id 
     * @param {string} title 
     * @param {string} description 
     * @param {string} spriteFileName 
     * @param {GameTime} gameTime
     * @param {Totals} totals
     * @param {BigNum} cost
     * @param {number} activationTurns
     * @param {NumberValue} numberValue
     * @param {number} activeValue The value to set numberValue to when activated.
     */
    constructor(id, title, description, spriteFileName, gameTime, totals, cost, activationTurns, numberValue, activeValue) {
      super(id, title, description, spriteFileName, gameTime, totals, cost, activationTurns);
      this.numberValue = numberValue;
      this.activeValue = activeValue;
    }
    /**
     * @override
     * @returns {boolean}
     */
    onActivation() {
      if (!super.onActivation()) {
        return false;
      }
      this.numberValue.incrementValue(this.activeValue);
      return true;
    }
    /**
     * @override
     */
    onActivationFromSave() {
      super.onActivationFromSave();
      this.numberValue.incrementValue(this.activeValue);
    }
    /**
     * @override
     */
    onDeactivation() {
      if (!super.onDeactivation()) {
        return false;
      }
      this.numberValue.decrementValue(this.activeValue);
      return true;
    }
    /**
     * Returns a number value that represents the bonus.
     * @override
     * @returns {number}
     */
    getActivationValue() {
      return this.activeValue;
    }
    /**
     * @override
     */
    reset() {
      super.reset();
      this.numberValue.reset();
    }
  };

  // src/model/bonus/GoldBonusCreator.js
  var GoldBonusCreator = class extends BonusCreator {
    /**
     * @param {string} id 
     * @param {GameTime} gameTime
     * @param {Totals} totals
     * @param {NumberValue} numberValue
     */
    constructor(id, gameTime, totals, numberValue) {
      super(id, gameTime, totals);
      this.numberValue = numberValue;
      this.cost = new BigNum(Settings.bonus.activationCost);
    }
    /**
     * @override
     * @returns {Bonus}
     */
    createBonus() {
      const activeValue = 2;
      return this.createBonusInternal(activeValue);
    }
    /**
     * @override
     * @param {number} activationValue
     * @returns {Bonus}
     */
    createBonusFromSave(activationValue) {
      return this.createBonusInternal(activationValue);
    }
    /**
     * @private
     * @param {number} activationValue 
     * @returns {Bonus}
     */
    createBonusInternal(activationValue) {
      const activationTurns = Settings.bonus.activationTurns;
      return new NumberValueBonus(
        this.id,
        "Gold Bonus",
        "Gold +" + activationValue,
        Images.currency.gold,
        this.gameTime,
        this.totals,
        this.cost,
        activationTurns,
        this.numberValue,
        activationValue
      );
    }
  };

  // src/model/bonus/OreBonusCreator.js
  var OreBonusCreator = class extends BonusCreator {
    /**
     * @param {string} id 
     * @param {GameTime} gameTime
     * @param {Totals} totals
     * @param {NumberValue} numberValue
     */
    constructor(id, gameTime, totals, numberValue) {
      super(id, gameTime, totals);
      this.numberValue = numberValue;
      this.cost = new BigNum(Settings.bonus.activationCost);
    }
    /**
     * @override
     * @returns {Bonus}
     */
    createBonus() {
      const activeValue = 50;
      return this.createBonusInternal(activeValue);
    }
    /**
     * @override
     * @param {number} activationValue
     * @returns {Bonus}
     */
    createBonusFromSave(activationValue) {
      return this.createBonusInternal(activationValue);
    }
    /**
     * @private
     * @param {number} activationValue 
     * @returns {Bonus}
     */
    createBonusInternal(activationValue) {
      const activationTurns = Settings.bonus.activationTurns;
      return new NumberValueBonus(
        this.id,
        "Ore Multiplier",
        "Ore x" + activationValue,
        Images.currency.ore,
        this.gameTime,
        this.totals,
        this.cost,
        activationTurns,
        this.numberValue,
        activationValue
      );
    }
  };

  // src/model/bonus/UpgradeBonusCreator.js
  var UpgradeBonusCreator = class extends BonusCreator {
    /**
     * @param {string} id 
     * @param {GameTime} gameTime
     * @param {Totals} totals
     * @param {NumberValue} numberValue
     */
    constructor(id, gameTime, totals, numberValue) {
      super(id, gameTime, totals);
      this.numberValue = numberValue;
      this.cost = new BigNum(Settings.bonus.activationCost);
    }
    /**
     * @override
     * @returns {Bonus}
     */
    createBonus() {
      const activeValue = 10;
      return this.createBonusInternal(activeValue);
    }
    /**
     * @override
     * @param {number} activationValue
     * @returns {Bonus}
     */
    createBonusFromSave(activationValue) {
      return this.createBonusInternal(activationValue);
    }
    /**
     * @private
     * @param {number} activationValue 
     * @returns {Bonus}
     */
    createBonusInternal(activationValue) {
      const activationTurns = Settings.bonus.activationTurns;
      return new NumberValueBonus(
        this.id,
        "Upgrade Multiplier",
        "Upgrades x" + activationValue,
        Images.currency.upgrades,
        this.gameTime,
        this.totals,
        this.cost,
        activationTurns,
        this.numberValue,
        activationValue
      );
    }
  };

  // src/model/bonus/BonusCollection.js
  var BonusCollection = class extends GameModel {
    /**
     * @param {GameTime} gameTime
     * @param {Totals} totals
     * @param {Values} values
     */
    constructor(gameTime, totals, values) {
      super();
      this.gameTime = gameTime;
      this.totals = totals;
      this.values = values;
      this.availableBonuses = [];
      this.activeBonuses = [];
      this.availableChangeCount = 0;
      this.activeChangeCount = 0;
      this.bonusCreators = [];
      this.bonusCreatorById = {};
      this.prevBonusTurn = -Settings.bonus.newBonusTurns;
      this.addBonusCreator(new OreBonusCreator("oreBonus", this.gameTime, this.totals, this.values.bonusOreMultiplier));
      this.addBonusCreator(new UpgradeBonusCreator("upgradeBonus", this.gameTime, this.totals, this.values.bonusUpgradeMultiplier));
      this.addBonusCreator(new GoldBonusCreator("goldBonus", this.gameTime, this.totals, this.values.bonusGoldIncrement));
    }
    /**
     * @private
     * @param {BonusCreator} bonusCreator 
     */
    addBonusCreator(bonusCreator) {
      this.bonusCreators.push(bonusCreator);
      this.bonusCreatorById[bonusCreator.id] = bonusCreator;
    }
    /**
     * @param {Bonus} bonus 
     */
    add(bonus) {
      if (!bonus) {
        console.log("BonusCollection.add() null bonus");
        return;
      }
      this.availableBonuses.push(bonus);
      this.availableChangeCount++;
    }
    /**
     * @param {Bonus} bonus 
     */
    addActiveBonusFromSave(bonus) {
      if (!bonus) {
        console.log("BonusCollection.addActiveBonusFromSave() null bonus");
        return;
      }
      this.activeBonuses.push(bonus);
      this.activeChangeCount++;
      console.log("********** addActiveBonusFromSave() ADDED ACTIVE. len=" + this.activeBonuses.length);
    }
    /**
     * @param {Bonus} bonus 
     */
    activateBonus(bonus) {
      console.log("****************** activatebonus " + bonus.id + "   current length: " + this.activeBonuses.length);
      if (bonus.activated) {
        console.log("BonusCollection.activateBonus() bonus already activated.");
        return;
      }
      if (this.remove(bonus)) {
        bonus.onPurchase();
        console.log("********** activateBonus() BONUS IS ACTIVATED: " + bonus.activated);
        this.activeBonuses.push(bonus);
        this.activeChangeCount++;
        console.log("********** activateBonus() ADDED ACTIVE. len=" + this.activeBonuses.length);
      } else {
        console.log("**************** failed to add active");
      }
    }
    /**
     * @param {Bonus} bonus 
     */
    remove(bonus) {
      if (!bonus) {
        console.log("BonusCollection.remove() bonus null");
        return false;
      }
      const index = this.availableBonuses.indexOf(bonus);
      if (index === -1) {
        console.log("BonusCollection.remove() did not find bonus in list");
        return false;
      }
      this.availableBonuses.splice(index, 1);
      this.availableChangeCount++;
      return true;
    }
    /**
     */
    updateForTurn() {
      for (let i = this.activeBonuses.length - 1; i >= 0; i--) {
        const bonus = this.activeBonuses[i];
        bonus.updateForTurn();
        if (!bonus.activated) {
          this.activeBonuses.splice(i, 1);
          this.activeChangeCount++;
        }
      }
      const elapsedTurns = this.gameTime.turnNumber - this.prevBonusTurn;
      if (elapsedTurns >= Settings.bonus.newBonusTurns) {
        this.prevBonusTurn = this.gameTime.turnNumber;
        const bonus = this.createRandomBonus();
        this.add(bonus);
      }
    }
    /**
     * @returns {Bonus}
     */
    createRandomBonus() {
      const index = Rand.randomInt(this.bonusCreators.length);
      const bonusCreator = this.bonusCreators[index];
      return bonusCreator.createBonus();
    }
    /**
     * @param {string} creatorId 
     * @param {number} activationValue
     * @returns {Bonus}
     */
    createBonusFromSave(creatorId, activationValue) {
      const bonusCreator = this.bonusCreatorById[creatorId];
      if (!bonusCreator) {
        console.log("BonusCollection.createBonusById() Failed to find creator by id: " + creatorId);
        return null;
      }
      return bonusCreator.createBonusFromSave(activationValue);
    }
    /**
     * @param {Bonus} bonus 
     * @returns {boolean}
     */
    purchaseBonus(bonus) {
      if (!bonus) {
        console.log("BonusCollection.purchaseBonus() null bonus");
        return false;
      }
      if (!bonus.isPurchasable()) {
        console.log("BonusCollection.purchaseBonus() bonus not purchasable");
        return false;
      }
      const index = this.availableBonuses.indexOf(bonus);
      if (index < 0) {
        console.log("BonusCollection.purchaseBonus() failed to find bonus in available list");
        return false;
      }
      this.activateBonus(bonus);
      return true;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      for (let i = 0; i < this.activeBonuses.length; i++) {
        this.activeBonuses[i].reset();
      }
      this.availableBonuses.length = 0;
      this.activeBonuses.length = 0;
      this.availableChangeCount = 0;
      this.activeChangeCount = 0;
      this.prevBonusTurn = -Settings.bonus.newBonusTurns;
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/save/BonusCollectionSave.js
  var BonusCollectionSave = class {
    constructor() {
    }
    /**
     * @param {BonusCollection} bonusCollection
     * @returns {Object}
     */
    static generateSave(bonusCollection) {
      const saveState = {};
      saveState.availableBonuses = [];
      saveState.activeBonuses = [];
      saveState.prevBonusTurn = bonusCollection.prevBonusTurn;
      for (let i = 0; i < bonusCollection.activeBonuses.length; i++) {
        if (!bonusCollection.activeBonuses[i]) {
          continue;
        }
        saveState.activeBonuses.push(this.generateBonusSave(bonusCollection.activeBonuses[i]));
      }
      for (let i = 0; i < bonusCollection.availableBonuses.length; i++) {
        if (!bonusCollection.availableBonuses[i]) {
          continue;
        }
        saveState.availableBonuses.push(this.generateBonusSave(bonusCollection.availableBonuses[i]));
      }
      return saveState;
    }
    /**
     * @param {BonusCollection} bonusCollection
     * @param {Object} saveState 
     */
    static loadSave(bonusCollection, saveState) {
      if (!saveState) {
        console.log("BonusCollectionSave.loadSave no save state");
        return;
      }
      const prevBonusTurn = saveState.prevBonusTurn;
      if (prevBonusTurn) {
        bonusCollection.prevBonusTurn = prevBonusTurn;
      }
      if (saveState.availableBonuses) {
        for (let i = 0; i < saveState.availableBonuses.length; i++) {
          this.loadBonusSave(bonusCollection, saveState.availableBonuses[i]);
        }
      }
      if (saveState.activeBonuses) {
        for (let i = 0; i < saveState.activeBonuses.length; i++) {
          this.loadBonusSave(bonusCollection, saveState.activeBonuses[i]);
        }
      }
    }
    /**
     * @private
     * @param {Bonus} bonus 
     * @returns {Object}
     */
    static generateBonusSave(bonus) {
      const saveState = {};
      saveState.id = bonus.id;
      saveState.activated = bonus.activated;
      saveState.startTurn = bonus.startTurn;
      saveState.activationValue = bonus.getActivationValue();
      return saveState;
    }
    /**
     * @private
     * @param {BonusCollection} bonusCollection 
     * @param {Object} bonusSaveState 
     */
    static loadBonusSave(bonusCollection, bonusSaveState) {
      if (!bonusSaveState) {
        return;
      }
      const id = bonusSaveState.id;
      const activated = bonusSaveState.activated;
      const startTurn = bonusSaveState.startTurn;
      const activationValue = bonusSaveState.activationValue;
      const bonus = bonusCollection.createBonusFromSave(id, activationValue);
      if (!bonus) {
        console.log("BonusCollectionSave.loadBonusSave() no bonus created for: " + id);
        return;
      }
      bonus.startTurn = startTurn;
      if (!activated) {
        bonusCollection.add(bonus);
      } else {
        bonusCollection.addActiveBonusFromSave(bonus);
        bonus.onActivationFromSave();
      }
    }
  };

  // src/GameStateControl.js
  var GameStateControl = class extends GameModel {
    /**
     * @abstract
     */
    constructor() {
      super();
      this.CALLBACK_GAME_RESET = 1;
      this.CALLBACK_GAME_DELETE = 2;
      this.CALLBACK_GAME_IMPORT = 3;
      this.CALLBACK_GAME_PRESTIGE = 4;
    }
    /**
     * @abstract
     * @returns {State}
     */
    getState() {
      return null;
    }
    /**
     * @abstract
     */
    startGame() {
    }
    ////////////////////////////////////////////////
    /**
     * @abstract
     */
    prestigeGame() {
    }
    /**
     * @abstract
     */
    resetGame() {
    }
    /**
     * @abstract
     */
    deleteGame() {
    }
    /**
     * @abstract
     * @param {string} saveStateText 
     */
    importSave(saveStateText) {
    }
    /**
     * @abstract
     * @param {number} callbackCode 
     */
    modelLoadCallback(callbackCode) {
    }
  };

  // src/model/automation/BaseAutomation.js
  var BaseAutomation = class extends GameModel {
    /**
     * @param {GameTime} gameTime
     * @param {BooleanValue} automationUnlockedValue 
     * @param {NumberValue} automationRateUpgrades
     * @param {number} baseUpgradeDelayTurns
     * @param {number} turnsPerRateUpgrade
     */
    constructor(gameTime, automationUnlockedValue, automationRateUpgrades, baseUpgradeDelayTurns, turnsPerRateUpgrade) {
      super();
      this.gameTime = gameTime;
      this.automationUnlockedValue = automationUnlockedValue;
      this.automationRateUpgrades = automationRateUpgrades;
      this.baseUpgradeDelayTurns = baseUpgradeDelayTurns;
      this.turnsPerRateUpgrade = turnsPerRateUpgrade;
      this.lastAutomationTurn = 0;
      this.lastAutomationFrame = 0;
      this.active = true;
    }
    /**
     * @returns {number}
     */
    getDelayTurns() {
      return Math.max(Settings.automation.minDelayTurns, this.baseUpgradeDelayTurns - this.automationRateUpgrades.getValue() * this.turnsPerRateUpgrade);
    }
    updateForTurn() {
      if (!this.active) {
        return;
      }
      if (!this.automationUnlockedValue.isValue()) {
        return;
      }
      const turnNumber = this.gameTime.turnNumber;
      const delayTurns = this.getDelayTurns();
      const elapsedTurns = turnNumber - this.lastAutomationTurn;
      if (elapsedTurns < delayTurns) {
        return;
      }
      this.lastAutomationTurn = turnNumber;
      this.lastAutomationFrame = this.gameTime.frameNumber;
      this.purchaseUpgrade();
    }
    /**
     * @abstract
     */
    purchaseUpgrade() {
    }
    /**
     * @returns {boolean}
     */
    isUnlocked() {
      return this.automationUnlockedValue.isValue();
    }
    toggleActiveFlag() {
      this.active = !this.active;
    }
    /**
     * When activated, this return the percent of the activation period completed.
     * @returns {number}
     */
    getActivationPercent() {
      if (!this.active) {
        return 0;
      }
      const delayFrames = this.getDelayTurns() * Settings.time.turnFrames;
      const elapsedFrames = this.gameTime.frameNumber - this.lastAutomationFrame;
      const ratio = Math.min(1, elapsedFrames / delayFrames);
      return ratio * 100 | 0;
    }
    /////////////////////////////////////////
    // GameModel
    /////////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.lastAutomationTurn = 0;
      this.lastAutomationFrame = 0;
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.lastAutomationTurn = 0;
      this.lastAutomationFrame = 0;
    }
  };

  // src/model/automation/MinedUpgradeAutomation.js
  var MinedUpgradeAutomation = class extends BaseAutomation {
    /**
     * @param {GameTime} gameTime
     * @param {MinedUpgradeCollection} minedUpgradeCollection 
     * @param {Values} values 
     */
    constructor(gameTime, minedUpgradeCollection, values) {
      super(
        gameTime,
        values.minedAutomationUnlocked,
        values.minedAutomationRateUpgrades,
        Settings.automation.baseUpgradeDelayTurns,
        Settings.automation.turnsPerRateUpgrade
      );
      this.minedUpgradeCollection = minedUpgradeCollection;
    }
    /**
     * @override
     */
    purchaseUpgrade() {
      const upgrades = this.minedUpgradeCollection.upgrades;
      if (upgrades.length === 0) {
        return;
      }
      const index = Rand.randomInt(upgrades.length);
      const upgrade = upgrades[index];
      if (upgrade && upgrade.isPurchasable()) {
        upgrade.purchase();
        this.minedUpgradeCollection.remove(upgrade);
      }
    }
  };

  // src/model/automation/PickUpgradeAutomation.js
  var PickUpgradeAutomation = class extends BaseAutomation {
    /**
     * @param {GameTime} gameTime
     * @param {PickUpgradeCollection} pickUpgradeCollection
     * @param {Values} values
     */
    constructor(gameTime, pickUpgradeCollection, values) {
      super(
        gameTime,
        values.pickAutomationUnlocked,
        values.pickAutomationRateUpgrades,
        Settings.automation.baseUpgradeDelayTurns,
        Settings.automation.turnsPerRateUpgrade
      );
      this.pickUpgradeCollection = pickUpgradeCollection;
      this.validUpgrades = [];
      this.workingScore = new BigNum(0);
      this.bestScore = new BigNum(0);
      this.additive = true;
    }
    /**
     * @override
     */
    purchaseUpgrade() {
      const upgrades = this.pickUpgradeCollection.upgrades;
      if (upgrades.length === 0) {
        return;
      }
      this.additive = !this.additive;
      this.findValidUpgrades();
      if (this.validUpgrades.length === 0) {
        return;
      }
      const upgrade = this.selectBestUpgrade(this.additive);
      if (!upgrade) {
        return;
      }
      upgrade.purchase();
    }
    /**
     * @private
     */
    findValidUpgrades() {
      this.validUpgrades.length = 0;
      const upgrades = this.pickUpgradeCollection.upgrades;
      for (let i = 0; i < upgrades.length; i++) {
        const upgrade = upgrades[i];
        if (this.isValidUpgrade(upgrade)) {
          this.validUpgrades.push(upgrade);
        }
      }
    }
    /**
     * @private
     * @param {boolean} additive
     * @returns {PickUpgrade}
     */
    selectBestUpgrade(additive) {
      const bestAdditiveUpgrade = this.selectBestUpgradeByType(true);
      const bestMultiplicativeUpgrade = this.selectBestUpgradeByType(false);
      if (!bestAdditiveUpgrade && !bestMultiplicativeUpgrade) {
        return null;
      } else if (!bestAdditiveUpgrade) {
        return bestMultiplicativeUpgrade;
      } else if (!bestMultiplicativeUpgrade) {
        return bestAdditiveUpgrade;
      } else if (additive) {
        return bestAdditiveUpgrade;
      } else {
        return bestMultiplicativeUpgrade;
      }
    }
    /**
     * @private
     * @param {boolean} additive True for additive upgrades, false for multplicative
     * @returns {PickUpgrade}
     */
    selectBestUpgradeByType(additive) {
      this.bestScore.setZero();
      let bestUpgrade = null;
      for (let i = 0; i < this.validUpgrades.length; i++) {
        const upgrade = this.validUpgrades[i];
        if (upgrade.additiveUpgrade !== additive) {
          continue;
        }
        const score = this.getUpgradeScore(upgrade);
        if (!bestUpgrade || score.greaterThan(this.bestScore)) {
          bestUpgrade = upgrade;
          this.bestScore.copy(score);
        }
      }
      return bestUpgrade;
    }
    /**
     * @private
     * @param {PickUpgrade} pickUpgrade 
     * @returns {BigNum}
     */
    getUpgradeScore(pickUpgrade) {
      this.workingScore.copy(pickUpgrade.valuePerUpgrade);
      this.workingScore.mulNumber(pickUpgrade.nextActualPurchaseCount);
      this.workingScore.div(pickUpgrade.getCost());
      return this.workingScore;
    }
    /**
     * @private
     * @param {PickUpgrade} upgrade 
     * @returns {boolean}
     */
    isValidUpgrade(upgrade) {
      if (!upgrade) {
        return false;
      }
      return upgrade.isVisible() && upgrade.isPurchasable();
    }
  };

  // src/model/automation/PrestigeAutomation.js
  var PrestigeAutomation = class extends BaseAutomation {
    /**
     * @param {GameTime} gameTime
     * @param {Values} values 
     * @param {GameStateControl} gameStateControl
     * @param {Totals} totals
     */
    constructor(gameTime, values, gameStateControl, totals) {
      super(
        gameTime,
        values.prestigeAutomationUnlocked,
        values.prestigeAutomationRateUpgrades,
        Settings.automation.prestigeUpgradeDelayTurns,
        Settings.automation.prestigeTurnsPerRateUpgrade
      );
      this.gameStateControl = gameStateControl;
      this.totals = totals;
      this.prevUnclaimedPrestige = new BigNum(0);
    }
    /**
     * @override
     */
    updateForTurn() {
      if (this.totals.unclaimedPrestige.greaterThanZero()) {
        if (!this.prevUnclaimedPrestige.equals(this.totals.unclaimedPrestige)) {
          this.prevUnclaimedPrestige.copy(this.totals.unclaimedPrestige);
          this.lastAutomationTurn = this.gameTime.turnNumber;
          this.lastAutomationFrame = this.gameTime.frameNumber;
        }
        super.updateForTurn();
      }
    }
    // /**
    //  * @private
    //  * @returns {boolean}
    //  */
    // isPrestigeCriteriaSatisfied() {
    //     if (this.prestigePossible) {
    //         return true;
    //     }
    //     // If we will earn 0 prestige, then don't start the clock.
    //     if (this.totals.unclaimedPrestige.equalsZero()) {
    //         return false;
    //     }
    //     // // If unclaimed prestige changes, then start a timer.
    //     // if (!this.prevUnclaimedPrestige.equals(this.totals.unclaimedPrestige)) {
    //     //     this.prevUnclaimedPrestige.copy(this.totals.unclaimedPrestige);
    //     //     this.lastPrestigeChangeTurn = this.gameTime.turnNumber;
    //     //     this.lastAutomationFrame = this.gameTime.frameNumber;
    //     //     console.log('updated last automation frame!!!!!' );
    //     // }
    //     if (this.lastPrestigeChangeTurn === 0) {
    //         return false;
    //     }
    //     // // If N minutes have passed since the last change in unclaimed prestige, then start the timer.
    //     // const elapsedTurns = this.gameTime.turnNumber - this.lastPrestigeChangeTurn;
    //     // if (elapsedTurns < Settings.automation.prestigeMinTurnsSinceLastChange) {
    //     //     return false;
    //     // }
    //     this.prestigePossible = true;
    //     return true;
    // }
    // /**
    //  * @returns {number}
    //  */
    // getElapsedTurnsSincePrestige() {
    //     return this.gameTime.turnNumber - this.lastPrestigeChangeTurn;
    // }
    // /**
    //  * @returns {number}
    //  */
    // getCriteriaPercent() {
    //     if (this.prestigePossible) {
    //         return 0;
    //     }
    //     // If N minutes have passed since the last change in unclaimed prestige, then start the timer.
    //     const elapsedTurns = this.gameTime.turnNumber - this.lastPrestigeChangeTurn;
    //     const delayTurns = Settings.automation.prestigeMinTurnsSinceLastChange;
    //     const ratio = Math.min(1.0, elapsedTurns / delayTurns);
    //     return (ratio * 100) | 0;
    // }
    // /**
    //  * When activated, this return the percent of the activation period completed.
    //  * @returns {number}
    //  */
    // getActivationPercent() {
    //     if (!this.prestigePossible) {
    //         return 0;
    //     }
    //     return super.getActivationPercent();
    // }
    /**
     * @override
     * This is invoked by the super class when it is time.
     */
    purchaseUpgrade() {
      this.gameStateControl.prestigeGame();
    }
    /////////////////////////////////////////
    // GameModel
    /////////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      super.resetFull();
      this.resetInternal();
    }
    /**
     * @override
     */
    resetForPrestige() {
      super.resetForPrestige();
      this.resetInternal();
    }
    resetInternal() {
      this.prevUnclaimedPrestige.setZero();
    }
  };

  // src/model/automation/AutomationManager.js
  var AutomationManager = class extends GameModel {
    /**
     * @param {MinedUpgradeCollection} minedUpgradeCollection
     * @param {PickUpgradeCollection} pickUpgradeCollection
     * @param {GameStateControl} gameStateControl
     * @param {Values} values
     * @param {Totals} totals
     * @param {GameTime} gameTime
     */
    constructor(minedUpgradeCollection, pickUpgradeCollection, gameStateControl, values, totals, gameTime) {
      super();
      this.gameTime = gameTime;
      this.minedUpgradeAutomation = new MinedUpgradeAutomation(gameTime, minedUpgradeCollection, values, gameTime);
      this.pickUpgradeAutomation = new PickUpgradeAutomation(gameTime, pickUpgradeCollection, values, gameTime);
      this.prestigeAutomation = new PrestigeAutomation(gameTime, values, gameStateControl, totals);
    }
    updateForTurn() {
      this.minedUpgradeAutomation.updateForTurn();
      this.pickUpgradeAutomation.updateForTurn();
      this.prestigeAutomation.updateForTurn();
    }
    /////////////////////////////////////////
    // GameModel
    /////////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.minedUpgradeAutomation.resetFull();
      this.pickUpgradeAutomation.resetFull();
      this.prestigeAutomation.resetFull();
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.minedUpgradeAutomation.resetForPrestige();
      this.pickUpgradeAutomation.resetForPrestige();
      this.prestigeAutomation.resetForPrestige();
    }
  };

  // src/model/save/AutomationSave.js
  var AutomationSave = class {
    constructor() {
    }
    /**
     * @param {AutomationManager} automationManager
     * @returns {Object}
     */
    static generateSave(automationManager) {
      const saveState = {};
      saveState.prevTurn = automationManager.prevTurn;
      saveState.minedAutomation = this.generateAutomationSave(automationManager.minedUpgradeAutomation);
      saveState.pickAutomation = this.generateAutomationSave(automationManager.pickUpgradeAutomation);
      saveState.prestigeAutomation = this.generatePrestigeAutomationSave(automationManager.prestigeAutomation);
      return saveState;
    }
    /**
     * @param {AutomationManager} automationManager
     * @param {Object} saveState 
     */
    static loadSave(automationManager, saveState) {
      if (!saveState) {
        return;
      }
      automationManager.prevTurn = saveState.prevTurn;
      this.loadAutomationSave(automationManager.minedUpgradeAutomation, saveState.minedAutomation);
      this.loadAutomationSave(automationManager.pickUpgradeAutomation, saveState.pickAutomation);
      this.loadPrestigeAutomationSave(automationManager.prestigeAutomation, saveState.prestigeAutomation);
    }
    /**
     * @private
     * @param {BaseAutomation} automation 
     * @returns {Object}
     */
    static generateAutomationSave(automation) {
      const saveState = {};
      saveState.lastAutomationTurn = automation.lastAutomationTurn;
      saveState.active = automation.active;
      return saveState;
    }
    /**
     * @private
     * @param {BaseAutomation} automation 
     * @param {Object} saveState 
     */
    static loadAutomationSave(automation, saveState) {
      if (!saveState) {
        return;
      }
      automation.lastAutomationTurn = saveState.lastAutomationTurn;
      automation.active = saveState.active;
    }
    /**
     * @private
     * @param {PrestigeAutomation} automation 
     * @returns {Object}
     */
    static generatePrestigeAutomationSave(automation) {
      const saveState = this.generateAutomationSave(automation);
      saveState.lastPrestigeChangeTurn = automation.lastPrestigeChangeTurn;
      saveState.prevUnclaimedPrestige = BigNumSave.save(automation.prevUnclaimedPrestige);
      return saveState;
    }
    /**
     * @private
     * @param {PrestigeAutomation} automation 
     * @param {Object} saveState 
     */
    static loadPrestigeAutomationSave(automation, saveState) {
      if (!saveState) {
        return;
      }
      this.loadAutomationSave(automation, saveState);
      if (saveState.prevUnclaimedPrestige) {
        BigNumSave.load(saveState.prevUnclaimedPrestige, automation.prevUnclaimedPrestige);
      }
      if (saveState.lastPrestigeChangeTurn) {
        automation.lastPrestigeChangeTurn = saveState.lastPrestigeChangeTurn;
      }
    }
  };

  // src/model/upgrade/gold/GoldUpgrade.js
  var GoldUpgrade = class extends ClassicUpgrade {
    /**
     * @param {string} id
     * @param {string} title
     * @param {string} iconFileName
     * @param {UpgradeCostCalculator} upgradeCostCalculator 
     * @param {number} maxCount
     * @param {Totals} totals
     */
    constructor(id, title, iconFileName, upgradeCostCalculator, maxCount, totals) {
      super(id, title, iconFileName, upgradeCostCalculator, maxCount);
      this.totals = totals;
      this.initializeCosts();
    }
    // NOTE: SUB-CLASSES MUST OVERRIDE getDescription()
    //////////////////////////////////////
    // Upgrade overrides
    //////////////////////////////////////
    /**
     * @override
     * @returns {string} See UpgradeCostUnit
     */
    getCostUnit() {
      return UpgradeCostUnit.GOLD;
    }
    //////////////////////////////////////
    // ClassicUpgrade overrides
    //////////////////////////////////////
    /**
     * @override
     * @returns {BigNum}
     */
    getMoney() {
      return this.totals.gold;
    }
    /**
     * @override
     * @param {BigNum} money 
     */
    decrementMoney(money) {
      this.totals.decrementGold(money);
    }
  };

  // src/model/upgrade/gold/DamageBonusGoldUpgrade.js
  var DamageBonusGoldUpgrade = class extends GoldUpgrade {
    /**
     * @param {string} id
     * @param {string} title
     * @param {string} iconFileName
     * @param {UpgradeCostCalculator} upgradeCostCalculator 
     * @param {number} maxCount
     * @param {Totals} totals
     * @param {MineDamageLogic} mineDamageLogic
     * @param {Damage} damage
     */
    constructor(id, title, iconFileName, upgradeCostCalculator, maxCount, totals, mineDamageLogic, damage) {
      super(id, title, iconFileName, upgradeCostCalculator, maxCount, totals);
      this.damage = damage;
      this.mineDamageLogic = mineDamageLogic;
      this.displayedMultiplier = new BigNum(-10);
      this.description = null;
    }
    /**
     * @override
     * @returns {string}
     */
    getDescription() {
      if (!this.description || !this.damage.goldDamageMultiplier.equals(this.displayedMultiplier)) {
        this.displayedMultiplier.copy(this.damage.goldDamageMultiplier);
        this.description = "x" + NumberFormatter.formatBigNum(this.damage.goldDamageMultiplier);
      }
      return this.description;
    }
    /**
     * Invoked by the base class to let the sub-class know that a purchase has been made.
     * @override
     * @param {number} currentCount This is the before value.
     * @param {number} purchaseCount 
     */
    onUpgradePurchased(currentCount, purchaseCount) {
      super.onUpgradePurchased(currentCount, purchaseCount);
      const goldDamageMultiplier = this.damage.goldDamageMultiplier;
      if (goldDamageMultiplier.equalsZero()) {
        goldDamageMultiplier.setValue(1);
      }
      const goldUnitMultiplier = new BigNum(Settings.gold.damageMultiplierPerUpgrade);
      for (let i = 0; i < purchaseCount; i++) {
        goldDamageMultiplier.multiply(goldUnitMultiplier);
      }
      this.mineDamageLogic.calculateTotalMineDamagePerTurn();
    }
  };

  // src/model/upgrade/gold/OreBonusGoldUpgrade.js
  var OreBonusGoldUpgrade = class extends GoldUpgrade {
    /**
     * @param {string} id
     * @param {string} title
     * @param {string} iconFileName
     * @param {UpgradeCostCalculator} upgradeCostCalculator 
     * @param {number} maxCount
     * @param {Totals} totals
     * @param {BigNumValue} oreBonusValue
     */
    constructor(id, title, iconFileName, upgradeCostCalculator, maxCount, totals, oreBonusValue) {
      super(id, title, iconFileName, upgradeCostCalculator, maxCount, totals);
      this.oreBonusValue = oreBonusValue;
      this.displayedMultiplier = new BigNum(-10);
      this.description = null;
    }
    /**
     * @override
     * @returns {string}
     */
    getDescription() {
      const oreBonus = this.oreBonusValue.getValue();
      if (!this.description || !oreBonus.equals(this.displayedMultiplier)) {
        this.displayedMultiplier.copy(oreBonus);
        this.description = "x" + NumberFormatter.formatBigNum(oreBonus);
      }
      return this.description;
    }
    /**
     * Invoked by the base class to let the sub-class know that a purchase has been made.
     * @override
     * @param {number} currentCount This is the before value.
     * @param {number} purchaseCount 
     */
    onUpgradePurchased(currentCount, purchaseCount) {
      super.onUpgradePurchased(currentCount, purchaseCount);
      const oreBonus = this.oreBonusValue.getValue();
      if (oreBonus.equalsZero()) {
        oreBonus.setValue(1);
      }
      const bonus = new BigNum(Settings.gold.oreBonusMultiplierPerUpgrade);
      for (let i = 0; i < purchaseCount; i++) {
        oreBonus.mul(bonus);
      }
    }
  };

  // src/model/upgrade/gold/GoldUpgradeCollection.js
  var GoldUpgradeCollection = class extends ClassicUpgradeCollection {
    /**
     * @param {Totals} totals 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     * @param {Damage} damage
     */
    constructor(totals, values, mineDamageLogic, damage) {
      super();
      this.initializeUpgrades(totals, values, mineDamageLogic, damage);
    }
    /**
     * @override
     * @param {Totals} totals 
     * @param {Values} values
     * @param {MineDamageLogic} mineDamageLogic
     * @param {Damage} damage
     */
    initializeUpgrades(totals, values, mineDamageLogic, damage) {
      this.generateDamageBonusUpgrade("goldDamage", totals, this.createCostCalculator(), mineDamageLogic, damage);
      this.generateOreBonusUpgrade("goldOre", totals, this.createCostCalculator(), values);
      this.addBulkCompleted();
    }
    /**
     * @private
     * @param {string} id
     * @param {Totals} totals 
     * @param {CostCalculator} costCalculator
     * @param {MineDamageLogic} mineDamageLogic
     * @param {Damage} damage
     */
    generateDamageBonusUpgrade(id, totals, costCalculator, mineDamageLogic, damage) {
      const upgradeMultiplier = Settings.gold.damageMultiplierPerUpgrade;
      const upgrade = new DamageBonusGoldUpgrade(
        id,
        "Mine: x" + upgradeMultiplier,
        Images.pick,
        costCalculator,
        100,
        totals,
        mineDamageLogic,
        damage
      );
      this.addBulk(upgrade);
    }
    /**
     * @private
     * @param {string} id
     * @param {Totals} totals 
     * @param {CostCalculator} costCalculator
     * @param {MineDamageLogic} mineDamageLogic
     * @param {Values} values
     */
    generateOreBonusUpgrade(id, totals, costCalculator, values) {
      const upgradeMultiplier = Settings.gold.oreBonusMultiplierPerUpgrade;
      const upgrade = new OreBonusGoldUpgrade(
        id,
        "Ore: x" + upgradeMultiplier,
        Images.currency.ore,
        costCalculator,
        100,
        totals,
        values.goldOreBonusMultiplier
      );
      this.addBulk(upgrade);
    }
    /**
     * @private
     * @returns {UpgradeCostCalculator}
     */
    createCostCalculator() {
      const costGrowthRate = 1.3;
      return new ClassicUpgradeCostCalculator(new BigNum(Settings.gold.upgradeBaseCost), costGrowthRate);
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetForPrestige() {
    }
  };

  // src/model/save/GoldUpgradeCollectionSave.js
  var GoldUpgradeCollectionSave = class {
    constructor() {
    }
    /**
     * @param {GoldUpgradeCollection} upgradeCollection
     * @returns {Object}
     */
    static generateSave(upgradeCollection) {
      const saveState = {};
      saveState.upgrades = [];
      for (let i = 0; i < upgradeCollection.upgrades.length; i++) {
        const upgradeSave = this.generateUpgradeSave(upgradeCollection.upgrades[i]);
        if (!upgradeSave) {
          continue;
        }
        saveState.upgrades.push(upgradeSave);
      }
      saveState.countToPurchase = upgradeCollection.countToPurchase;
      return saveState;
    }
    /**
     * @param {GoldUpgradeCollection} upgradeCollection
     * @param {Object} saveState 
     */
    static loadSave(upgradeCollection, saveState) {
      if (!saveState) {
        console.log("GoldUpgradeCollectionSave.loadSave no save state");
        return;
      }
      const upgradeSaves = saveState.upgrades;
      if (!upgradeSaves) {
        console.log("GoldUpgradeCollectionSave.loadSave state empty");
        return;
      }
      for (let i = 0; i < saveState.upgrades.length; i++) {
        this.loadUpgradeSave(upgradeCollection, saveState.upgrades[i]);
      }
      const countToPurchase = saveState.countToPurchase;
      if (countToPurchase) {
        upgradeCollection.setCountToPurchase(countToPurchase);
      }
    }
    /**
     * @private
     * @param {GoldUpgrade} upgrade 
     * @returns {Object}
     */
    static generateUpgradeSave(upgrade) {
      if (upgrade.purchasedCount === 0) {
        return null;
      }
      const upgradeState = {};
      upgradeState.id = upgrade.id;
      upgradeState.c = upgrade.purchasedCount;
      return upgradeState;
    }
    /**
     * @private
     * @param {GoldUpgradeCollection} upgradeCollection
     * @param {Object} upgradeState
     */
    static loadUpgradeSave(upgradeCollection, upgradeState) {
      if (!upgradeState) {
        return;
      }
      const id = upgradeState.id;
      const upgrade = upgradeCollection.findById(id);
      if (!upgrade) {
        console.log("GoldUpgradeCollectionSave.loadUpgradeSave() failed to find upgrade id=" + id);
        return;
      }
      const count = upgradeState.c;
      if (count === void 0) {
        return;
      }
      upgrade.setPurchasedCountFromSave(count);
    }
  };

  // src/model/path/VectorFieldGenerator.js
  var VectorFieldGenerator = class extends GameModel {
    /**
     * @param {WorldGrid} worldGrid
     * @param {Projection} projection
     * @param {VectorField} vectorField 
     * @param {PartyTarget} partyTarget
     * @param {Crew} crew
     */
    constructor(worldGrid, projection, vectorField, partyTarget, crew) {
      super();
      this.worldGrid = worldGrid;
      this.projection = projection;
      this.vectorField = vectorField;
      this.partyTarget = partyTarget;
      this.crew = crew;
      this.startTileOrigin = null;
      this.vectorFieldNumber = 0;
      const thisRef = this;
      this.minePremiumTileRegionCallback = /**
       * @param {GridRegion} region 
       */
      function(region) {
        const mineTiles = region.mineTiles;
        region.vectorFieldNumber = thisRef.vectorField.vectorFieldNumber;
        let count = 0;
        for (let i = 0; i < mineTiles.length; i++) {
          const tile = mineTiles[i];
          if (!tile || tile.open) {
            continue;
          }
          if (tile.isCurrency()) {
            thisRef.vectorField.currencyMiningCandidates.push(tile);
            count++;
          } else {
            thisRef.vectorField.priorityMiningCandidates.push(tile);
            count++;
          }
          tile.pathData.setMineScore(VectorFieldScores.PREMIUM, thisRef.vectorField.vectorFieldNumber);
        }
      };
      this.commonTileRegionCallback = /**
       * @param {GridRegion} region 
       */
      function(region) {
        const tiles = region.tiles;
        for (let i = 0; i < tiles.length; i++) {
          const tile = tiles[i];
          if (!tile || tile.tileType.rarityModifier !== TileTypeRarity.COMMON) {
            continue;
          }
          if (!tile.lighting.everVisibleToCharacter) {
            continue;
          }
          if (tile.open) {
            continue;
          }
          const mineScore = thisRef.calculateCommonTileMineScore(tile);
          tile.pathData.setMineScore(mineScore, thisRef.vectorFieldNumber);
          if (mineScore > VectorFieldScores.WORTHLESS) {
            thisRef.vectorField.commonMiningCandidates.push(tile);
          }
        }
      };
    }
    /**
     * @param {GridTile} startTile
     * @param {boolean} ignoreCommonTiles
     * @param {boolean} ignorePremiumTiles
     * @param {boolean} smallGridMode
     * @param {number} destinationDirection 0=center, 1=down, 2=up, 3=right
     */
    generateVectorField(startTile, ignoreCommonTiles, ignorePremiumTiles, smallGridMode, destinationDirection) {
      if (!startTile) {
        console.log("VectorFieldGenerator - not generating: no tile");
        return;
      }
      const grid = startTile.getGrid();
      if (!grid.isLoaded()) {
        console.log("VectorFieldGenerator - not generating: grid not loaded?");
        return;
      }
      PerformanceMetrics.startTime("FindTargets");
      this.startTileOrigin = startTile.origin;
      this.vectorField.commonMiningCandidates.length = 0;
      this.vectorField.currencyMiningCandidates.length = 0;
      this.vectorField.priorityMiningCandidates.length = 0;
      this.vectorField.ignoreCommonTiles = ignoreCommonTiles;
      this.vectorField.ignorePremiumTiles = ignorePremiumTiles;
      this.vectorField.destinationTileCandidates.fill(null);
      this.vectorField.vectorFieldNumber++;
      this.vectorField.centerTile = startTile;
      this.vectorFieldNumber = this.vectorField.vectorFieldNumber;
      const premiumPixelRadius = (smallGridMode ? 12 : 25) * Settings.tile.size;
      GridInversionOfControl.allNearbyRegions(this.worldGrid, this.projection, this.startTileOrigin, premiumPixelRadius, this.minePremiumTileRegionCallback);
      const numGoodTiles = this.vectorField.currencyMiningCandidates.length + this.vectorField.priorityMiningCandidates.length;
      if (!ignoreCommonTiles && numGoodTiles < this.crew.miners.length) {
        const commonPixelRadius = (smallGridMode ? 6 : 15) * Settings.tile.size;
        GridInversionOfControl.allNearbyRegions(this.worldGrid, this.projection, this.startTileOrigin, commonPixelRadius, this.commonTileRegionCallback);
      }
      this.addDestinationTiles(startTile, destinationDirection, smallGridMode);
      PerformanceMetrics.endTime("FindTargets");
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @param {number} destinationDirection 1=down, 2=up, 3=right
     * @param {boolean} smallGridMode
     */
    addDestinationTiles(tile, destinationDirection, smallGridMode) {
      if (!tile) {
        return;
      }
      if (destinationDirection === 1) {
        this.addDownDestinationTiles(tile, smallGridMode);
      } else if (destinationDirection === 2) {
        this.addUpDestinationTiles(tile, smallGridMode);
      } else if (destinationDirection === 3) {
        this.addRightDestinationTiles(tile, smallGridMode);
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @param {boolean} smallGridMode
     */
    addDownDestinationTiles(tile, smallGridMode) {
      const tiles = this.vectorField.destinationTileCandidates;
      let yShiftPixels = Settings.tile.size * (smallGridMode ? 15 : 25);
      let count = 0;
      let downCenter = this.worldGrid.findGridTileXY(tile.origin.x, tile.origin.y + yShiftPixels);
      while (!downCenter && yShiftPixels > 0) {
        yShiftPixels -= Settings.tile.size * Settings.grid.numTileColsInRegion;
        downCenter = this.worldGrid.findGridTileXY(tile.origin.x, tile.origin.y + yShiftPixels);
      }
      if (downCenter) {
        if (tiles.length <= count) {
          tiles.push(downCenter);
        } else {
          tiles[count] = downCenter;
        }
        count++;
      }
      for (let i = 0; i < 15; i++) {
        const xShift = (i + 1) * Settings.tile.size;
        const downLeft = this.worldGrid.findGridTileXY(tile.origin.x - xShift, tile.origin.y + yShiftPixels);
        if (downLeft) {
          if (tiles.length <= count) {
            tiles.push(downLeft);
          } else {
            tiles[count] = downLeft;
          }
          count++;
        }
      }
      for (let i = 0; i < 15; i++) {
        const xShift = (i + 1) * Settings.tile.size;
        const downRight = this.worldGrid.findGridTileXY(tile.origin.x + xShift, tile.origin.y + yShiftPixels);
        if (downRight) {
          if (tiles.length <= count) {
            tiles.push(downRight);
          } else {
            tiles[count] = downRight;
          }
          count++;
        }
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     */
    addUpDestinationTiles(tile, smallGridMode) {
      const tiles = this.vectorField.destinationTileCandidates;
      let yShiftPixels = Settings.tile.size * (smallGridMode ? 15 : 25);
      let count = 0;
      let upCenter = this.worldGrid.findGridTileXY(tile.origin.x, tile.origin.y - yShiftPixels);
      while (!upCenter && yShiftPixels > 0) {
        yShiftPixels -= Settings.tile.size * Settings.grid.numTileColsInRegion;
        upCenter = this.worldGrid.findGridTileXY(tile.origin.x, tile.origin.y - yShiftPixels);
      }
      if (upCenter) {
        if (tiles.length <= count) {
          tiles.push(upCenter);
        } else {
          tiles[count] = upCenter;
        }
        count++;
      }
      for (let i = 0; i < 15; i++) {
        const xShift = (i + 1) * Settings.tile.size;
        const upLeft = this.worldGrid.findGridTileXY(tile.origin.x - xShift, tile.origin.y - yShiftPixels);
        if (upLeft) {
          if (tiles.length <= count) {
            tiles.push(upLeft);
          } else {
            tiles[count] = upLeft;
          }
          count++;
        }
      }
      for (let i = 0; i < 15; i++) {
        const xShift = (i + 1) * Settings.tile.size;
        const upRight = this.worldGrid.findGridTileXY(tile.origin.x + xShift, tile.origin.y - yShiftPixels);
        if (upRight) {
          if (tiles.length <= count) {
            tiles.push(upRight);
          } else {
            tiles[count] = upRight;
          }
          count++;
        }
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     */
    addRightDestinationTiles(tile, smallGridMode) {
      const tiles = this.vectorField.destinationTileCandidates;
      let xShiftPixels = Settings.tile.size * 25;
      let count = 0;
      let rightCenter = this.worldGrid.findGridTileXY(tile.origin.x + xShiftPixels, tile.origin.y);
      while (!rightCenter && xShiftPixels > 0) {
        xShiftPixels -= Settings.tile.size * Settings.grid.numTileColsInRegion;
        rightCenter = this.worldGrid.findGridTileXY(tile.origin.x + xShiftPixels, tile.origin.y);
      }
      if (rightCenter) {
        if (tiles.length <= count) {
          tiles.push(rightCenter);
        } else {
          tiles[count] = rightCenter;
        }
        count++;
      }
      for (let i = 0; i < 15; i++) {
        const yShift = (i + 1) * Settings.tile.size;
        const rightUp = this.worldGrid.findGridTileXY(tile.origin.x + xShiftPixels, tile.origin.y - yShift);
        if (rightUp) {
          if (tiles.length <= count) {
            tiles.push(rightUp);
          } else {
            tiles[count] = rightUp;
          }
          count++;
        }
      }
      for (let i = 0; i < 15; i++) {
        const yShift = (i + 1) * Settings.tile.size;
        const rightDown = this.worldGrid.findGridTileXY(tile.origin.x + xShiftPixels, tile.origin.y + yShift);
        if (rightDown) {
          if (tiles.length <= count) {
            tiles.push(rightDown);
          } else {
            tiles[count] = rightDown;
          }
          count++;
        }
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     */
    addCenterDestinationTiles(tile) {
      const tiles = this.vectorField.destinationTileCandidates;
      tiles.push(tile);
      let neighbors = tile.neighbors;
      for (let i = 0; i < neighbors.length; i++) {
        const neighbor = neighbors[i];
        if (neighbor) {
          tiles.push(neighbor);
        }
      }
      const topLeft = tile.getNeighborTopLeft();
      const topRight = tile.getNeighborTopRight();
      const bottomLeft = tile.getNeighborBottomLeft();
      const bottomRight = tile.getNeighborBottomRight();
      if (topLeft) {
        tiles.push(topLeft);
      }
      if (topRight) {
        tiles.push(topRight);
      }
      if (bottomLeft) {
        tiles.push(bottomLeft);
      }
      if (bottomRight) {
        tiles.push(bottomRight);
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @returns {number}
     */
    calculateCommonTileMineScore(tile) {
      if (tile.borderCode === TileBorderCode.ALL_BORDERS_OPEN) {
        return VectorFieldScores.WORTHLESS;
      }
      return this.calculateNeighborTileScore(tile);
    }
    /**
     * Calculate the mine score of a common tile based on that state of its neighbors.
     * @private
     * @param {GridTile} tile
     * @returns {number}
     */
    calculateNeighborTileScore(tile) {
      let hiddenNeighbor = false;
      let revealCavern = false;
      const neighbors = tile.neighbors;
      for (let i = 0; i < neighbors.length; i++) {
        const neighbor = neighbors[i];
        if (!neighbor) {
          continue;
        }
        if (neighbor.lighting.everVisibleToCharacter || !neighbor.tileType.lightingSupported) {
          continue;
        }
        if (neighbor.open) {
          revealCavern = true;
        } else {
          hiddenNeighbor = true;
        }
      }
      let score = 0;
      if (hiddenNeighbor) {
        score += VectorFieldScores.COMMON_HIDDEN_NEIGHBOR;
      }
      if (revealCavern) {
        score += VectorFieldScores.COMMON_REVEAL_CAVERN;
      }
      return score;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
    }
    /**
     * @override
     */
    resetForPrestige() {
    }
  };

  // src/model/control/MineMode.js
  var MineMode = class {
    /**
     * 
     * @param {string} id 
     * @param {string} name 
     * @param {string} iconFileName
     */
    constructor(id, name, iconFileName) {
      this.id = id;
      this.name = name;
      this.iconFileName = iconFileName;
    }
  };

  // src/model/control/MineModes.js
  var MineModes = {
    /**
     * @constant
     * @type {MineMode}
     */
    MINE_DEEPER: new MineMode("1", "Deeper", Images.pick),
    /**
     * @constant
     * @type {MineMode}
     */
    MINE_SHALLOWER: new MineMode("2", "Shallower", Images.pick),
    /**
     * @constant
     * @type {MineMode}
     */
    MINE_CURRENT: new MineMode("3", "Current Depth", Images.pick),
    /**
     * @constant
     * @type {MineMode}
     */
    MINE_AUTO: new MineMode("4", "Automated", Images.pick)
  };

  // src/model/control/MineControl.js
  var VectorFieldDirectionCode = {
    LOCKED_NO_MOVE: -3,
    MOVE_UP_LARGE: -2,
    MOVE_UP_SMALL: -1,
    CURRENT: 0,
    MOVE_DOWN_SMALL: 1,
    MOVE_DOWN_LARGE: 2
  };
  var MineControl = class extends GameModel {
    /**
     * 
     * @param {Crew} crew 
     * @param {PartyTarget} partyTarget 
     * @param {Damage} damage
     * @param {WorldGrid} worldGrid 
     * @param {VectorFieldGenerator} vectorFieldGenerator 
     * @param {VectorField} vectorField 
     */
    constructor(crew, partyTarget, damage, worldGrid, vectorFieldGenerator, vectorField) {
      super();
      this.crew = crew;
      this.partyTarget = partyTarget;
      this.damage = damage;
      this.worldGrid = worldGrid;
      this.vectorFieldGenerator = vectorFieldGenerator;
      this.vectorField = vectorField;
      this.crewModes = [MineModes.MINE_DEEPER, MineModes.MINE_SHALLOWER, MineModes.MINE_CURRENT, MineModes.MINE_AUTO];
      this.mineTileStep = 40;
      this.prevTotalPickDamagePerTurn = new BigNum(0);
      this.prevMode = null;
      this.workingHealth = new BigNum(0);
      this.tileHealthPerDamageThreshold = new BigNum(0.05);
      this.debugTileHealthNegligible = false;
      this.debugSearchGridSmall = false;
      this.debugIgnorePremium = false;
      this.debugIgnoreCommon = false;
      this.debugGoalDescription = "";
      this.activeMode = MineModes.MINE_AUTO;
    }
    /**
     * @param {MineMode} mineMode 
     */
    setModeActive(mineMode) {
      this.activeMode = mineMode;
    }
    /**
     * This is called by the save loader.
     * @param {string} modeId 
     */
    setActiveModeById(modeId) {
      const mode = this.findModeById(modeId);
      if (!mode) {
        console.log("MineControl.setActiveModeById() Failed to find mode id: " + modeId);
        return;
      }
      this.setModeActive(mode);
    }
    /**
     * @private
     * @param {string} modeId 
     * @returns {MineMode}
     */
    findModeById(modeId) {
      for (let i = 0; i < this.crewModes.length; i++) {
        const mode = this.crewModes[i];
        if (mode.id === modeId) {
          return mode;
        }
      }
      return null;
    }
    updateForTurn() {
      const crewCenterTile = this.crew.calculateCrewCenterTile();
      if (!crewCenterTile) {
        console.log("MineControl.updateForTurn() no crew center tile");
        return;
      }
      if (this.activeMode === MineModes.MINE_AUTO) {
        const mineSecondsDifference = this.partyTarget.targetMineSeconds !== this.partyTarget.defaultMineSeconds;
        const pickDamageDifference = !this.prevTotalPickDamagePerTurn.equals(this.damage.totalPickDamagePerTurn);
        if (mineSecondsDifference || pickDamageDifference) {
          this.partyTarget.targetMineSeconds = this.partyTarget.defaultMineSeconds;
          this.prevTotalPickDamagePerTurn.copy(this.damage.totalPickDamagePerTurn);
          this.partyTarget.calculateTargetRow();
        }
      } else {
        this.checkForTargetAdjust(crewCenterTile, this.prevMode !== this.activeMode);
      }
      this.prevMode = this.activeMode;
      this.vectorField.tileHealthNegligible = this.isTileHealthNegligible(crewCenterTile);
      this.debugTileHealthNegligible = this.vectorField.tileHealthNegligible;
      this.applyMiningLogic(crewCenterTile);
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @returns {boolean}
     */
    isTileHealthNegligible(tile) {
      tile.tileType.layerDescription.calculateTileHealth(tile.getTileRow(), this.workingHealth);
      this.workingHealth.div(this.damage.totalPickDamagePerTurn);
      return this.workingHealth.lessThan(this.tileHealthPerDamageThreshold);
    }
    /**
     * @private
     * @param {GridTile} centerTile
     * @param {boolean} modeChanged
     */
    checkForTargetAdjust(centerTile, modeChanged) {
      const tileRow = centerTile.getTileRow();
      if (modeChanged) {
        if (this.activeMode === MineModes.MINE_CURRENT) {
          this.applyMineCurrentTargetAdjust(tileRow);
        } else if (this.activeMode === MineModes.MINE_SHALLOWER) {
          this.applyMineShallowerTargetAdjust(tileRow);
        } else if (this.activeMode === MineModes.MINE_DEEPER) {
          this.applyMineDeeperTargetAdjust(tileRow);
        }
        return;
      }
      const targetRow = this.partyTarget.targetRow;
      const minRow = targetRow - 15;
      const maxRow = targetRow + 15;
      if (tileRow < minRow) {
        if (this.activeMode === MineModes.MINE_SHALLOWER) {
          this.applyMineShallowerTargetAdjust(tileRow);
        }
      } else if (tileRow > maxRow) {
        if (this.activeMode === MineModes.MINE_DEEPER) {
          this.applyMineDeeperTargetAdjust(tileRow);
        }
      } else {
        if (this.activeMode === MineModes.MINE_DEEPER) {
          this.applyMineDeeperTargetAdjust(tileRow);
        } else if (this.activeMode === MineModes.MINE_SHALLOWER) {
          this.applyMineShallowerTargetAdjust(tileRow);
        }
      }
    }
    /**
     * @private
     * @param {number} tileRow
     */
    applyMineCurrentTargetAdjust(tileRow) {
      this.partyTarget.deriveTargetSecondsForRow(tileRow);
      this.partyTarget.calculateTargetRow();
    }
    /**
     * @private
     * @param {number} tileRow
     */
    applyMineShallowerTargetAdjust(tileRow) {
      const shallowerRow = Math.max(Settings.target.minTargetRow, tileRow - this.mineTileStep);
      this.partyTarget.deriveTargetSecondsForRow(shallowerRow);
      this.partyTarget.calculateTargetRow();
    }
    /**
     * @private
     * @param {number} tileRow
     */
    applyMineDeeperTargetAdjust(tileRow) {
      this.partyTarget.deriveTargetSecondsForRow(tileRow + this.mineTileStep);
      this.partyTarget.calculateTargetRow();
    }
    /**
     * @private
     * @param {GridTile} crewCenterTile
     */
    applyMiningLogic(crewCenterTile) {
      const tile = this.vectorField.centerTile ? this.vectorField.centerTile : crewCenterTile;
      const vectorFieldTileRow = tile.getTileRow();
      const crewTileRow = crewCenterTile.getTileRow();
      const targetRow = this.partyTarget.targetRow;
      const priorityTileVisible = this.vectorField.isPriorityTileVisible();
      let directionCode = 0;
      if (this.activeMode === MineModes.MINE_CURRENT) {
        if (crewTileRow < -5) {
          directionCode = VectorFieldDirectionCode.MOVE_DOWN_LARGE;
        } else {
          directionCode = VectorFieldDirectionCode.CURRENT;
        }
      } else if (this.activeMode === MineModes.MINE_SHALLOWER) {
        directionCode = vectorFieldTileRow > Settings.target.minTargetRow ? VectorFieldDirectionCode.MOVE_UP_LARGE : VectorFieldDirectionCode.CURRENT;
      } else if (this.activeMode === MineModes.MINE_DEEPER) {
        directionCode = VectorFieldDirectionCode.MOVE_DOWN_LARGE;
      } else {
        const minRowMinor = Math.max(Settings.target.minTargetRow, targetRow - 15);
        const minRowMajor = Math.max(Settings.target.minTargetRow, targetRow - 25);
        const maxRowMinor = targetRow + 15;
        const maxRowMajor = targetRow + 25;
        if (vectorFieldTileRow < minRowMajor) {
          directionCode = VectorFieldDirectionCode.MOVE_DOWN_LARGE;
        } else if (vectorFieldTileRow < minRowMinor) {
          directionCode = VectorFieldDirectionCode.MOVE_DOWN_SMALL;
        } else if (vectorFieldTileRow > maxRowMajor) {
          directionCode = VectorFieldDirectionCode.MOVE_UP_LARGE;
        } else if (vectorFieldTileRow > maxRowMinor) {
          directionCode = VectorFieldDirectionCode.MOVE_UP_SMALL;
        } else {
          directionCode = VectorFieldDirectionCode.CURRENT;
        }
      }
      if (priorityTileVisible) {
        if (directionCode !== VectorFieldDirectionCode.MOVE_DOWN_LARGE && directionCode !== VectorFieldDirectionCode.MOVE_UP_LARGE) {
          directionCode = VectorFieldDirectionCode.LOCKED_NO_MOVE;
        }
      }
      let moveUpOk = true;
      let moveDownOk = true;
      let bigStepY = false;
      let bigStepX = false;
      let ignorePremiumTiles = false;
      let ignoreCommonTiles = this.vectorField.tileHealthNegligible;
      let smallGridMode = false;
      if (directionCode === VectorFieldDirectionCode.LOCKED_NO_MOVE) {
        this.debugGoalDescription = "mine priority tiles";
      } else if (directionCode === VectorFieldDirectionCode.MOVE_DOWN_LARGE) {
        moveUpOk = false;
        moveDownOk = vectorFieldTileRow < crewTileRow + 6;
        bigStepY = true;
        ignorePremiumTiles = this.vectorField.tileHealthNegligible;
        ignoreCommonTiles = true;
        smallGridMode = true;
        this.debugGoalDescription = "mine downwards";
      } else if (directionCode === VectorFieldDirectionCode.MOVE_DOWN_SMALL) {
        moveUpOk = false;
        moveDownOk = vectorFieldTileRow < crewTileRow + 10;
        this.debugGoalDescription = "mine down a little";
      } else if (directionCode === VectorFieldDirectionCode.MOVE_UP_LARGE) {
        moveDownOk = false;
        bigStepY = true;
        moveUpOk = vectorFieldTileRow > crewTileRow - 6;
        ignorePremiumTiles = this.vectorField.tileHealthNegligible;
        ignoreCommonTiles = true;
        smallGridMode = true;
        this.debugGoalDescription = "mine upwards";
      } else if (directionCode === VectorFieldDirectionCode.MOVE_UP_SMALL) {
        moveDownOk = false;
        moveUpOk = vectorFieldTileRow > crewTileRow - 10;
        this.debugGoalDescription = "mine up a little";
      } else {
        moveDownOk = vectorFieldTileRow < targetRow;
        moveUpOk = vectorFieldTileRow > targetRow;
        bigStepX = this.vectorField.tileHealthNegligible;
        this.debugGoalDescription = "mine around target depth";
      }
      this.crew.values.fallSpeedBonusActive.setValue(ignorePremiumTiles && directionCode === VectorFieldDirectionCode.MOVE_DOWN_LARGE);
      const vectorFieldCenterTile = this.calculateVectorFieldCenterTile(crewCenterTile, this.vectorField.centerTile, directionCode, moveUpOk, moveDownOk, bigStepY, bigStepX);
      this.debugSearchGridSmall = smallGridMode;
      this.debugIgnorePremium = ignorePremiumTiles;
      this.debugIgnoreCommon = ignoreCommonTiles;
      let destinationDirection = 0;
      switch (directionCode) {
        case VectorFieldDirectionCode.CURRENT:
          destinationDirection = 3;
          break;
        case VectorFieldDirectionCode.LOCKED_NO_MOVE:
          destinationDirection = 0;
          break;
        case VectorFieldDirectionCode.MOVE_DOWN_LARGE:
        case VectorFieldDirectionCode.MOVE_DOWN_SMALL:
          destinationDirection = 1;
          break;
        case VectorFieldDirectionCode.MOVE_UP_LARGE:
        case VectorFieldDirectionCode.MOVE_UP_SMALL:
          destinationDirection = 2;
          break;
      }
      this.vectorFieldGenerator.generateVectorField(vectorFieldCenterTile, ignoreCommonTiles, ignorePremiumTiles, smallGridMode, destinationDirection);
    }
    /**
     * @private
     * @param {GridTile} crewCenterTile 
     * @param {GridTile} vectorFieldCenterTile 
     * @param {number} directionCode 
     * @param {boolean} moveUpOk
     * @param {boolean} moveDownOk
     * @param {boolean} bigStepY
     * @param {boolean} bigStepX
     * @returns {GridTile}
     */
    calculateVectorFieldCenterTile(crewCenterTile, vectorFieldCenterTile, directionCode, moveUpOk, moveDownOk, bigStepY, bigStepX) {
      if (!vectorFieldCenterTile) {
        console.log("MineControl.calculateVectorFieldCenterTile() - no vector field center tile");
        return crewCenterTile;
      }
      if (directionCode === VectorFieldDirectionCode.LOCKED_NO_MOVE) {
        return vectorFieldCenterTile;
      }
      const xStep = bigStepX ? 4 * Settings.tile.size : Settings.tile.size;
      const dx = crewCenterTile.origin.x - vectorFieldCenterTile.origin.x;
      const x = dx == 0 ? crewCenterTile.origin.x : dx < 0 ? vectorFieldCenterTile.origin.x - Settings.tile.size : vectorFieldCenterTile.origin.x + xStep;
      let y = vectorFieldCenterTile.origin.y;
      if (directionCode === VectorFieldDirectionCode.MOVE_UP_LARGE || directionCode === VectorFieldDirectionCode.MOVE_UP_SMALL) {
        if (moveUpOk) {
          const yStep = bigStepY ? 4 * Settings.tile.size : Settings.tile.size;
          y = vectorFieldCenterTile.origin.y - yStep;
        }
      } else if (directionCode === VectorFieldDirectionCode.MOVE_DOWN_LARGE || directionCode === VectorFieldDirectionCode.MOVE_DOWN_SMALL) {
        if (moveDownOk) {
          const dy = crewCenterTile.origin.y - vectorFieldCenterTile.origin.y;
          const yStep = bigStepY ? this.calculateBigYStep(dy) : Settings.tile.size;
          y = vectorFieldCenterTile.origin.y + yStep;
        }
      } else {
        const dy = crewCenterTile.origin.y - vectorFieldCenterTile.origin.y;
        const yStep = bigStepY ? this.calculateBigYStep(dy) : Settings.tile.size;
        if (dy < 0 && moveUpOk) {
          y = vectorFieldCenterTile.origin.y - yStep;
        } else if (dy > 0 && moveDownOk) {
          y = vectorFieldCenterTile.origin.y + yStep;
        }
      }
      const newCenter = this.worldGrid.findGridTileXY(x, y);
      if (!newCenter) {
        return vectorFieldCenterTile;
      }
      return newCenter;
    }
    // TODO FAST FALLING - WE ARE CATCHING UP TO THE EDGE OF THE GRID WITHIN THE TURN.
    /**
     * How far should the vector field shift in the y-direction.
     * @private
     * @param {number} dy crew y-coordinate minus vector field y-coodinate. 
     * @returns {number} 
     */
    calculateBigYStep(dy) {
      if (dy <= 0) {
        return 4 * Settings.tile.size;
      }
      if (dy > 4 * Settings.tile.size) {
        return dy;
      } else {
        return 4 * Settings.tile.size;
      }
    }
    /////////////////////////////////////////////////
    // GameModel
    /////////////////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.setModeActive(MineModes.MINE_AUTO);
    }
    /**
     * @override
     */
    resetForPrestige() {
    }
  };

  // src/model/save/MineControlSave.js
  var MineControlSave = class {
    constructor() {
    }
    /**
     * @param {MineControl} mineControl
     * @returns {Object}
     */
    static generateSave(mineControl) {
      const saveState = {};
      saveState.activeId = mineControl.activeMode.id;
      return saveState;
    }
    /**
     * @param {MineControl} mineControl 
     * @param {Object} saveState 
     */
    static loadSave(mineControl, saveState) {
      if (!saveState) {
        return;
      }
      const modeId = saveState.activeId;
      if (modeId) {
        mineControl.setActiveModeById(modeId);
      } else {
        console.log("MineControlSave.loadSave() Failed to load mine mode.");
        mineControl.setModeActive(MineModes.MINE_AUTO);
      }
    }
  };

  // src/model/options/GameOptions.js
  var GameOptions = class {
    constructor() {
      this.crewBrainDebugEnabled = false;
      this.maxFps = -1;
      this.displayFps = false;
      this.effectsRenderingEnabled = true;
      this.depthColumnRendered = true;
      this.wireframeModeEnabled = false;
    }
    /**
     * The fps threshold in millis (for use by the GameLoop)
     * @returns {number}
     */
    getFpsMillis() {
      if (this.maxFps <= 0) {
        return 1e3 / 250;
      }
      return 1e3 / this.maxFps;
    }
  };

  // src/model/save/GameOptionsSave.js
  var GameOptionsSave = class {
    constructor() {
    }
    /**
     * @param {GameOptions} gameOptions 
     * @returns {Object}
     */
    static generateSave(gameOptions) {
      const saveState = {};
      saveState.crewBrainDebugEnabled = gameOptions.crewBrainDebugEnabled;
      saveState.maxFps = gameOptions.maxFps;
      saveState.displayFps = gameOptions.displayFps;
      saveState.dynamicLightingEnabled = gameOptions.dynamicLightingEnabled;
      saveState.effectsRenderingEnabled = gameOptions.effectsRenderingEnabled;
      saveState.depthColumnRendered = gameOptions.depthColumnRendered;
      saveState.wireframeModeEnabled = gameOptions.wireframeModeEnabled;
      return saveState;
    }
    /**
     * @param {GameOptions} gameOptions 
     * @param {Object} saveState 
     */
    static loadSave(gameOptions, saveState) {
      if (!saveState) {
        return;
      }
      gameOptions.crewBrainDebugEnabled = false;
      if (saveState.crewBrainDebugEnabled) {
        gameOptions.crewBrainDebugEnabled = true;
      }
      if (saveState.maxFps) {
        gameOptions.maxFps = saveState.maxFps;
      }
      gameOptions.displayFps = false;
      if (saveState.displayFps) {
        gameOptions.displayFps = true;
      }
      gameOptions.dynamicLightingEnabled = true;
      if (saveState.dynamicLightingEnabled !== void 0) {
        gameOptions.dynamicLightingEnabled = saveState.dynamicLightingEnabled;
      }
      gameOptions.effectsRenderingEnabled = true;
      if (saveState.effectsRenderingEnabled !== void 0) {
        gameOptions.effectsRenderingEnabled = saveState.effectsRenderingEnabled;
      }
      gameOptions.depthColumnRendered = true;
      if (saveState.depthColumnRendered !== void 0) {
        gameOptions.depthColumnRendered = saveState.depthColumnRendered;
      }
      gameOptions.wireframeModeEnabled = false;
      if (saveState.wireframeModeEnabled) {
        gameOptions.wireframeModeEnabled = true;
      }
    }
  };

  // src/model/save/SaveManager.js
  var SaveManager = class {
    /**
     * 
     * @param {GridSaveManager} gridSaveManager
     */
    constructor(gridSaveManager) {
      this.gridSaveManager = gridSaveManager;
      this.modelsSaveKey = "modelsSaveV1";
    }
    /**
     * @param {State} state 
     * @returns {boolean} True if the save file was loaded.
     */
    loadSave(state) {
      return this.loadModels(state);
    }
    /**
     * 
     * @param {State} state 
     */
    saveGame(state) {
      this.saveAllLoadedGrids(state);
      this.saveModels(state);
    }
    deleteSave() {
      localStorage.removeItem(this.modelsSaveKey);
      this.gridSaveManager.deleteAllGrids();
    }
    /**
     * @private
     * @param {State} state 
     */
    saveModels(state) {
      const modelState = this.generateModelState(state);
      if (!modelState) {
        console.log("SaveManager.saveModels() Failed to generate models save state");
        return;
      }
      const modelStateJsonString = JSON.stringify(modelState);
      if (!modelStateJsonString) {
        console.log("SaveManager.saveModels() Failed to stringify models state");
        return;
      }
      const compressedStateString = LZString2.compressToUTF16(modelStateJsonString);
      if (!compressedStateString) {
        console.log("SaveManager.saveModels() Failed to compress state for models");
        return;
      }
      localStorage.setItem(this.modelsSaveKey, compressedStateString);
    }
    /**
     * @private
     * @param {State} state 
     * @returns {boolean} True if the models were loaded from the save file.
     */
    loadModels(state) {
      const compressedStateString = localStorage.getItem(this.modelsSaveKey);
      if (!compressedStateString) {
        console.log("SaveManager.loadModels() No save found.");
        return false;
      }
      const modelStateJsonString = LZString2.decompressFromUTF16(compressedStateString);
      if (!modelStateJsonString) {
        console.log("SaveManager.loadModels() Failed to decompress save.");
        return false;
      }
      const modelState = JSON.parse(modelStateJsonString);
      if (!modelState) {
        console.log("SaveManager.loadModels() Failed to parse save as JSON.");
        return false;
      }
      return this.loadModelState(state, modelState);
    }
    /**
     * @private
     * @param {State} state 
     * @returns {Object}
     */
    generateModelState(state) {
      const modelState = {};
      modelState.state = StateSave.generateSave(state);
      modelState.gridSaveManager = GridSaveManagerSave.generateSave(state.gridSaveManager);
      modelState.time = GameTimeSave.generateSave(state.gameTime);
      modelState.projection = ProjectionSave.generateSave(state.projection);
      modelState.partyTarget = PartyTargetSave.generateSave(state.partyTarget);
      modelState.gameOptions = GameOptionsSave.generateSave(state.gameOptions);
      modelState.crew = CrewSave.generateSave(state.crew);
      modelState.totals = TotalsSave.generateSave(state.totals);
      modelState.damage = DamageSave.generateSave(state.damage);
      modelState.values = ValuesSave.generateSave(state.values);
      modelState.runStats = StatisticsSave.generateSave(state.runStatistics);
      modelState.globalStats = StatisticsSave.generateSave(state.globalStatistics);
      modelState.minedUpgradeCollection = MinedUpgradeCollectionSave.generateSave(state.minedUpgradeCollection);
      modelState.pickUpgradeCollection = PickUpgradeCollectionSave.generateSave(state.pickUpgradeCollection);
      modelState.goldUpgradeCollection = GoldUpgradeCollectionSave.generateSave(state.goldUpgradeCollection);
      modelState.bonusCollection = BonusCollectionSave.generateSave(state.bonusCollection);
      modelState.automation = AutomationSave.generateSave(state.automationManager);
      modelState.mineControl = MineControlSave.generateSave(state.mineControl);
      modelState.skillTree = SkillTreeSave.generateSave(state.skillTreeGraph);
      return modelState;
    }
    /**
     * @private
     * @param {State} state 
     * @param {Object} modelState 
     * @returns {boolean}
     */
    loadModelState(state, modelState) {
      if (!modelState) {
        return false;
      }
      let success = true;
      try {
        StateSave.loadSave(state, modelState.state);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load State:", error.message);
        success = false;
      }
      try {
        GridSaveManagerSave.loadSave(state.gridSaveManager, modelState.gridSaveManager);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load GridSaveManager:", error.message);
        success = false;
      }
      try {
        GameTimeSave.loadSave(state.gameTime, modelState.time);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load GameTime:", error.message);
        success = false;
      }
      try {
        ProjectionSave.loadSave(state.projection, modelState.projection);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load Projection:", error.message);
        success = false;
      }
      try {
        CrewSave.loadSave(state.crew, modelState.crew);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load Crew:", error.message);
        success = false;
      }
      try {
        TotalsSave.loadSave(state.totals, modelState.totals);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load Totals:", error.message);
        success = false;
      }
      try {
        DamageSave.loadSave(state.damage, modelState.damage);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load Damage:", error.message);
        success = false;
      }
      try {
        ValuesSave.loadSave(state.values, modelState.values);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load Values:", error.message);
        success = false;
      }
      try {
        StatisticsSave.loadSave(state.runStatistics, modelState.runStats);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load Statistics (run):", error.message);
        success = false;
      }
      try {
        StatisticsSave.loadSave(state.globalStatistics, modelState.globalStats);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load Statistics (global):", error.message);
        success = false;
      }
      try {
        PartyTargetSave.loadSave(state.partyTarget, modelState.partyTarget);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load PartyTarget:", error.message);
        success = false;
      }
      try {
        GameOptionsSave.loadSave(state.gameOptions, modelState.gameOptions);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load PartyTarget:", error.message);
        success = false;
      }
      try {
        MinedUpgradeCollectionSave.loadSave(state.minedUpgradeCollection, state.upgradeCreators, modelState.minedUpgradeCollection);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load MinedUpgradeCollection:", error.message);
        success = false;
      }
      try {
        PickUpgradeCollectionSave.loadSave(state.pickUpgradeCollection, modelState.pickUpgradeCollection);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load PickUpgradeCollection:", error.message);
        success = false;
      }
      try {
        GoldUpgradeCollectionSave.loadSave(state.goldUpgradeCollection, modelState.goldUpgradeCollection);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load GoldUpgradeCollection:", error.message);
        success = false;
      }
      try {
        BonusCollectionSave.loadSave(state.bonusCollection, modelState.bonusCollection);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load BonusCollection:", error.message);
        success = false;
      }
      try {
        AutomationSave.loadSave(state.automationManager, modelState.automation);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load AutomationSave:", error.message);
        success = false;
      }
      try {
        MineControlSave.loadSave(state.mineControl, modelState.mineControl);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load MineControlSave:", error.message);
        success = false;
      }
      try {
        SkillTreeSave.loadSave(state.skillTreeGraph, modelState.skillTree);
      } catch (error) {
        console.error("SaveManager.loadModelState() Failed to load SkillTreeSave:", error.message);
        success = false;
      }
      return success;
    }
    /**
     * @private
     * @param {State} state 
     */
    saveAllLoadedGrids(state) {
      const grids = state.worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const grid = grids[i];
        if (grid && grid.isLoaded()) {
          this.gridSaveManager.saveGridState(grid);
        }
      }
    }
    /**
     * @param {State} state 
     * @returns {string}
     */
    getSaveStateForExport(state) {
      const modelState = this.generateModelState(state);
      if (!modelState) {
        console.log("SaveManager.getSaveState() Failed to generate models save state");
        return null;
      }
      const gridState = this.gridSaveManager.generateGridStateForExport(state.worldGrid);
      if (!gridState) {
        console.log("SaveManager.getSaveState() Failed to generate grid state");
      }
      const saveState = {
        model: modelState,
        grid: gridState
      };
      const saveStateJsonString = JSON.stringify(saveState);
      if (!saveStateJsonString) {
        console.log("SaveManager.getSaveState() Failed to stringify state");
        return null;
      }
      const compressedStateString = LZString2.compressToBase64(saveStateJsonString);
      if (!compressedStateString) {
        console.log("SaveManager.getSaveState() Failed to compress state");
        return null;
      }
      return compressedStateString;
    }
    /**
     * @param {State} state 
     * @param {string} saveStateString 
     * @returns {boolean}
     */
    importSave(state, saveStateString) {
      if (!saveStateString) {
        console.log("SaveManager.importSave() No save found.");
        return false;
      }
      const saveStateJsonString = LZString2.decompressFromBase64(saveStateString);
      if (!saveStateJsonString) {
        console.log("SaveManager.importSave() Failed to decompress save.");
        return false;
      }
      const saveState = JSON.parse(saveStateJsonString);
      if (!saveState) {
        console.log("SaveManager.importSave() Failed to parse save as JSON.");
        return false;
      }
      const modelState = saveState.model;
      const worldGridState = saveState.grid;
      const modelStateLoaded = this.loadModelState(state, modelState);
      console.log("SaveManager.importSave() load model state:" + modelStateLoaded);
      if (!modelStateLoaded) {
        return false;
      }
      this.gridSaveManager.deleteAllGrids();
      const worldGridStateLoaded = this.gridSaveManager.importGridState(state.worldGrid, worldGridState);
      console.log("SaveManager.importSave() import grid state:" + worldGridStateLoaded);
      if (worldGridStateLoaded) {
        console.log("SaveManager.importSave() saving newly imported state.");
        const grids = state.worldGrid.grids;
        for (let i = 0; i < grids.length; i++) {
          const grid = grids[i];
          if (grid) {
            console.log("SaveManager.importSave() SAVING GRID STATE.");
            this.gridSaveManager.saveGridState(grid);
          }
        }
        this.saveModels(state);
      } else {
        console.log("SaveManager.importSave() FAIL modelStateLoaded=" + modelStateLoaded + " worldGridStateLoaded=" + worldGridStateLoaded);
      }
      return worldGridStateLoaded;
    }
  };

  // src/model/sound/SoundEffectManager.js
  var SoundEffectManager = class {
    constructor() {
    }
    /**
     * @param {SoundEffect} soundEffect 
     */
    playSound(soundEffect) {
      if (!soundEffect) {
        return;
      }
    }
  };

  // src/logic/PanAnimation.js
  var PanAnimation = class extends GameModel {
    /**
     * @param {Projection} projection 
     * @param {Crew} crew
     */
    constructor(projection, crew) {
      super();
      this.projection = projection;
      this.crew = crew;
      this.animating = false;
      this.workingCenter = new Vector(0, 0);
      this.deltaThreshold = 1.5;
      this.targetAnimationMillis = 200;
    }
    startAnimation() {
      if (this.animating) {
        return;
      }
      this.crew.calculateCrewCenterCoordinate(this.workingCenter);
      const distance = Fast.dist(this.workingCenter, this.projection.gridCenter);
      if (distance > Settings.grid.gridPixelWidth * 2) {
        this.projection.setGridCenter(this.workingCenter.x, this.workingCenter.y);
        this.projection.stayCenteredOnCharacter = true;
        return;
      }
      const deltaX = this.workingCenter.x - this.projection.gridCenter.x;
      const deltaY = this.workingCenter.y - this.projection.gridCenter.y;
      if (deltaX === 0 && deltaY === 0) {
        this.animating = false;
        this.projection.stayCenteredOnCharacter = true;
        return;
      }
      this.animating = true;
    }
    /**
     * @param {number} frameTimeRatio 
     * @returns {boolean} True if we were animating, but now we're done.
     */
    updateForFrame(frameTimeRatio) {
      if (!this.animating) {
        return false;
      }
      this.crew.calculateCrewCenterCoordinate(this.workingCenter);
      const deltaX = this.workingCenter.x - this.projection.gridCenter.x;
      const deltaY = this.workingCenter.y - this.projection.gridCenter.y;
      if (deltaX === 0 && deltaY === 0) {
        this.animating = false;
        return true;
      }
      const deltaXAbs = Math.abs(deltaX);
      const deltaYAbs = Math.abs(deltaY);
      const xPerFrame = deltaX / this.targetAnimationMillis * Settings.time.defaultMillisPerFrame;
      const yPerFrame = deltaY / this.targetAnimationMillis * Settings.time.defaultMillisPerFrame;
      const xMotion = xPerFrame * frameTimeRatio;
      const yMotion = yPerFrame * frameTimeRatio;
      let newX;
      let newY;
      let doneX;
      let doneY;
      if (deltaXAbs < this.deltaThreshold || deltaXAbs < xMotion) {
        newX = this.workingCenter.x;
        doneX = true;
      } else {
        newX = this.projection.gridCenter.x + xMotion;
        doneX = false;
      }
      if (deltaYAbs < this.deltaThreshold || deltaYAbs < yMotion) {
        newY = this.workingCenter.y;
        doneY = true;
      } else {
        newY = this.projection.gridCenter.y + yMotion;
        doneY = false;
      }
      this.projection.setGridCenter(newX, newY);
      if (doneX && doneY) {
        this.projection.stayCenteredOnCharacter = true;
        this.animating = false;
        return true;
      }
      return false;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetFull() {
      this.animating = false;
    }
    /**
     * @override
     */
    resetForPrestige() {
      this.resetFull();
    }
  };

  // src/model/character/turn/MineTurnAction.js
  var MineTurnAction = class extends TurnAction {
    /**
     * @param {TileMinedLogic} tileMinedLogic
     */
    constructor(tileMinedLogic) {
      super();
      this.tileMinedLogic = tileMinedLogic;
    }
    /**
     * @override
     * @param {PartyCharacter} character The character making the turn action.
     * @param {number} frameTimeRatio The time frame ratio.
     * @param {boolean} turnStart True if this is the start of a turn.
     */
    performAction(character, frameTimeRatio, turnStart) {
      const tile = character.position.tile;
      if (!tile) {
        character.resetTurnState();
        return;
      }
      const mineTile = character.target.mineTile;
      if (!mineTile) {
        character.resetTurnState();
        return;
      }
      if (mineTile.open) {
        character.resetTurnState();
        return;
      }
      if (!tile.isNeighborTile(mineTile)) {
        character.resetTurnState();
        return;
      }
      character.setCharacterAction(CharacterAction.MINE);
      if (character.position.worldCoordinateOrigin.x !== mineTile.origin.x) {
        character.position.facingLeft = character.position.worldCoordinateOrigin.x > mineTile.origin.x;
      }
      if (!turnStart) {
        return;
      }
      if (this.tileMinedLogic.mineTileForTurn(character, mineTile)) {
        character.resetTurnState();
      }
    }
    /**
     * @override
     * @returns {string}
     */
    toString() {
      return "MineTurnAction";
    }
  };

  // src/model/character/turn/PartyMoveTurnAction.js
  var PartyMoveTurnAction = class extends MoveTurnAction {
    /**
     * @param {StatisticsIncrementor} statisticsIncrementor 
     * @param {MineDamageLogic} mineDamageLogic
     */
    constructor(statisticsIncrementor, mineDamageLogic) {
      super();
      this.statisticsIncrementor = statisticsIncrementor;
      this.mineDamageLogic = mineDamageLogic;
    }
    /**
     * @override
     * @param {Character} character The character making the turn action.
     * @param {number} frameTimeRatio The time frame ratio.
     * @param {boolean} turnStart True if this is the start of a turn.
     */
    performAction(character, frameTimeRatio, turnStart) {
      super.performAction(character, frameTimeRatio, turnStart);
      const tile = character.position.tile;
      if (!tile) {
        return;
      }
      const maxDepthBefore = this.statisticsIncrementor.globalStatitics.maxDepth;
      const depth = tile.getTileRow();
      this.statisticsIncrementor.tileDepth(depth);
      if (maxDepthBefore < depth) {
        this.mineDamageLogic.calculateTotalMineDamagePerTurn();
      }
    }
  };

  // src/model/crew/CrewBrain.js
  var CrewBrain = class {
    /**
     * @param {Crew} crew
     * @param {VectorField} vectorField 
     * @param {PartyTarget} partyTarget
     * @param {PathPlanFinder} pathPlanFinder
     * @param {TileMinedLogic} tileMinedLogic
     * @param {MineDamageLogic} mineDamageLogic
     * @param {StatisticsIncrementor} statisticsIncrementor
     */
    constructor(crew, vectorField, partyTarget, pathPlanFinder, tileMinedLogic, mineDamageLogic, statisticsIncrementor) {
      this.crew = crew;
      this.vectorField = vectorField;
      this.partyTarget = partyTarget;
      this.pathPlanFinder = pathPlanFinder;
      this.mineTurnAction = new MineTurnAction(tileMinedLogic);
      this.moveTurnAction = new PartyMoveTurnAction(statisticsIncrementor, mineDamageLogic);
      this.unassignedMiners = [];
      this.unassignedMinerCount = 0;
      this.claimedTiles = [];
      this.bestTiles = [];
      this.workingPosition = new Vector(0, 0);
      this.nearDistance2 = 5 * Settings.tile.size * (5 * Settings.tile.size);
    }
    updateForTurn() {
      if (this.vectorField.ignoreCommonTiles && this.vectorField.ignorePremiumTiles) {
        this.assignTurnsForDestinationTiles();
      } else {
        if (this.vectorField.isVectorFieldMineTargetsEmpty()) {
          this.assignTurnsForDestinationTiles();
        } else {
          this.assignTurnsForVectorField();
        }
      }
      this.setTurnActions();
    }
    /**
     * @private
     */
    assignTurnsForDestinationTiles() {
      const miners = this.crew.miners;
      const destinationTiles = this.vectorField.destinationTileCandidates;
      for (let i = 0; i < miners.length; i++) {
        const miner = miners[i];
        const closestDestinationTile = this.findClosestTile(miner.position.worldCoordinateOrigin, destinationTiles);
        if (closestDestinationTile) {
          if (this.evaluateMinerDestination(miner, closestDestinationTile)) {
            continue;
          }
          this.assignMinerTarget(miner, closestDestinationTile, null);
          continue;
        }
        miner.resetTurnState();
      }
    }
    // /**
    //  * @private
    //  */
    // assignTurnsForDestinationTiles() {
    //     const miners = this.crew.miners;
    //     const destinationTiles = this.vectorField.destinationTileCandidates;
    //     ///////////////////////////////////////
    //     // Initialize unassigned miners
    //     ///////////////////////////////////////
    //     this.claimedTiles.length = 0;
    //     // Clear out the array
    //     this.unassignedMiners.fill(null);
    //     this.unassignedMinerCount = 0;
    //     ///////////////////////////////////////
    //     // Evaluate the miner targets, populate unassigned miners
    //     ///////////////////////////////////////
    //     for (let i = 0; i < miners.length; i++) {
    //         this.evaluateMinerDestination(miners[i]);
    //     }
    //     for (let i = 0; i < this.unassignedMiners.length; i++) {
    //         const miner = this.unassignedMiners[i];
    //         if (!miner) {
    //             continue;
    //         }
    //         if (destinationTiles.length > 0 && this.assignMinerToClosestDestinationTile(miner, i, destinationTiles)) {
    //             continue;
    //         }
    //     }
    //     ///////////////////////////////////////
    //     // Leftovers: stand still
    //     ///////////////////////////////////////
    //     if (this.unassignedMinerCount > 0) {
    //         for (let i = 0; i < this.unassignedMiners.length; i++) {
    //             const miner = this.unassignedMiners[i];
    //             if (!miner) {
    //                 continue;
    //             }
    //             miner.resetTurnState();
    //             miner.setCharacterAction(CharacterAction.STAND);
    //         }
    //     }
    // }
    // /**
    //  * @private
    //  * @param {Character} miner 
    //  * @param {GridTile[]} destinationTiles 
    //  * @returns {boolean}
    //  */
    // assignMinerToClosestDestinationTile(miner, destinationTiles) {
    //     const tile = this.findClosestTile(miner.position.worldCoordinateOrigin, destinationTiles);
    //     if (!tile) {
    //         return false;
    //     }
    //     this.assignMinerTarget(miner, tile, null);
    //     return true;
    // }
    /**
     * @private
     */
    assignTurnsForVectorField() {
      const miners = this.crew.miners;
      const priorityTiles = this.vectorField.priorityMiningCandidates;
      const currencyTiles = this.vectorField.currencyMiningCandidates;
      const commonTiles = this.vectorField.commonMiningCandidates;
      this.claimedTiles.length = 0;
      this.unassignedMiners.fill(null);
      this.unassignedMinerCount = 0;
      for (let i = 0; i < miners.length; i++) {
        this.evaluateMinerTarget(miners[i]);
      }
      for (let i = 0; i < this.unassignedMiners.length; i++) {
        const miner = this.unassignedMiners[i];
        if (!miner) {
          continue;
        }
        if (priorityTiles.length > 0 && this.assignMinerToClosestAvailableTile(miner, i, priorityTiles)) {
          continue;
        }
        if (currencyTiles.length > 0 && this.assignMinerToClosestAvailableTile(miner, i, currencyTiles)) {
          continue;
        }
        if (commonTiles.length > 0 && this.assignMinerToClosestAvailableTile(miner, i, commonTiles)) {
          continue;
        }
      }
      if (this.unassignedMinerCount > 0) {
        for (let i = this.unassignedMiners.length - 1; i >= 0; i--) {
          const miner = this.unassignedMiners[i];
          if (!miner) {
            continue;
          }
          this.assignMinerToHelpOthers(miner, i);
        }
      }
      if (this.unassignedMinerCount > 0) {
        for (let i = 0; i < this.unassignedMiners.length; i++) {
          const miner = this.unassignedMiners[i];
          if (!miner) {
            continue;
          }
          miner.resetTurnState();
          miner.setCharacterAction(CharacterAction.STAND);
        }
      }
    }
    /**
     * @private
     * @param {Character} miner 
     * @param {number} minerIndex
     */
    assignMinerToHelpOthers(miner, minerIndex) {
      const mineTile = this.findClosestTargetedMineTile(miner.position.tile.origin);
      if (!mineTile) {
        return;
      }
      const neighborTile = this.findBestNeighborTile(mineTile, miner.position.tile);
      if (!neighborTile) {
        console.log("CrewBrain.assignMinerToHelpOthers() failed to find miner for tile.");
        return;
      }
      this.unassignedMiners[minerIndex] = null;
      this.unassignedMinerCount--;
      this.assignMinerTarget(miner, neighborTile, mineTile);
    }
    /**
     * @private
     * @param {Character} miner 
     * @param {number} unassignedMinerIndex
     * @param {GridTile[]} tiles 
     * @returns {boolean}
     */
    assignMinerToClosestAvailableTile(miner, unassignedMinerIndex, tiles) {
      const tile = this.findClosestUnclaimedTile(miner.position.worldCoordinateOrigin, tiles);
      if (!tile) {
        return false;
      }
      if (!this.claimTargetForMiner(miner, tile)) {
        return false;
      }
      this.unassignedMiners[unassignedMinerIndex] = null;
      this.unassignedMinerCount--;
      return true;
    }
    /**
     * @private
     * @param {Character} miner 
     * @param {GridTile} tile 
     * @returns {boolean}
     */
    claimTargetForMiner(miner, tile) {
      const neighborTile = this.findBestNeighborTile(tile, miner.position.tile);
      if (!neighborTile) {
        console.log("CrewBrain.assignTargetForMiner() failed to find miner for tile.");
        return false;
      }
      this.assignMinerTarget(miner, neighborTile, tile);
      this.claimedTiles.push(tile);
      return true;
    }
    /**
     * @private
     * @param {Character} miner 
     */
    evaluateMinerTarget(miner) {
      if (!miner.position.tile) {
        return;
      }
      const mineTile = miner.target.mineTile;
      if (mineTile) {
        if (this.isCurrentMineTargetValid(mineTile)) {
          this.claimedTiles.push(miner.target.mineTile);
          return;
        }
      }
      this.unassignedMiners[this.unassignedMinerCount] = miner;
      this.unassignedMinerCount++;
    }
    /**
     * @private
     * @param {Character} miner 
     * @param {GridTile} closestDestinationTile
     * @returns {boolean} True if the miner has a good path to the target. False if they need to be assigned.
     */
    evaluateMinerDestination(miner, closestDestinationTile) {
      if (!miner.position.tile) {
        return true;
      }
      const targetTile = miner.target.targetTile;
      if (targetTile && miner.position.pathPlan.length > 0) {
        const dist2 = targetTile.origin.distanceSquared(closestDestinationTile.origin);
        if (dist2 <= this.nearDistance2) {
          return true;
        }
      }
      return false;
    }
    /**
     * @private
     * @param {GridTile} mineTile
     * @returns {boolean}
     */
    isCurrentMineTargetValid(mineTile) {
      if (!mineTile || mineTile.open) {
        return false;
      }
      const priorityTiles = this.vectorField.priorityMiningCandidates;
      const currencyTiles = this.vectorField.currencyMiningCandidates;
      if (mineTile.isCommon() && (priorityTiles.length > 0 || currencyTiles.length > 0)) {
        return false;
      }
      if (mineTile.pathData.getMineScore(this.vectorField.vectorFieldNumber) <= VectorFieldScores.WORTHLESS) {
        return false;
      }
      if (mineTile.isPriority() && priorityTiles.length > 0 && priorityTiles.indexOf(mineTile) !== -1) {
        return true;
      }
      if (mineTile.isCurrency() && currencyTiles.length > 0 && currencyTiles.indexOf(mineTile) !== -1) {
        return true;
      }
      const commonTiles = this.vectorField.commonMiningCandidates;
      if (mineTile.isCommon() && commonTiles.length > 0 && commonTiles.indexOf(mineTile) !== -1) {
        return true;
      }
      return false;
    }
    /**
     * @private
     * @param {Vector} origin
     * @returns {GridTile}
     */
    findClosestTargetedMineTile(origin) {
      const miners = this.crew.miners;
      let closestTile = null;
      let closestDist2 = 1e6;
      for (let i = 0; i < miners.length; i++) {
        const tile = miners[i].target.mineTile;
        if (!tile) {
          continue;
        }
        const dist2 = origin.distanceSquared(tile.origin);
        if (!closestTile || closestDist2 > dist2) {
          closestTile = tile;
          closestDist2 = dist2;
        }
      }
      return closestTile;
    }
    /**
     * @private
     * @param {Vector} origin 
     * @param {GridTile[]} tiles 
     * @returns {GridTile}
     */
    findClosestUnclaimedTile(origin, tiles) {
      let closestTile = null;
      let closestDist2 = 1e6;
      for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        const dist2 = origin.distanceSquared(tile.origin);
        if (!closestTile || closestDist2 > dist2) {
          if (this.claimedTiles.indexOf(tile) !== -1) {
            continue;
          }
          closestTile = tile;
          closestDist2 = dist2;
        }
      }
      return closestTile;
    }
    /**
     * @private
     * @param {Vector} origin 
     * @param {GridTile[]} tiles 
     * @returns {GridTile}
     */
    findClosestTile(origin, tiles) {
      let closestTile = null;
      let closestDist2 = 1e6;
      for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        if (!tile) {
          continue;
        }
        const dist2 = origin.distanceSquared(tile.origin);
        if (!closestTile || closestDist2 > dist2) {
          closestTile = tile;
          closestDist2 = dist2;
        }
      }
      return closestTile;
    }
    /**
     * @private
     * @param {Vector} origin 
     * @param {GridTile[]} tiles 
     * @returns {GridTile}
     */
    findClosestOpenTile(origin, tiles) {
      let closestTile = null;
      let closestDist2 = 1e6;
      for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];
        if (!tile || !tile.open) {
          continue;
        }
        const dist2 = origin.distanceSquared(tile.origin);
        if (!closestTile || closestDist2 > dist2) {
          closestTile = tile;
          closestDist2 = dist2;
        }
      }
      return closestTile;
    }
    /**
     * @private
     */
    setTurnActions() {
      const miners = this.crew.miners;
      for (let i = 0; i < miners.length; i++) {
        this.setMinerTurnAction(miners[i]);
      }
    }
    /**
     * @private
     * @param {PartyCharacter} miner 
     */
    setMinerTurnAction(miner) {
      const mineTile = miner.target.mineTile;
      if (miner.position.pathPlan.length > 0) {
        miner.turnAction = this.moveTurnAction;
      } else if (mineTile && !mineTile.open && miner.position.tile.isNeighborTile(mineTile)) {
        miner.turnAction = this.mineTurnAction;
      } else {
        miner.resetTurnState();
      }
    }
    /**
     * @private
     * @param {GridTile} targetTile 
     * @param {GridTile} minerTile 
     * @returns {GridTile}
     */
    findBestNeighborTile(targetTile, minerTile) {
      if (targetTile.isNeighborTile(minerTile)) {
        return minerTile;
      }
      const neighbors = targetTile.getNeighbors();
      const closestOpenNeighbor = this.findClosestOpenTile(minerTile.origin, neighbors);
      if (closestOpenNeighbor && closestOpenNeighbor.open) {
        return closestOpenNeighbor;
      }
      for (let i = 0; i < neighbors.length; i++) {
        const neighbor = neighbors[i];
        if (!neighbor || !neighbor.open) {
          continue;
        }
        if (neighbor.isNeighborTile(minerTile)) {
          return neighbor;
        }
      }
      let closest = null;
      let closestDist2 = 1e6;
      for (let i = 0; i < neighbors.length; i++) {
        const neighbor = neighbors[i];
        if (!neighbor) {
          continue;
        }
        const dist2 = neighbor.origin.distanceSquared(minerTile.origin);
        if (!closest || closestDist2 > dist2) {
          closest = neighbor;
          closestDist2 = dist2;
        }
      }
      return closest;
    }
    /**
     * @private
     * @param {PartyCharacter} miner 
     * @param {GridTile} destinationTile
     * @param {GridTile} mineTile
     */
    assignMinerTarget(miner, destinationTile, mineTile) {
      miner.target.setTargetTile(destinationTile, mineTile, "crewBrain");
      if (destinationTile !== miner.position.tile) {
        let startAtStart = true;
        if (!miner.position.isCenteredOnTile()) {
          if (miner.position.isNearTileOrigin()) {
            miner.position.setPositionToTileOrigin();
            miner.resetTurnState();
          } else {
            startAtStart = false;
          }
        }
        this.pathPlanFinder.findPartyCharacterPathPlan(miner.position.tile, destinationTile, miner.position.pathPlan, startAtStart);
      }
    }
  };

  // src/model/statistics/GlobalStatistics.js
  var GlobalStatistics = class extends Statistics {
    constructor() {
      super();
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    resetForPrestige() {
    }
  };

  // src/logic/OfflineLogic.js
  var OfflineLogic = class {
    /**
     * @param {Totals} totals 
     * @param {Values} values
     */
    constructor(totals, values) {
      this.totals = totals;
      this.values = values;
      this.tempFormatValue = new BigNum(0);
      this.workingOre = new BigNum(0);
      this.workingPrestige = new BigNum(0);
      this.workingGold = new BigNum(0);
      this.workingRuby = new BigNum(0);
    }
    /**
     * @param {Totals} totals 
     * @param {Values} values
     */
    calculateOfflineEarnings() {
      const offlineSeconds = this.totals.offlineSeconds;
      if (offlineSeconds <= 0) {
        return;
      }
      console.log("OfflineLogic.calculateOfflineEarnings() offlineSeconds=" + TimeFormatter.formatElapsedTime(offlineSeconds * 1e3));
      const offlineTurns = offlineSeconds * Settings.time.turnsPerSecond;
      const maxOfflineTurns = Settings.offline.defaultOfflineTurns + this.values.offlineTimeUpgrades.getValue() * Settings.offline.turnsPerUpgrade;
      const countedTurns = Math.min(maxOfflineTurns, offlineTurns);
      if (countedTurns <= 0) {
        this.totals.offlineSeconds = 0;
        this.totals.countedOfflineSeconds = 0;
        return;
      }
      this.calculateOfflineCurrency(countedTurns, this.totals.prestigePerTurn, this.workingPrestige);
      if (this.workingPrestige.greaterThanZero()) {
        this.totals.incrementOfflinePrestige(this.workingPrestige);
      }
      this.calculateOfflineCurrency(countedTurns, this.totals.goldPerTurn, this.workingGold);
      if (this.workingGold.greaterThanZero()) {
        this.totals.incrementOfflineGold(this.workingGold);
      }
      this.calculateOfflineCurrency(countedTurns, this.totals.rubyPerTurn, this.workingRuby);
      if (this.workingRuby.greaterThanZero()) {
        this.totals.incrementOfflineRuby(this.workingRuby);
      }
      this.calculateOfflineCurrency(countedTurns, this.totals.orePerTurn, this.workingOre);
      if (this.workingOre.greaterThanZero()) {
        this.totals.incrementOfflineOre(this.workingOre);
      }
      this.totals.countedOfflineSeconds = countedTurns * Settings.time.secondsPerTurn | 0;
      this.totals.offlineSeconds = 0;
    }
    /**
     * @private
     * @param {number} offlineTurns 
     * @param {BigNum} currencyPerTurn
     * @param {BigNum} offlineCurrency
     */
    calculateOfflineCurrency(offlineTurns, currencyPerTurn, offlineCurrency) {
      if (currencyPerTurn.equalsZero()) {
        offlineCurrency.setZero();
        return;
      }
      offlineCurrency.copy(currencyPerTurn);
      offlineCurrency.mulNumber(offlineTurns);
      offlineCurrency.floor();
    }
  };

  // src/State.js
  var State = class extends GameModel {
    /**
     * @param {GameStateControl} gameStateControl 
     */
    constructor(gameStateControl) {
      super();
      this.gameModels = [];
      this.sprites = new Sprites();
      this.worldGrid = new WorldGrid();
      this.gameModels.push(this.worldGrid);
      this.projection = new Projection();
      this.gameModels.push(this.projection);
      this.gameTime = new GameTime();
      this.gameModels.push(this.gameTime);
      this.globalStatistics = new GlobalStatistics();
      this.gameModels.push(this.globalStatistics);
      this.runStatistics = new Statistics();
      this.gameModels.push(this.runStatistics);
      this.gameOptions = new GameOptions();
      this.statisticsIncrementor = new StatisticsIncrementor(this.globalStatistics, this.runStatistics);
      this.values = new Values();
      this.gameModels.push(this.values);
      this.crew = new Crew(this.worldGrid, this.gameTime, this.sprites.characterSpritesheet, this.sprites.itemOverlaySpritesheet, this.values);
      this.gameModels.push(this.crew);
      this.gridLoadingManager = new GridLoadingManager(this.worldGrid, this.projection);
      this.gameModels.push(this.gridLoadingManager);
      this.gameVisible = true;
      this.gamePaused = false;
      this.worldSeed = 1;
      this.currentFps = 0;
      this.vectorField = new VectorField();
      this.gameModels.push(this.vectorField);
      this.totals = new Totals(this.gameTime);
      this.gameModels.push(this.totals);
      this.damage = new Damage();
      this.gameModels.push(this.damage);
      this.effectManager = new EffectManager(this.projection);
      this.gameModels.push(this.effectManager);
      this.lightSourceCreators = new LightSourceCreators();
      this.gameModels.push(this.lightSourceCreators);
      this.effectCreators = new EffectCreators(this.lightSourceCreators, this.sprites.spellFxSpritesheet);
      this.gameModels.push(this.effectCreators);
      this.lightingCalculator = new LightingCalculator(this.worldGrid, this.projection);
      this.gameModels.push(this.lightingCalculator);
      this.physicsManager = new PhysicsManager(this.worldGrid, this.projection, this.gameTime);
      this.soundEffectManager = new SoundEffectManager();
      this.infoTextProcessor = new InfoTextProcessor(this.projection);
      this.gameModels.push(this.infoTextProcessor);
      this.partyTarget = new PartyTarget(this.totals, this.damage);
      this.gameModels.push(this.partyTarget);
      this.mineDamageLogic = new MineDamageLogic(this.values, this.totals, this.damage, this.globalStatistics);
      this.offlineLogic = new OfflineLogic(this.totals, this.values);
      this.minedUpgradeCollection = new MinedUpgradeCollection();
      this.gameModels.push(this.minedUpgradeCollection);
      this.pickUpgradeCollection = new PickUpgradeCollection(this.totals, this.values, this.mineDamageLogic);
      this.gameModels.push(this.pickUpgradeCollection);
      this.goldUpgradeCollection = new GoldUpgradeCollection(this.totals, this.values, this.mineDamageLogic, this.damage);
      this.gameModels.push(this.goldUpgradeCollection);
      this.bonusCollection = new BonusCollection(this.gameTime, this.totals, this.values);
      this.gameModels.push(this.bonusCollection);
      this.vectorFieldGenerator = new VectorFieldGenerator(this.worldGrid, this.projection, this.vectorField, this.partyTarget, this.crew);
      this.gameModels.push(this.vectorFieldGenerator);
      this.oreCalculationLogic = new OreCalculationLogic(this.values);
      this.upgradeCreators = new UpgradeCreators(this.values, this.totals, this.oreCalculationLogic, this.mineDamageLogic, this.minedUpgradeCollection, this.statisticsIncrementor);
      this.tileMinedLogic = new TileMinedLogic(
        this.crew,
        this.totals,
        this.damage,
        this.values,
        this.statisticsIncrementor,
        this.minedUpgradeCollection,
        this.upgradeCreators,
        this.infoTextProcessor,
        this.effectCreators,
        this.effectManager,
        this.oreCalculationLogic,
        this.mineDamageLogic
      );
      this.skillTreeGraph = new SkillTreeGraph(
        this.gameTime,
        this.worldGrid,
        this.totals,
        this.values,
        this.tileMinedLogic,
        this.mineDamageLogic,
        this.crew,
        this.vectorField,
        this.sprites.spellFxSpritesheet
      );
      this.gameModels.push(this.skillTreeGraph);
      this.automationManager = new AutomationManager(
        this.minedUpgradeCollection,
        this.pickUpgradeCollection,
        gameStateControl,
        this.values,
        this.totals,
        this.gameTime
      );
      this.gameModels.push(this.automationManager);
      this.pathPlanFinder = new PathPlanFinder(this.vectorField, this.tileMinedLogic);
      this.gameModels.push(this.pathPlanFinder);
      this.crewBrain = new CrewBrain(
        this.crew,
        this.vectorField,
        this.partyTarget,
        this.pathPlanFinder,
        this.tileMinedLogic,
        this.mineDamageLogic,
        this.statisticsIncrementor
      );
      this.mineControl = new MineControl(this.crew, this.partyTarget, this.damage, this.worldGrid, this.vectorFieldGenerator, this.vectorField);
      this.gameModels.push(this.mineControl);
      this.characterBrains = new CharacterBrains(this.pathPlanFinder);
      this.characterCreator = new CharacterCreator(this.sprites.monsterSpritesheet, this.characterBrains);
      this.gameModels.push(this.characterCreator);
      this.gridSave = new GridSave(this.characterCreator);
      this.gridSaveManager = new GridSaveManager(this.gridSave);
      this.gameModels.push(this.gridSaveManager);
      this.saveManager = new SaveManager(this.gridSaveManager);
      this.panAnimation = new PanAnimation(this.projection, this.crew);
      this.gameModels.push(this.panAnimation);
    }
    /**
     * Called after the save file have been loaded.
     * @param {boolean} saveLoaded True if the save file has been loaded, false if this is a new game with no save data.
     */
    initializeState(saveLoaded) {
      const terrainGenerator = new LayeredTerrainGenerator(this.worldSeed, this.characterCreator);
      const gridLoader = new GridLoader(this.gridSaveManager, terrainGenerator, this.worldGrid, this.crew, this.vectorField);
      this.gridLoadingManager.initializeLoadingManager(gridLoader, this.crew);
      if (!this.crew.main) {
        const mainMiner = this.crew.createMainMiner();
        let tile = null;
        if (saveLoaded) {
          tile = this.worldGrid.findGridTile(mainMiner.position.worldCoordinateOrigin);
        } else {
          tile = this.worldGrid.findGridTileXY(Settings.start.startX, Settings.start.startY);
        }
        if (tile) {
          mainMiner.position.setTileAndOriginPosition(tile, tile.origin.x, tile.origin.y);
        } else {
          if (!saveLoaded) {
            mainMiner.position.setWorldCoordinateOriginXY(Settings.start.startX, Settings.start.startY);
          }
        }
      } else {
        const tile = this.worldGrid.findGridTile(this.crew.main.position.worldCoordinateOrigin);
        if (tile) {
          this.crew.main.position.setTileAndOriginPosition(tile, tile.origin.x, tile.origin.y);
        }
      }
      if (saveLoaded) {
        const currentTime = Date.now();
        const saveTime = this.gameTime.saveTime;
        const offlineMillis = currentTime - saveTime;
        const offlineSeconds = offlineMillis / 1e3 | 0;
        if (offlineSeconds > 0) {
          this.totals.offlineSeconds += offlineSeconds;
          this.offlineLogic.calculateOfflineEarnings();
        }
      }
      this.mineDamageLogic.calculateTotalMineDamagePerTurn();
    }
    beforeImportSave() {
      for (let i = 0; i < this.gameModels.length; i++) {
        this.gameModels[i].resetFull();
      }
    }
    afterImportSave() {
      this.initializeState(true);
      this.projection.setGridCenter(Settings.start.startX, Settings.start.startY);
      this.gridLoadingManager.manageLoadedGridsForFrame();
    }
    /**
     * @override
     */
    resetForPrestige() {
      for (let i = 0; i < this.gameModels.length; i++) {
        this.gameModels[i].resetForPrestige();
      }
      this.worldSeed++;
      this.initializeState(false);
      this.projection.setGridCenter(Settings.start.startX, Settings.start.startY);
      this.gridLoadingManager.manageLoadedGridsForFrame();
    }
    /**
     * @override
     */
    resetFull() {
      for (let i = 0; i < this.gameModels.length; i++) {
        this.gameModels[i].resetFull();
      }
      this.worldSeed++;
      this.initializeState(false);
      this.projection.setGridCenter(Settings.start.startX, Settings.start.startY);
      this.gridLoadingManager.manageLoadedGridsForFrame();
    }
  };

  // src/view/framework/Page.js
  var Page = class _Page {
    constructor() {
    }
    /**
     * @param {string} elementId
     * @returns {HTMLElement}
     */
    static getElement(elementId) {
      return document.getElementById(elementId);
    }
    /**
     * @param {string} text
     * @returns {Text}
     */
    static createTextElement(text) {
      return document.createTextNode(text);
    }
    /**
     * @param {string} elementId
     * @param {string} text
     */
    static setInnerHtml(elementId, text) {
      var element = _Page.getElement(elementId);
      if (element) {
        element.innerHTML = text;
      }
    }
    /**
     * @param {string} tagName
     * @param {HTMLElement} parent
     * @param {string} id
     * @param {string} className
     * @returns {HTMLElement}
     */
    static createElement(tagName, parent, id, className) {
      var element = document.createElement(tagName);
      if (className) {
        element.className = className;
      }
      if (id) {
        element.id = id;
      }
      if (parent) {
        parent.appendChild(element);
      }
      return element;
    }
    /**
     * @param {string} inputType
     * @param {HTMLElement} parent
     * @param {string} id
     * @param {string} className
     * @returns {HTMLInputElement}
     */
    static createInputElement(inputType, parent, id, className) {
      var element = document.createElement("input");
      element.type = inputType;
      if (className) {
        element.className = className;
      }
      if (id) {
        element.id = id;
      }
      if (parent) {
        parent.appendChild(element);
      }
      return element;
    }
    /**
     * @param {string} elementId
     */
    static clearChildren(elementId) {
      var element = _Page.getElement(elementId);
      if (element) {
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
    }
    /**
     * @param {string} parentId
     * @param {string} elementId
     */
    static removeElementById(parentId, elementId) {
      this.removeElement(parentId, _Page.getElement(elementId));
    }
    /**
     * @param {string} parentId
     * @param {HTMLElement} element
     */
    static removeElement(parentId, element) {
      var parent = _Page.getElement(parentId);
      if (!parent || !element) {
        return;
      }
      try {
        parent.removeChild(element);
      } catch (e) {
        if (e instanceof DOMException) {
          console.error("Caught a DOMException. parentId=" + parentId + " elementId=" + element.id, e.name, e.message);
          if (e.name === "SyntaxError") {
            console.warn("Invalid CSS selector used.");
          }
        } else {
          console.error("Caught a non-DOMException error.  parentId=" + parentId + " elementId=" + element.id, e);
        }
      }
    }
    /**
     * @param {HTMLElement} element
     */
    static hideElement(element) {
      if (element) {
        element.style.display = "none";
      }
    }
    /**
     * @param {HTMLElement} element
     */
    static showElement(element) {
      this.showElementWithValue(element, "block");
    }
    /**
     * @param {string} elementId 
     * @param {string} visibleDisplayValue 
     */
    static showElementIdWithValue(elementId, visibleDisplayValue) {
      _Page.showElementWithValue(_Page.getElement(elementId), visibleDisplayValue);
    }
    /**
     * @param {HTMLElement} element
     * @param {string} visibleDisplayValue
     */
    static showElementWithValue(element, visibleDisplayValue) {
      if (element) {
        element.style.display = visibleDisplayValue;
      }
    }
    /**
     * @param {string} elementId
     */
    static hideElementId(elementId) {
      _Page.hideElement(_Page.getElement(elementId));
    }
    /**
     * @param {string} elementId
     */
    static showElementId(elementId) {
      _Page.showElement(_Page.getElement(elementId));
    }
  };

  // src/view/framework/View.js
  var View = class {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     */
    constructor(parentId, elementId) {
      this.parentId = parentId;
      this.elementId = elementId;
      this.viewVisible = true;
      this.currentlyVisible = false;
      this.inialized = false;
    }
    /**
     * @returns {string}
     */
    getElementId() {
      return this.elementId;
    }
    /**
     * @param {boolean} currentlyVisible
     */
    setCurrentlyVisible(currentlyVisible) {
      this.currentlyVisible = currentlyVisible;
    }
    /**
     * Returns true if the element should or should not be visible on the page.
     * @returns {boolean}
     */
    isViewVisible() {
      return this.viewVisible;
    }
    /**
     * Set to true if the element should be visible on the page.
     * @param {boolean} visible
     */
    setViewVisible(visible) {
      this.viewVisible = visible;
    }
    /**
     * Set the initial visibility of the element.
     * @param {boolean} visible
     */
    setInitialVisibility(visible) {
      this.currentlyVisible = !visible;
      this.viewVisible = visible;
    }
    /**
     * @abstract
     */
    clearChildViews() {
    }
    /**
     * Updates the user interface to reflect the data in the model.
     */
    updateView() {
      if (!this.inialized) {
        console.log("View.updateView() Not initialized: " + this.constructor.name);
      }
      if (this.elementId) {
        var viewVisible = this.isViewVisible();
        if (this.currentlyVisible !== viewVisible) {
          this.currentlyVisible = viewVisible;
          if (viewVisible) {
            Page.showElementIdWithValue(this.elementId, this.getVisibileDisplayValue());
          } else {
            Page.hideElementId(this.elementId);
          }
        }
        if (viewVisible) {
          this.updateViewContents();
        }
      }
    }
    /**
     * Returns the value that the display property should be set to in order to make
     * the element visible. 
     * 
     * By default this is 'block', but you should overwrite this if the element is 'display:flex', or 'display:inline-block' 
     * or something other than 'display:block'.
     * 
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "block";
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @abstract
     */
    initializeView() {
      this.inialized = true;
    }
    /**
     * Invoked by the base view if the element is visible on the page.
     * @abstract
     */
    updateViewContents() {
    }
    /**
     */
    removeAll() {
      if (this.parentId) {
        Page.removeElementById(this.parentId, this.elementId);
      }
    }
  };

  // src/view/framework/ParentView.js
  var ParentView = class extends View {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     */
    constructor(parentId, elementId) {
      super(parentId, elementId);
      this.childViews = null;
    }
    /**
     * @returns {View[]}
     */
    getChildViews() {
      return this.childViews;
    }
    /**
     * Clears out all child views.
     */
    clearChildViews() {
      if (this.childViews && this.childViews.length > 0) {
        for (let i = 0; i < this.childViews.length; i++) {
          this.childViews[i].clearChildViews();
        }
        this.childViews.length = 0;
      }
    }
    /**
     * @override
     */
    removeAll() {
      if (this.childViews) {
        for (let i = 0; i < this.childViews.length; i++) {
          this.childViews[i].removeAll();
        }
      }
      this.childViews = null;
      super.removeAll();
    }
    /**
     * Clears out all child view elements and also clears the child view array.
     */
    removeChildViewElements() {
      if (!this.childViews || this.childViews.length === 0) {
        return;
      }
      const id = this.getElementId();
      for (let i = 0; i < this.childViews.length; i++) {
        Page.removeElementById(id, this.childViews[i].getElementId());
      }
      this.clearChildViews();
    }
    /**
     * @param {number} index
     */
    removeViewAtIndex(index) {
      if (!this.childViews || this.childViews.length === 0) {
        return;
      }
      const child = this.childViews[index];
      const id = this.getElementId();
      Page.removeElementById(id, child.getElementId());
      this.childViews.splice(index, 1);
    }
    /**
     * @param {string} elementId 
     */
    removeView(elementId) {
      if (!this.childViews || this.childViews.length === 0) {
        return;
      }
      const id = this.getElementId();
      let childIndex = -1;
      for (let i = 0; i < this.childViews.length; i++) {
        const child2 = this.childViews[i];
        if (child2.getElementId() === elementId) {
          childIndex = i;
          break;
        }
      }
      if (childIndex === -1) {
        console.log("ParentView.removeView() Failed to find child id: " + elementId);
        return;
      }
      const child = this.childViews[childIndex];
      Page.removeElementById(id, child.getElementId());
      this.childViews.splice(childIndex, 1);
    }
    /**
     * Adds a view to the parent.
     * @param {View} view
     */
    addView(view) {
      if (view) {
        if (!this.childViews) {
          this.childViews = [];
        }
        this.childViews.push(view);
      }
    }
    /**
     * @inheritDoc
     */
    initializeView() {
      if (this.childViews) {
        for (let i = 0; i < this.childViews.length; i++) {
          this.childViews[i].initializeView();
        }
      }
      super.initializeView();
    }
    /**
     * @inheritDoc
     */
    updateViewContents() {
      this.updateChildViews();
    }
    /**
     * @private
     */
    updateChildViews() {
      if (this.childViews) {
        for (let i = 0; i < this.childViews.length; i++) {
          this.childViews[i].updateView();
        }
      }
    }
  };

  // src/view/PageIds.js
  var PageIds = {
    GAME_VIEW_CONTAINER: "gameViewContainer",
    GAME_VIEW_OVERLAY_CONTAINER: "gameViewOverlayContainer",
    GAME_SKILL_TOGGLE_CONTAINER: "gameSkillToggleContainer",
    GAME_CANVAS: "gameCanvas",
    SKILL_TREE_GRAPH: "skillTreeGraph",
    CENTER_ON_CHARACTER_BUTTON: "centerOnCharacterButton",
    AUTO_PLAY_BUTTON: "autoPlayButton",
    ACTIVE_SKILLS_PANEL: "activeSkillsPanel",
    ACTIVE_BONUSES_PANEL: "activeBonusesPanel",
    /**
     * The main upgrade panel on the right of the screen.
     * Contains the tab menu and the upgrade container.
     */
    PRIMARY_UPGRADE_PANEL: "primaryUpgradePanel",
    /**
     * The div with the upgrade tabs.
     */
    PRIMARY_UPGRADE_PANEL_TAB_BAR: "primaryUpgradePanelTabBar",
    UPGRADE_TAB_MENU_ITEM_CREW: "crewUpgradesMenuItem",
    SKILL_TREE_TAB_MENU_ITEM: "skillTreeMenuItem",
    /**
     * Free Upgrades Panel
     */
    FREE_UPGRADES_PANEL: "freeUpgradesPanel",
    /**
     * Mined Upgrades Panel
     */
    MINED_UPGRADES_PANEL: "minedUpgradesPanel",
    /**
     * Pick Upgrades Panel
     */
    PICK_UPGRADES_PANEL: "pickUpgradesPanel",
    /**
     * Gold Upgrades Panel
     */
    GOLD_UPGRADES_PANEL: "goldUpgradesPanel",
    /**
     * Bonus Panel
     */
    BONUS_PANEL: "bonusPanel",
    /**
     * Point Upgrades Panel
     */
    POINT_UPGRADES_PANEL: "pointUpgradesPanel",
    /**
     * Crew Upgrades Panel
     */
    CREW_UPGRADES_PANEL: "crewUpgradesPanel",
    /**
     * Crew Upgrades Panel
     */
    SKILL_SELECTION_PANEL: "skillSelectionPanel",
    /**
     * Skill Tree Panel
     */
    SKILL_TREE_PANEL: "skillTreePanel",
    /**
     * Menu Panel
     */
    MENU_PANEL: "menuPanel",
    /**
     * Crew Tab Upgrade Collection
     */
    CREW_TAB_UPGRADE_COLLECTION: "upgradeCollection",
    /**
     * Crew Tab Contents
     */
    CREW_PICK_UPGRADE_CONTENTS: "pickUpgradeBody",
    /**
     * The mine damage breakdown.
     */
    MINE_DAMAGE_VIEW: "mineDamageDisplay",
    /**
     * The max row depth.
     */
    MAX_DEPTH_VIEW: "maxDepth",
    /**
     * The max unlocked layer.
     */
    MAX_LAYER_VIEW: "maxLayer",
    /**
     * The max unlocked layer.
     */
    CURRENT_LAYER_VIEW: "currentLayer",
    /**
     * The crew 'mode' (what its doing right now)
     */
    CREW_MODE_VIEW: "crewMode",
    /**
     * The current ore value.
     */
    CURRENCY_VIEW: "currencyView",
    PRESTIGE_POPUP: "prestigePopup",
    OFFLINE_POPUP: "offlinePopup",
    STATISTICS_POPUP: "statisticsPopup",
    SAVE_POPUP: "savePopup",
    CLOSE_SKILL_TREE_POPUP: "closeSkillTree",
    PERFORMANCE_POPUP: "performancePopup",
    GAME_OPTIONS_POPUP: "gameOptionsPopup"
  };

  // src/input/UserInput.js
  var UserInput = class {
    constructor() {
      this.firstMovement = true;
      this.leftMouseDown = false;
      this.prevMouseX = 0;
      this.prevMouseY = 0;
      this.mouseX = 0;
      this.mouseY = 0;
      this.mouseDeltaX = 0;
      this.mouseDeltaY = 0;
      this.mouseDownTime = 0;
      this.mouseDownX = 0;
      this.mouseDownY = 0;
      this.leftMouseClick = false;
      this.clickX = 0;
      this.clickY = 0;
      this.mouseWheelMotion = 0;
      this.mouseMoved = false;
    }
    /**
     * @param {Document} document The page document. We listen to the document for keyboard events.
     * @param {HTMLElement} element The page element. We listen to the element for mouse events.
     */
    attachListeners(document2, element) {
      const thisRef = this;
      element.onmouseover = function(event) {
        element.focus();
        thisRef.mouseX = event.clientX;
        thisRef.mouseY = event.clientY;
        return false;
      };
      element.onmouseout = function(event) {
        thisRef.leftMouseDown = false;
        thisRef.mouseX = event.clientX;
        thisRef.mouseY = event.clientY;
        thisRef.firstMovement = true;
      };
      if (document2) {
        document2.onmouseout = function(event) {
          thisRef.leftMouseDown = false;
          thisRef.mouseX = event.clientX;
          thisRef.mouseY = event.clientY;
          thisRef.firstMovement = true;
        };
      }
      element.addEventListener("mousewheel", function(event) {
        thisRef.mouseWheelMotion = -(event.wheelDelta || event.detail);
        return false;
      }, false);
      element.addEventListener("DOMMouseScroll", function(event) {
        thisRef.mouseWheelMotion = event.wheelDelta || event.detail;
        return false;
      }, false);
      element.onmousedown = function(event) {
        thisRef.mouseX = event.clientX;
        thisRef.mouseY = event.clientY;
        thisRef.prevMouseX = event.clientX;
        thisRef.prevMouseY = event.clientY;
        thisRef.mouseMoved = false;
        thisRef.mouseDeltaX = 0;
        thisRef.mouseDeltaY = 0;
        thisRef.mouseDownX = event.clientX;
        thisRef.mouseDownY = event.clientY;
        thisRef.mouseDownTime = Date.now();
        if (event.button === 0 || event.button === 1) {
          thisRef.leftMouseDown = true;
        }
        return false;
      };
      element.onmouseup = function(event) {
        thisRef.mouseX = event.clientX;
        thisRef.mouseY = event.clientY;
        thisRef.mouseDeltaX = thisRef.mouseX - thisRef.prevMouseX;
        thisRef.mouseDeltaY = thisRef.mouseY - thisRef.prevMouseY;
        thisRef.prevMouseX = thisRef.mouseX;
        thisRef.prevMouseY = thisRef.mouseY;
        if (event.button === 0 || event.button === 1) {
          thisRef.leftMouseDown = false;
          const deltaX = thisRef.mouseX - thisRef.mouseDownX;
          const deltaY = thisRef.mouseY - thisRef.mouseDownY;
          if (Math.abs(deltaX) < 5 && Math.abs(deltaY) < 5 && Date.now() - thisRef.mouseDownTime < 250) {
            thisRef.leftMouseClick = true;
            thisRef.clickX = event.clientX;
            thisRef.clickY = event.clientY;
          }
        }
        return false;
      };
      element.onmousemove = function(event) {
        thisRef.onMouseMove(event.clientX, event.clientY);
        return false;
      };
    }
    /**
     * 
     * @param {number} mouseX
     * @param {number} mouseY 
     */
    onMouseMove(mouseX, mouseY) {
      this.mouseX = mouseX;
      this.mouseY = mouseY;
      this.mouseMoved = true;
      if (this.firstMovement) {
        this.firstMovement = false;
      } else {
        this.mouseDeltaX += this.mouseX - this.prevMouseX;
        this.mouseDeltaY += this.mouseY - this.prevMouseY;
      }
      this.prevMouseX = this.mouseX;
      this.prevMouseY = this.mouseY;
    }
    // /**
    //  * @param {Array.<String>} keyCodeArray 
    //  * @returns {boolean}
    //  */
    // isKeyPressed(keyCodeArray) {
    //     for (var i = 0; i < keyCodeArray.length; i++) {
    //         if (this.keysPressed[keyCodeArray[i]]) {
    //             return true;
    //         }
    //     }
    //     return false;
    // }
    /**
     * Resets the per-frame input state. Things that have to be for each frame.
     */
    resetInputState() {
      this.leftMouseClick = false;
      this.mouseWheelMotion = 0;
      this.mouseDeltaX = 0;
      this.mouseDeltaY = 0;
      this.mouseMoved = false;
    }
  };

  // src/view/canvas/CanvasView.js
  var CanvasView = class extends View {
    /**
     * @param {string} parentId
     * @param {State} state
     * @param {UserInput} userInput
     */
    constructor(parentId, state, userInput) {
      super(parentId, PageIds.GAME_CANVAS);
      this.canvas = null;
      this.context = null;
      this.userInput = userInput;
      this.projection = state.projection;
      this.sprites = state.sprites;
      this.tileDamageSpriteOverlay = this.sprites.tileDamageSpriteOverlay;
      this.oreSpriteOverlay = this.sprites.oreSpriteOverlay;
      this.upgradeSpriteOverlay = this.sprites.tileSpriteOverlaySpritesheet.upgradeSpriteOverlay;
      this.crew = state.crew;
      this.partyTarget = state.partyTarget;
      this.state = state;
      this.worldGrid = state.worldGrid;
      this.vectorField = state.vectorField;
      this.infoTextProcessor = state.infoTextProcessor;
      this.spriteSize = 0;
      this.scaledSize = 0;
      this.screenCoordinate = new Vector(0, 0);
      this.screenCoordinate2 = new Vector(0, 0);
      this.worldCoordinate = new Vector(0, 0);
      this.tileHealthNum = new BigNum(0);
      this.crewBrain = state.crewBrain;
      const thisRef = this;
      this.renderRegionBorderDebugCallback = (region) => {
        if (region.vectorFieldNumber != this.vectorField.vectorFieldNumber) {
          return;
        }
        thisRef.renderRegionBorder(region);
      };
      this.renderTilesCallback = (tile) => {
        thisRef.renderTile(tile);
      };
      this.renderWireframeTilesCallback = (tile) => {
        thisRef.renderTileWireframe(tile);
      };
      this.renderMonstersCallback = (grid) => {
        thisRef.renderMonsterCharacters(grid);
      };
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      this.canvas = Page.createElement("canvas", parent, PageIds.GAME_CANVAS, "game-canvas");
      this.context = this.canvas.getContext("2d");
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      this.userInput.attachListeners(document, this.canvas);
      this.projection.setCanvas(this.canvas);
      this.setInitialVisibility(true);
      super.initializeView();
    }
    /**
     * @returns {HTMLCanvasElement}
     */
    getCanvas() {
      return this.canvas;
    }
    /**
     * @override
     */
    updateViewContents() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.context.font = "12pt helvetica";
      this.context.imageSmoothingEnabled = false;
      PerformanceMetrics.startTime("Render-total");
      this.renderWorld();
      PerformanceMetrics.endTime("Render-total");
    }
    /**
     * @private
     */
    renderWorld() {
      this.spriteSize = this.sprites.tileSpritesheet.spriteSize;
      this.scaledSize = this.spriteSize * this.projection.zoom;
      const thisRef = this;
      PerformanceMetrics.startTime("Render-blocks");
      if (this.state.gameOptions.wireframeModeEnabled) {
        GridInversionOfControl.allVisibleTiles(this.worldGrid, this.projection, this.renderWireframeTilesCallback);
      } else {
        GridInversionOfControl.allVisibleTiles(this.worldGrid, this.projection, this.renderTilesCallback);
      }
      PerformanceMetrics.endTime("Render-blocks");
      this.renderInfoText();
      GridInversionOfControl.allVisibleGrids(this.worldGrid, this.projection, this.renderMonstersCallback);
      if (this.state.gameOptions.crewBrainDebugEnabled) {
        this.renderRegionBordersDebug();
        this.renderVectorFieldTargets();
      }
      if (this.state.gameOptions.depthColumnRendered) {
        this.renderTileDepths();
      }
      if (this.state.gameOptions.effectsRenderingEnabled) {
        PerformanceMetrics.startTime("Render-effects");
        this.renderEffects();
        this.renderSkills();
        PerformanceMetrics.endTime("Render-effects");
      }
      PerformanceMetrics.startTime("Render-crew");
      this.renderCrew();
      PerformanceMetrics.endTime("Render-crew");
      if (this.state.gameOptions.crewBrainDebugEnabled) {
        this.renderPaths();
      }
      if (this.state.gameOptions.displayFps) {
        this.context.fillStyle = "#FFFA";
        this.context.fillText("FPS: " + this.state.currentFps, 270, this.canvas.height - 100);
      }
    }
    renderPaths() {
      const miners = this.crew.miners;
      for (let i = 0; i < miners.length; i++) {
        this.renderPath(miners[i]);
      }
    }
    renderPath(miner) {
      if (!miner.position.tile) {
        return;
      }
      if (miner.position.pathPlan.length < 2) {
        return;
      }
      this.context.strokeStyle = miner.target.invalidated ? "#F114" : "#F834";
      this.context.lineWidth = 4;
      this.context.beginPath();
      for (let i = 0; i < miner.position.pathPlan.length; i++) {
        const planStep = miner.position.pathPlan[i];
        this.screenCoordinate.copy(planStep.startTile.origin);
        this.screenCoordinate.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
        this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        this.context.moveTo(this.screenCoordinate.x, this.screenCoordinate.y);
        this.screenCoordinate.copy(planStep.endTile.origin);
        this.screenCoordinate.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
        this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        this.context.lineTo(this.screenCoordinate.x, this.screenCoordinate.y);
      }
      this.context.stroke();
    }
    /**
     * @private
     */
    renderCrew() {
      const miners = this.crew.miners;
      this.spriteSize = this.sprites.itemOverlaySpritesheet.spriteSize;
      this.scaledSize = this.spriteSize * this.projection.zoom;
      for (let i = 0; i < miners.length; i++) {
        this.renderThruster(miners[i]);
      }
      this.spriteSize = this.sprites.tileSpritesheet.spriteSize;
      this.scaledSize = this.spriteSize * this.projection.zoom;
      for (let i = 0; i < miners.length; i++) {
        this.renderCharacter(miners[i]);
      }
      this.spriteSize = this.sprites.itemOverlaySpritesheet.spriteSize;
      this.scaledSize = this.spriteSize * this.projection.zoom;
      for (let i = 0; i < miners.length; i++) {
        this.renderItemOverlay(miners[i]);
      }
    }
    // /**
    //  * @private
    //  * @param {GridTile} tile 
    //  */
    // renderTileNeighborScores(tile) {
    //     const neighbors = tile.neighbors;
    //     this.screenCoordinate.copy(tile.origin);
    //     this.screenCoordinate.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
    //     ////////this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
    //     for (let i = 0; i < neighbors.length; i++) {
    //         const neighbor = neighbors[i];
    //         if (!neighbor) {
    //             continue;
    //         }
    //         // If the neighbor is known, then it provides no bonus to this tile.
    //         if (neighbor.lighting.everVisibleToCharacter || neighbor.tileType === SpecialTileTypes.SKY) {
    //             continue;
    //         }
    //         this.screenCoordinate2.copy(neighbor.origin);
    //         this.screenCoordinate2.subtract(tile.origin);
    //         this.screenCoordinate2.scale(0.5);
    //         this.screenCoordinate2.add(this.screenCoordinate);
    //         ///////this.screenCoordinate2.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
    //         this.projection.worldToScreen(this.screenCoordinate2, this.screenCoordinate2);
    //         // Unseen neighbor tiles that are open are caverns.
    //         if (neighbor.open) {
    //             //this.context.fillStyle = "white";
    //             this.context.fillRect(this.screenCoordinate2.x - 3, this.screenCoordinate2.y - 3, 6, 6);
    //         }
    //         else {
    //             //this.context.fillStyle = "yellow";
    //             this.context.fillRect(this.screenCoordinate2.x - 2, this.screenCoordinate2.y - 2, 4, 4);
    //         }
    //     }
    // }
    renderInfoText() {
      const infoTextArray = this.infoTextProcessor.infoTextArray;
      if (infoTextArray.length === 0) {
        return;
      }
      this.context.fillStyle = "white";
      for (let i = 0; i < infoTextArray.length; i++) {
        const infoText = infoTextArray[i];
        this.context.fillText(infoText.text, infoText.textX, infoText.textY);
      }
    }
    renderRegionBordersDebug() {
      if (!this.state.vectorField.centerTile) {
        return;
      }
      const startTileOrigin = this.state.vectorField.centerTile.origin;
      const mineTileRadius = 25 * Settings.tile.size;
      GridInversionOfControl.allNearbyRegions(this.worldGrid, this.projection, startTileOrigin, mineTileRadius, this.renderRegionBorderDebugCallback);
    }
    /**
     * @param {GridRegion} region 
     */
    renderRegionBorder(region) {
      this.screenCoordinate.copy(region.origin);
      this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
      this.screenCoordinate2.copy(region.origin);
      this.screenCoordinate2.addXY(Settings.grid.regionPixelWidth, Settings.grid.regionPixelHeight);
      this.projection.worldToScreen(this.screenCoordinate2, this.screenCoordinate2);
      const widthA = Math.abs(this.screenCoordinate2.x - this.screenCoordinate.x);
      const heightA = Math.abs(this.screenCoordinate2.y - this.screenCoordinate.y);
      this.context.strokeStyle = "#22222288";
      this.context.lineWidth = 2;
      this.context.strokeRect(this.screenCoordinate.x, this.screenCoordinate.y, widthA, heightA);
    }
    renderVectorFieldTargets() {
      this.context.fillStyle = "#FF0000";
      this.renderTargetList(this.vectorField.priorityMiningCandidates);
      this.context.fillStyle = "#FFFF00";
      this.renderTargetList(this.vectorField.currencyMiningCandidates);
      this.context.fillStyle = "#FF00FF";
      this.renderTargetList(this.vectorField.commonMiningCandidates);
      for (let i = 0; i < this.crew.miners.length; i++) {
        const miner = this.crew.miners[i];
        const targetTile = miner.target.targetTile;
        const mineTile = miner.target.mineTile;
        this.renderMineTarget(miner.position.tile, targetTile, mineTile);
      }
      const vectorFieldCenterTile = this.vectorField.centerTile;
      if (vectorFieldCenterTile) {
        this.screenCoordinate.copy(vectorFieldCenterTile.origin);
        this.screenCoordinate.addXY(4, 4);
        this.screenCoordinate2.copy(vectorFieldCenterTile.origin);
        this.screenCoordinate2.addXY(Settings.tile.size - 4, Settings.tile.size - 4);
        this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        this.projection.worldToScreen(this.screenCoordinate2, this.screenCoordinate2);
        this.context.fillStyle = "#FFFFFF";
        this.context.fillRect(this.screenCoordinate.x, this.screenCoordinate.y, this.screenCoordinate2.x - this.screenCoordinate.x, this.screenCoordinate2.y - this.screenCoordinate.y);
      }
      const crewCenterTile = this.crew.centerTile;
      if (crewCenterTile) {
        this.screenCoordinate.copy(crewCenterTile.origin);
        this.screenCoordinate.addXY(4, 4);
        this.screenCoordinate2.copy(crewCenterTile.origin);
        this.screenCoordinate2.addXY(Settings.tile.size - 4, Settings.tile.size - 4);
        this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        this.projection.worldToScreen(this.screenCoordinate2, this.screenCoordinate2);
        this.context.fillStyle = "#00FFFF";
        this.context.fillRect(this.screenCoordinate.x, this.screenCoordinate.y, this.screenCoordinate2.x - this.screenCoordinate.x, this.screenCoordinate2.y - this.screenCoordinate.y);
      }
      const destinationTiles = this.vectorField.destinationTileCandidates;
      if (destinationTiles.length > 0) {
        this.context.strokeStyle = "#FF02";
        this.context.lineWidth = 2;
        for (let i = 0; i < destinationTiles.length; i++) {
          const dt = destinationTiles[i];
          if (!dt) {
            break;
          }
          this.screenCoordinate.copy(dt.origin);
          this.screenCoordinate.addXY(4, 4);
          this.screenCoordinate2.copy(dt.origin);
          this.screenCoordinate2.addXY(Settings.tile.size - 4, Settings.tile.size - 4);
          this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
          this.projection.worldToScreen(this.screenCoordinate2, this.screenCoordinate2);
          this.context.strokeRect(this.screenCoordinate.x, this.screenCoordinate.y, this.screenCoordinate2.x - this.screenCoordinate.x, this.screenCoordinate2.y - this.screenCoordinate.y);
        }
      }
      this.context.fillStyle = "#888";
      this.context.fillText("瓷砖生命值: " + (this.state.mineControl.debugTileHealthNegligible ? "negligible" : "normal"), 250, this.canvas.height - 280);
      this.context.fillText("搜索网格: " + (this.state.mineControl.debugSearchGridSmall ? "small" : "normal"), 250, this.canvas.height - 260);
      this.context.fillText("高级瓷砖: " + (this.state.mineControl.debugIgnorePremium ? "ignored" : "targeted"), 250, this.canvas.height - 240);
      this.context.fillText("普通瓷砖: " + (this.state.mineControl.debugIgnoreCommon ? "ignored" : "targeted"), 250, this.canvas.height - 220);
      this.context.fillText("目标介绍: " + this.state.mineControl.debugGoalDescription, 250, this.canvas.height - 200);
    }
    /**
     * @private
     * @param {GridTile} tile 
     * @param {GridTile} targetTile 
     * @param {GridTile} mineTile 
     */
    renderMineTarget(tile, targetTile, mineTile) {
      if (!tile) {
        return;
      }
      if (mineTile) {
        this.screenCoordinate.copy(mineTile.origin);
        this.screenCoordinate.addXY(Settings.tile.quarterSize + 2, Settings.tile.quarterSize + 2);
        this.screenCoordinate2.copy(mineTile.origin);
        this.screenCoordinate2.addXY(Settings.tile.threeQuarterSize - 2, Settings.tile.threeQuarterSize - 2);
        this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        this.projection.worldToScreen(this.screenCoordinate2, this.screenCoordinate2);
        this.context.fillStyle = "#4444FF";
        this.context.fillRect(this.screenCoordinate.x, this.screenCoordinate.y, this.screenCoordinate2.x - this.screenCoordinate.x, this.screenCoordinate2.y - this.screenCoordinate.y);
      }
      if (targetTile) {
        this.screenCoordinate.copy(targetTile.origin);
        this.screenCoordinate.addXY(Settings.tile.quarterSize + 2, Settings.tile.quarterSize + 2);
        this.screenCoordinate2.copy(targetTile.origin);
        this.screenCoordinate2.addXY(Settings.tile.threeQuarterSize - 2, Settings.tile.threeQuarterSize - 2);
        this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        this.projection.worldToScreen(this.screenCoordinate2, this.screenCoordinate2);
        this.context.fillStyle = "#FF4444";
        this.context.fillRect(this.screenCoordinate.x, this.screenCoordinate.y, this.screenCoordinate2.x - this.screenCoordinate.x, this.screenCoordinate2.y - this.screenCoordinate.y);
        this.renderLineDebug(tile, targetTile, "#AAF4");
      }
    }
    /**
     * @private
     * @param {GridTile} startTile 
     * @param {GridTile} endTile 
     * @param {string} color 
     */
    renderLineDebug(startTile, endTile, color) {
      this.context.strokeStyle = color;
      this.context.lineWidth = 4;
      this.context.beginPath();
      this.screenCoordinate.copy(startTile.origin);
      this.screenCoordinate.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
      this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
      this.context.moveTo(this.screenCoordinate.x, this.screenCoordinate.y);
      this.screenCoordinate.copy(endTile.origin);
      this.screenCoordinate.addXY(Settings.tile.halfSize, Settings.tile.halfSize);
      this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
      this.context.lineTo(this.screenCoordinate.x, this.screenCoordinate.y);
      this.context.stroke();
    }
    /**
     * @private
     * @param {GridTile[]} targets 
     */
    renderTargetList(targets) {
      for (let i = 0; i < targets.length; i++) {
        const tile = targets[i];
        this.screenCoordinate.copy(tile.origin);
        this.screenCoordinate.addXY(Settings.tile.quarterSize, Settings.tile.quarterSize);
        this.screenCoordinate2.copy(tile.origin);
        this.screenCoordinate2.addXY(Settings.tile.threeQuarterSize, Settings.tile.threeQuarterSize);
        this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        this.projection.worldToScreen(this.screenCoordinate2, this.screenCoordinate2);
        this.context.fillRect(this.screenCoordinate.x, this.screenCoordinate.y, this.screenCoordinate2.x - this.screenCoordinate.x, this.screenCoordinate2.y - this.screenCoordinate.y);
      }
    }
    renderGridBorders() {
      this.context.strokeStyle = "#11111122";
      this.context.lineWidth = 1;
      const scaledGridSize = this.spriteSize * this.projection.zoom * Settings.grid.gridTileWidth;
      const grids = this.worldGrid.grids;
      for (let i = 0; i < grids.length; i++) {
        const grid = grids[i];
        if (this.projection.isVisibleGridBox(grid)) {
          this.projection.worldToScreen(grid.origin, this.screenCoordinate);
          this.context.strokeRect(this.screenCoordinate.x, this.screenCoordinate.y, scaledGridSize, scaledGridSize);
        }
      }
    }
    renderTileDepths() {
      const panelWidth = 190;
      this.context.fillStyle = "#22222211";
      this.context.fillRect(0, 0, panelWidth, this.canvas.height);
      const centerRowTile = this.worldGrid.findGridTile(this.projection.gridCenter);
      if (!centerRowTile) {
        return;
      }
      this.context.fillStyle = "#666666FF";
      let workingTile = centerRowTile;
      this.renderTileDepth(workingTile);
      this.renderTileHealth(workingTile);
      workingTile = centerRowTile.getNeighborTop();
      while (workingTile && this.projection.isVisibleGridBox(workingTile)) {
        this.renderTileDepth(workingTile);
        this.renderTileHealth(workingTile);
        workingTile = workingTile.getNeighborTop();
      }
      workingTile = centerRowTile.getNeighborBottom();
      while (workingTile && this.projection.isVisibleGridBox(workingTile)) {
        this.renderTileDepth(workingTile);
        this.renderTileHealth(workingTile);
        workingTile = workingTile.getNeighborBottom();
      }
      this.context.fillStyle = "#111111EE";
      this.context.fillRect(0, this.canvas.height - 30, panelWidth, 30);
      this.context.fillStyle = "#666666FF";
      this.context.fillText("深度", 5, this.canvas.height - 10);
      this.context.fillText("生命值", 100, this.canvas.height - 10);
    }
    /**
     * @private
     * @param {GridTile} tile 
     */
    renderTileDepth(tile) {
      const panelWidth = 80;
      let displayRow = tile.getTileRow();
      if (displayRow === this.partyTarget.targetRow) {
        this.screenCoordinate.copy(tile.origin);
        this.screenCoordinate.y += Settings.tile.size;
        this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        this.context.fillStyle = "#FF8822FF";
        this.context.fillRect(0, this.screenCoordinate.y, panelWidth, 3);
        this.context.fillText("" + this.partyTarget.targetRow + " target", 5, this.screenCoordinate.y - 5);
      } else if (displayRow % 5 === 0) {
        this.screenCoordinate.copy(tile.origin);
        this.screenCoordinate.y += Settings.tile.size;
        this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
        this.context.fillStyle = "#666666FF";
        this.context.fillRect(0, this.screenCoordinate.y, panelWidth, 2);
        this.context.fillText("" + displayRow, 5, this.screenCoordinate.y - 5);
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     */
    renderTileHealth(tile) {
      const rowNumber = tile.getTileRow();
      if (rowNumber < 0) {
        return;
      }
      this.screenCoordinate.copy(tile.origin);
      this.screenCoordinate.y += Settings.tile.size;
      this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
      const layerDescription = tile.tileType.layerDescription;
      layerDescription.calculateTileHealth(rowNumber, this.tileHealthNum);
      this.context.fillStyle = "#666666FF";
      this.context.fillText(NumberFormatter.formatBigNum(this.tileHealthNum), 100, this.screenCoordinate.y - 5);
    }
    /**
     * @private
     * @param {Grid} grid 
     */
    renderMonsterCharacters(grid) {
      const characters = grid.characters;
      for (let i = 0; i < characters.length; i++) {
        if (characters[i].isMonster()) {
          this.renderCharacter(characters[i]);
        }
      }
    }
    /**
     * @private
     * @param {Character} character
     */
    renderCharacter(character) {
      if (!this.projection.isVisible(character.position.worldCoordinateOrigin, Settings.tile.size)) {
        return;
      }
      const tile = character.position.tile;
      if (!tile) {
        return;
      }
      const lighting = tile.lighting;
      if (!lighting.everVisibleToCharacter) {
        return;
      }
      if (tile.tileType.lightingSupported && lighting.shadowColor.a === 0) {
        return;
      }
      const sprite = character.getCharacterSprite();
      if (character.position.facingLeft) {
        this.projection.worldToScreen(character.position.worldCoordinateOrigin, this.screenCoordinate);
        this.renderSprite(sprite, this.screenCoordinate);
      } else {
        this.worldCoordinate.copy(character.position.worldCoordinateOrigin);
        this.worldCoordinate.addXY(this.spriteSize, 0);
        this.projection.worldToScreen(this.worldCoordinate, this.screenCoordinate);
        this.context.save();
        this.context.translate(this.screenCoordinate.x, this.screenCoordinate.y);
        this.context.scale(-1, 1);
        this.screenCoordinate.set(0, 0);
        this.renderSprite(sprite, this.screenCoordinate);
        this.context.restore();
      }
    }
    /**
     * @private
     * @param {Character} character
     */
    renderItemOverlay(character) {
      if (!this.projection.isVisible(character.position.worldCoordinateOrigin, Settings.tile.size)) {
        return;
      }
      this.renderOverlaySprite(character, character.getItemOverlaySprite());
    }
    /**
     * @private
     * @param {PartyCharacter} character
     */
    renderThruster(character) {
      if (!this.projection.isVisible(character.position.worldCoordinateOrigin, Settings.tile.size)) {
        return;
      }
      this.renderOverlaySprite(character, character.getThrusterOverlaySprite());
    }
    /**
     * @private
     * @param {Character} character
     * @param {Sprite} sprite 
     */
    renderOverlaySprite(character, sprite) {
      if (!sprite) {
        return;
      }
      if (character.position.facingLeft) {
        this.worldCoordinate.copy(character.position.worldCoordinateOrigin);
        this.worldCoordinate.subtractXY(Settings.tile.size, Settings.tile.size);
        this.projection.worldToScreen(this.worldCoordinate, this.screenCoordinate);
        this.renderSprite(sprite, this.screenCoordinate);
      } else {
        this.worldCoordinate.copy(character.position.worldCoordinateOrigin);
        this.worldCoordinate.subtractXY(Settings.tile.size, Settings.tile.size);
        this.worldCoordinate.addXY(this.spriteSize, 0);
        this.projection.worldToScreen(this.worldCoordinate, this.screenCoordinate);
        this.context.save();
        this.context.translate(this.screenCoordinate.x, this.screenCoordinate.y);
        this.context.scale(-1, 1);
        this.screenCoordinate.set(0, 0);
        this.renderSprite(sprite, this.screenCoordinate);
        this.context.restore();
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     */
    renderTile(tile) {
      if (!tile) {
        return;
      }
      if (!tile.tileType.lightingSupported) {
        this.projection.worldToScreen(tile.origin, this.screenCoordinate);
        if (tile.open) {
          this.renderSprite(tile.backgroundSprite, this.screenCoordinate);
        } else {
          this.renderSprite(tile.sprite, this.screenCoordinate);
        }
      } else {
        const lighting = tile.lighting;
        if (!lighting.everVisibleToCharacter) {
          return;
        }
        this.projection.worldToScreen(tile.origin, this.screenCoordinate);
        const shadowColor = lighting.calculateShadowColor();
        if (shadowColor.a > 0) {
          if (tile.open) {
            this.renderSprite(tile.backgroundSprite, this.screenCoordinate);
            if (tile.fixtureDescription) {
              if (!tile.fixtureDescription.sprite) {
                tile.fixtureDescription.sprite = this.sprites.staticFixtureSpritesheet.getSprite(tile.fixtureDescription.spriteName);
              }
              this.renderSprite(tile.fixtureDescription.sprite, this.screenCoordinate);
            }
          } else {
            this.renderSprite(tile.sprite, this.screenCoordinate);
          }
          if (!tile.open && tile.healthPercent != 100) {
            const damageSprite = this.tileDamageSpriteOverlay.getDamageSprite(tile);
            if (damageSprite) {
              this.context.globalAlpha = 0.7;
              this.renderSprite(damageSprite, this.screenCoordinate);
              this.context.globalAlpha = 1;
            }
          }
          if (!tile.open && tile.tileType.rarityModifier !== TileTypeRarity.COMMON) {
            if (tile.tileType.rarityModifier === TileTypeRarity.UPGRADE) {
              const upgradeSprite = this.upgradeSpriteOverlay.getCurrentSpriteDefault();
              if (upgradeSprite) {
                this.renderSprite(upgradeSprite, this.screenCoordinate);
              }
            } else {
              const oreSprite = this.oreSpriteOverlay.getOreSprite(tile);
              if (oreSprite) {
                this.renderSprite(oreSprite, this.screenCoordinate);
              }
            }
          }
          if (shadowColor.a < 1) {
            this.context.fillStyle = shadowColor.getFillColor();
            this.context.fillRect(this.screenCoordinate.x, this.screenCoordinate.y, this.scaledSize, this.scaledSize);
          }
        }
      }
      if (this.state.gameOptions.crewBrainDebugEnabled) {
        this.renderTileDebug(tile);
      }
    }
    /**
     * @param {GridTile} tile 
     * @param {string} strokeStyle
     */
    renderTileWire(tile, strokeStyle) {
      if (!tile) {
        return;
      }
      this.context.strokeStyle = strokeStyle;
      this.context.lineWidth = 2;
      this.screenCoordinate.copy(tile.origin);
      this.screenCoordinate.addXY(2, 2);
      this.screenCoordinate2.copy(tile.origin);
      this.screenCoordinate2.addXY(Settings.tile.size - 2, Settings.tile.size - 2);
      this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
      this.projection.worldToScreen(this.screenCoordinate2, this.screenCoordinate2);
      this.context.strokeRect(this.screenCoordinate.x, this.screenCoordinate.y, this.screenCoordinate2.x - this.screenCoordinate.x, this.screenCoordinate2.y - this.screenCoordinate.y);
    }
    /**
     * @private
     * @param {GridTile} tile 
     */
    renderTileWireframe(tile) {
      if (!tile) {
        return;
      }
      if (!tile.tileType.lightingSupported) {
        if (tile.open) {
          this.renderTileWire(tile, "#4444");
        } else {
          this.renderTileWire(tile, "#AAF4");
        }
      } else {
        const lighting = tile.lighting;
        if (!lighting.everVisibleToCharacter) {
          return;
        }
        const shadowColor = lighting.calculateShadowColor();
        if (tile.open) {
          this.renderTileWire(tile, "#4444");
        } else {
          if (!tile.open && tile.tileType.rarityModifier !== TileTypeRarity.COMMON) {
            if (tile.tileType.rarityModifier === TileTypeRarity.UPGRADE) {
              this.renderTileWire(tile, "#AAF4");
            } else if (tile.tileType.rarityModifier === TileTypeRarity.GOLD) {
              this.renderTileWire(tile, "#FFA4");
            } else if (tile.tileType.rarityModifier === TileTypeRarity.ORE) {
              this.renderTileWire(tile, "#FAF4");
            } else if (tile.tileType.rarityModifier === TileTypeRarity.RUBY) {
              this.renderTileWire(tile, "#FAA4");
            } else {
              this.renderTileWire(tile, "#AAF4");
            }
          } else {
            this.renderTileWire(tile, "#AAF4");
          }
        }
      }
      if (this.state.gameOptions.crewBrainDebugEnabled) {
        this.renderTileDebug(tile);
      }
    }
    /**
     * @private
     * @param {GridTile} tile 
     */
    renderTileDebug(tile) {
      const vectorFieldNumber = this.vectorField.vectorFieldNumber;
      const mineScore = tile.pathData.getMineScore(vectorFieldNumber);
      if (mineScore === VectorFieldScores.UNSET) {
        return;
      }
      this.screenCoordinate.copy(tile.origin);
      this.screenCoordinate.addXY(Settings.tile.quarterSize, Settings.tile.quarterSize);
      this.screenCoordinate2.copy(tile.origin);
      this.screenCoordinate2.addXY(Settings.tile.threeQuarterSize, Settings.tile.threeQuarterSize);
      this.projection.worldToScreen(this.screenCoordinate, this.screenCoordinate);
      this.projection.worldToScreen(this.screenCoordinate2, this.screenCoordinate2);
      if (mineScore === VectorFieldScores.IN_RANGE_UNSEEN) {
        this.context.fillStyle = "#8665";
      } else if (mineScore === VectorFieldScores.WORTHLESS) {
        this.context.fillStyle = "#8885";
      }
      this.context.fillRect(this.screenCoordinate.x, this.screenCoordinate.y, this.screenCoordinate2.x - this.screenCoordinate.x, this.screenCoordinate2.y - this.screenCoordinate.y);
    }
    /**
     * @private
     */
    renderSkills() {
      const skills = this.state.skillTreeGraph.skills;
      for (let i = 0; i < skills.length; i++) {
        const skill = skills[i];
        if (!skill.isUnlocked()) {
          continue;
        }
        const renderer = skill.getRenderer();
        if (renderer) {
          renderer.renderSkill(this.context, this.projection);
        }
      }
    }
    /**
     * @private
     */
    renderEffects() {
      this.renderSpriteEffects();
    }
    /**
     * @private
     */
    renderSpriteEffects() {
      const effects = this.state.effectManager.spriteEffects;
      if (effects.length === 0) {
        return;
      }
      this.renderEffectList(effects);
    }
    /**
     * @private
     * @param {Effect[]} effects
     */
    renderEffectList(effects) {
      for (let i = 0; i < effects.length; i++) {
        const effect = effects[i];
        if (!effect || effect.isEffectFinished() || effect.isNotStarted()) {
          continue;
        }
        const sprite = effect.getSprite();
        if (!sprite) {
          continue;
        }
        const effectPosition = effect.getPosition();
        if (this.projection.isVisible(effectPosition, Settings.tile.size)) {
          this.projection.worldToScreen(effectPosition, this.screenCoordinate);
          this.renderScaledSprite(sprite, this.screenCoordinate);
        }
      }
    }
    /**
     * @private
     * @param {Sprite} sprite
     * @param {Vector} canvasCoordinate The canvas coordinate.
     */
    renderScaledSprite(sprite, canvasCoordinate) {
      if (sprite) {
        const spriteSize = sprite.getSize();
        this.context.drawImage(
          sprite.getImage(),
          sprite.spriteX,
          sprite.spriteY,
          // coords of sprite in sheet (top left corner)
          spriteSize,
          spriteSize,
          // width/height of sprite
          canvasCoordinate.x,
          canvasCoordinate.y,
          // canvas coords to render sprite (top left corner)
          this.scaledSize,
          this.scaledSize
        );
      }
    }
    /**
     * @private
     * @param {Sprite} sprite
     * @param {Vector} canvasCoordinate The canvas coordinate.
     */
    renderSprite(sprite, canvasCoordinate) {
      if (sprite) {
        this.context.drawImage(
          sprite.getImage(),
          sprite.spriteX,
          sprite.spriteY,
          // coords of sprite in sheet (top left corner)
          this.spriteSize,
          this.spriteSize,
          // width/height of sprite
          canvasCoordinate.x,
          canvasCoordinate.y,
          // canvas coords to render sprite (top left corner)
          this.scaledSize,
          this.scaledSize
        );
      }
    }
  };

  // src/view/bonuses/ActiveBonusView.js
  var DISPLAY_STATE_UNSET = -1;
  var ActiveBonusView = class extends View {
    /**
     * @param {string} parentId 
     * @param {string} elementId 
     * @param {Bonus} bonus
     */
    constructor(parentId, elementId, bonus) {
      super(parentId, elementId);
      this.bonus = bonus;
      this.mainElement = null;
      this.activeProgressElement = null;
      this.titleElement = null;
      this.descriptionElement = null;
      this.displayedTitle = null;
      this.displayedDescription = null;
      this.displayState = DISPLAY_STATE_UNSET;
    }
    /**
     * @override
     */
    initializeView() {
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("ActiveSkillView.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      this.mainElement = Page.createElement("div", parent, id, "active-skill-button-outer-active");
      this.activeProgressElement = Page.createElement("div", this.mainElement, null, "active-skill-panel-activated");
      const bodyElement = Page.createElement("div", this.mainElement, null, "active-skill-button-body");
      const iconElement = Page.createElement("div", bodyElement, null, "icon-container");
      const titleDescriptionContainer = Page.createElement("div", bodyElement, null, "active-skill-title-description-container");
      const imgElement = Page.createElement("img", iconElement, null, null);
      imgElement.src = this.bonus.spriteFileName;
      this.titleElement = Page.createElement("div", titleDescriptionContainer, null, "skill-panel-row1-title");
      this.titleElement.innerHTML = "";
      this.descriptionElement = Page.createElement("div", titleDescriptionContainer, null, "skill-panel-row2-description");
      this.descriptionElement.innerHTML = "";
      this.setInitialVisibility(true);
      super.initializeView();
    }
    // /**
    //  * Updates the user interface to reflect the data in the model.
    //  */
    // updateView() {
    //     //////this.setViewVisible(this.skill.isSkillUnlocked());
    //     super.updateView();
    // }
    /**
     * @override
     */
    updateViewContents() {
      const title = this.bonus.getTitle();
      if (title !== this.displayedTitle) {
        this.displayedTitle = title;
        this.titleElement.innerHTML = title;
      }
      const description = this.bonus.getDescription();
      if (description && description !== this.displayedDescription) {
        this.displayedDescription = description;
        if (this.descriptionElement) {
          this.descriptionElement.innerHTML = description;
        }
      }
      const percent = this.bonus.getActivationPercent();
      this.activeProgressElement.style.width = percent + "%";
    }
    // /**
    //  * @private
    //  * @returns {number}
    //  */
    // getDisplayState() {
    //     return DISPLAY_STATE_ACTIVATED;
    //     // if (this.bonus.isActivated()) {
    //     //     return DISPLAY_STATE_ACTIVATED;
    //     // }
    //     // else if (this.bonus.isActivationReady()) {
    //     //     return DISPLAY_STATE_NOT_ACTIVATED_READY;
    //     // }
    //     // else {
    //     //     return DISPLAY_STATE_NOT_ACTIVATED_NOT_READY;
    //     // }
    // }
  };

  // src/view/bonuses/ActiveBonusesView.js
  var ActiveBonusesView = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {BonusCollection} bonusCollection 
     */
    constructor(parentId, bonusCollection) {
      super(parentId, PageIds.ACTIVE_BONUSES_PANEL);
      const elementId = this.getElementId();
      const bonuses = bonusCollection.activeBonuses;
      for (let i = 0; i < bonuses.length; i++) {
        const bonusView = new ActiveBonusView(elementId, elementId + "_" + i, bonuses[i]);
        this.addView(bonusView);
      }
      this.bonusCollection = bonusCollection;
      this.displayedChangeCount = -1;
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "active-skills-panel");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      if (this.displayedChangeCount !== this.bonusCollection.activeChangeCount) {
        this.displayedChangeCount = this.bonusCollection.activeChangeCount;
        console.log("-------------------------------");
        console.log("active change count: " + this.bonusCollection.activeChangeCount);
        console.log("   active bonuses:  " + this.bonusCollection.activeBonuses.length);
        this.removeChildViewElements();
        const elementId = this.getElementId();
        const bonuses = this.bonusCollection.activeBonuses;
        for (let i = 0; i < bonuses.length; i++) {
          const skillView = new ActiveBonusView(elementId, elementId + "_" + i, bonuses[i]);
          this.addView(skillView);
          console.log("  adding view: " + bonuses[i].id);
          skillView.initializeView();
        }
      }
      super.updateViewContents();
    }
    /**
     * Returns the value that the display property should be set to in order to make
     * the element visible. 
     * 
     * By default this is 'block', but you should overwrite this if the element is 'display:flex' or something other than 'display:block'.
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "flex";
    }
  };

  // src/view/main/bottom/CenterButtonView.js
  var CenterButtonView = class extends View {
    /**
     * @param {string} parentId
     * @param {Projection} projection
     * @param {PanAnimation} panAnimation 
     */
    constructor(parentId, projection, panAnimation) {
      super(parentId, PageIds.CENTER_ON_CHARACTER_BUTTON);
      this.projection = projection;
      this.panAnimation = panAnimation;
      this.setInitialVisibility(false);
    }
    /**
     * @override
     * @inheritdoc
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const buttonElement = Page.createElement("div", parentElement, this.elementId, "center-on-character-button");
      buttonElement.style.display = "none";
      const imageElement = Page.createElement("img", buttonElement, null, null);
      imageElement.src = "images/ui_center_button.png";
      imageElement.title = "Center on Crew";
      const thisRef = this;
      buttonElement.onclick = function() {
        thisRef.panAnimation.startAnimation();
      };
      super.initializeView();
    }
    /**
     * @override
     */
    updateView() {
      const visible = !this.projection.stayCenteredOnCharacter && !this.panAnimation.animating;
      if (visible !== this.isViewVisible()) {
        this.setViewVisible(visible);
      }
      super.updateView();
    }
  };

  // src/view/main/bottom/BottomRowButtonContainer.js
  var BottomRowButtonContainer = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {Projection} projection
     * @param {PanAnimation} panAnimation
     */
    constructor(parentId, elementId, projection, panAnimation) {
      super(parentId, elementId);
      this.addView(new CenterButtonView(elementId, projection, panAnimation));
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "bottom-row-button-container");
      super.initializeView();
    }
  };

  // src/view/main/bottom/damage/BaseDamageOreView.js
  var BaseDamageOreView = class extends View {
    /**
     * @param {string} parentId
     * @param {Damage} damage
     * @param {Values} values
     */
    constructor(parentId, damage, values) {
      super(parentId, parentId + "_base_ore");
      this.damage = damage;
      this.values = values;
      this.displayedBasePickDamage = new BigNum(0);
      this.basePickDamageString = null;
      this.workingNum = new BigNum(0);
      this.turnsPerSecond = new BigNum(Settings.time.turnsPerSecond);
      this.baseAdditiveBody = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const baseAdditiveDiv = Page.createElement("div", parentElement, null, "mine-damage-panel-main-section");
      const baseAdditiveHeader = Page.createElement("div", baseAdditiveDiv, null, "mine-damage-panel-section-header");
      baseAdditiveHeader.innerHTML = "Base";
      this.baseAdditiveBody = Page.createElement("div", baseAdditiveDiv, null, "mine-damage-panel-section-body");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const basePickDamagePerTurn = this.damage.basePickDamagePerTurn;
      const baseAdditiveBonusPerTurn = this.values.baseAdditiveBonusPerTurn.getValue();
      if (!this.basePickDamageString || !baseAdditiveBonusPerTurn.equals(this.displayedBasePickDamage)) {
        this.displayedBasePickDamage.copy(baseAdditiveBonusPerTurn);
        this.workingNum.copy(basePickDamagePerTurn);
        this.workingNum.add(baseAdditiveBonusPerTurn);
        this.workingNum.mul(this.turnsPerSecond);
        this.basePickDamageString = NumberFormatter.formatBigNum(this.workingNum) + "/s";
        this.baseAdditiveBody.innerHTML = this.basePickDamageString;
      }
      super.updateViewContents();
    }
  };

  // src/view/main/bottom/damage/DepthDamageView.js
  var DepthDamageView = class extends View {
    /**
     * @param {string} parentId
     * @param {Damage} damage
     */
    constructor(parentId, damage) {
      super(parentId, parentId + "_depth");
      this.damage = damage;
      this.displayedDamageMultiplier = new BigNum(-10);
      this.bonusString = null;
      this.body = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const container = Page.createElement("div", parentElement, this.getElementId(), "mine-damage-panel-main-section");
      const header = Page.createElement("div", container, null, "mine-damage-panel-section-header");
      header.innerHTML = "Depth";
      this.body = Page.createElement("div", container, null, "mine-damage-panel-section-body");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const damageMultiplier = this.damage.depthDamageMultiplier;
      if (!this.bonusString || !damageMultiplier.equals(this.displayedDamageMultiplier)) {
        this.displayedDamageMultiplier.copy(damageMultiplier);
        this.bonusString = NumberFormatter.formatBigNum(damageMultiplier);
        this.body.innerHTML = this.bonusString;
      }
      super.updateViewContents();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/bottom/damage/GoldDamageView.js
  var GoldDamageView = class extends View {
    /**
     * @param {string} parentId
     * @param {Damage} damage
     */
    constructor(parentId, damage) {
      super(parentId, parentId + "_gold");
      this.damage = damage;
      this.displayedGoldDamageMultiplier = new BigNum(-1);
      this.goldBonusString = null;
      this.body = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const container = Page.createElement("div", parentElement, this.getElementId(), "mine-damage-panel-main-section");
      const header = Page.createElement("div", container, null, "mine-damage-panel-section-header");
      header.innerHTML = "Gold";
      this.body = Page.createElement("div", container, null, "mine-damage-panel-section-body");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const goldDamageMultiplier = this.damage.goldDamageMultiplier;
      if (!this.goldBonusString || !goldDamageMultiplier.equals(this.displayedGoldDamageMultiplier)) {
        this.displayedGoldDamageMultiplier.copy(goldDamageMultiplier);
        this.goldBonusString = NumberFormatter.formatBigNum(goldDamageMultiplier);
        this.body.innerHTML = this.goldBonusString;
      }
      super.updateViewContents();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/bottom/damage/MineDamageLabelView.js
  var MineDamageLabelView = class extends View {
    /**
     * @param {string} parentId
     */
    constructor(parentId) {
      super(parentId, null);
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const labelElement = Page.createElement("div", parentElement, null, "mine-damage-panel-operator-section");
      const labelTopRow = Page.createElement("div", labelElement, null, "mine-damage-panel-section-header");
      labelTopRow.innerHTML += "Mine";
      const labelBottomRow = Page.createElement("div", labelElement, null, "mine-damage-panel-section-body");
      labelBottomRow.innerHTML = "Damage:";
      super.initializeView();
    }
  };

  // src/view/main/bottom/damage/MultiplierOreView.js
  var MultiplierOreView = class extends View {
    /**
     * @param {string} parentId
     * @param {Values} values
     */
    constructor(parentId, values) {
      super(parentId, parentId + "_multore");
      this.values = values;
      this.displayedBonus = new BigNum(0);
      this.displayedValue = null;
      this.workingNum = new BigNum(0);
      this.oneBigNum = new BigNum(1);
      this.body = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const baseMultiDiv = Page.createElement("div", parentElement, null, "mine-damage-panel-main-section");
      const baseMultiHeader = Page.createElement("div", baseMultiDiv, null, "mine-damage-panel-section-header");
      baseMultiHeader.innerHTML = "Ore Multi";
      this.body = Page.createElement("div", baseMultiDiv, null, "mine-damage-panel-section-body");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const baseMultiplicativeBonus = this.values.baseMultiplicativeBonusValue.getValue();
      if (!this.displayedValue || !baseMultiplicativeBonus.equals(this.displayedBonus)) {
        this.displayedBonus.copy(baseMultiplicativeBonus);
        this.workingNum.copy(this.oneBigNum);
        this.workingNum.add(baseMultiplicativeBonus);
        this.displayedValue = NumberFormatter.formatBigNum(this.workingNum);
        this.body.innerHTML = this.displayedValue;
      }
      super.updateViewContents();
    }
  };

  // src/view/main/bottom/damage/RubyDamageView.js
  var RubyDamageView = class extends View {
    /**
     * @param {string} parentId
     * @param {Damage} damage
     */
    constructor(parentId, damage) {
      super(parentId, parentId + "_ruby");
      this.damage = damage;
      this.displayedDamageMultiplier = new BigNum(-1);
      this.damageBonusString = null;
      this.body = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const container = Page.createElement("div", parentElement, this.getElementId(), "mine-damage-panel-main-section");
      const header = Page.createElement("div", container, null, "mine-damage-panel-section-header");
      header.innerHTML = "Ruby";
      this.body = Page.createElement("div", container, null, "mine-damage-panel-section-body");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const damageMultiplier = this.damage.rubyDamageMultiplier;
      if (!this.damageBonusString || !damageMultiplier.equals(this.displayedDamageMultiplier)) {
        this.displayedDamageMultiplier.copy(damageMultiplier);
        this.damageBonusString = NumberFormatter.formatBigNum(damageMultiplier);
        this.body.innerHTML = this.damageBonusString;
      }
      super.updateViewContents();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/bottom/damage/OperatorView.js
  var OperatorView = class extends View {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {string} operator
     */
    constructor(parentId, elementId, operator) {
      super(parentId, elementId);
      this.operator = operator;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const container = Page.createElement("div", parentElement, this.getElementId(), "mine-damage-panel-operator-section");
      const header = Page.createElement("div", container, null, null);
      header.innerHTML += "&nbsp;";
      const body = Page.createElement("div", container, null, null);
      body.innerHTML = this.operator;
      super.initializeView();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/bottom/damage/PrestigeDamageView.js
  var PrestigeDamageView = class extends View {
    /**
     * @param {string} parentId
     * @param {Damage} damage
     */
    constructor(parentId, damage) {
      super(parentId, parentId + "_prestige");
      this.damage = damage;
      this.displayedPrestigeDamageMultiplier = new BigNum(0);
      this.prestigeBonusString = null;
      this.body = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const container = Page.createElement("div", parentElement, this.getElementId(), "mine-damage-panel-main-section");
      const headerElement = Page.createElement("div", container, null, "mine-damage-panel-section-header");
      headerElement.innerHTML = "Prestige";
      this.body = Page.createElement("div", container, null, "mine-damage-panel-section-body");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const damageMultiplier = this.damage.prestigeDamageMultiplier;
      if (!this.prestigeBonusString || !damageMultiplier.equals(this.displayedPrestigeDamageMultiplier)) {
        this.displayedPrestigeDamageMultiplier.copy(damageMultiplier);
        this.prestigeBonusString = NumberFormatter.formatBigNum(damageMultiplier);
        this.body.innerHTML = this.prestigeBonusString;
      }
      super.updateViewContents();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/bottom/damage/TotalDamageView.js
  var TotalDamageView = class extends View {
    /**
     * @param {string} parentId
     * @param {Damage} damage
     */
    constructor(parentId, damage) {
      super(parentId, parentId + "_tot");
      this.damage = damage;
      this.displayedTotalDamage = new BigNum(0);
      this.totalDamageString = null;
      this.workingNum = new BigNum(0);
      this.turnsPerSecond = new BigNum(Settings.time.turnsPerSecond);
      this.baseTotalBody = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const baseTotalDiv = Page.createElement("div", parentElement, null, "mine-damage-panel-main-section");
      const baseTotalHeader = Page.createElement("div", baseTotalDiv, null, "mine-damage-panel-section-header");
      baseTotalHeader.innerHTML = "Total Damage";
      this.baseTotalBody = Page.createElement("div", baseTotalDiv, null, "mine-damage-panel-section-body");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const totalDamagePerTurn = this.damage.totalPickDamagePerTurn;
      if (!this.totalDamageString || !totalDamagePerTurn.equals(this.displayedTotalDamage)) {
        this.displayedTotalDamage.copy(totalDamagePerTurn);
        this.workingNum.copy(totalDamagePerTurn);
        this.workingNum.mul(this.turnsPerSecond);
        this.totalDamageString = NumberFormatter.formatBigNum(this.workingNum);
        this.baseTotalBody.innerHTML = this.totalDamageString + "/Sec";
      }
    }
  };

  // src/view/main/bottom/damage/MinedDamageView.js
  var MinedDamageView = class extends View {
    /**
     * @param {string} parentId
     * @param {Damage} damage
     */
    constructor(parentId, damage) {
      super(parentId, parentId + "_mined");
      this.damage = damage;
      this.displayedDamageMultiplier = new BigNum(0);
      this.bonusString = null;
      this.body = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const container = Page.createElement("div", parentElement, this.getElementId(), "mine-damage-panel-main-section");
      const headerElement = Page.createElement("div", container, null, "mine-damage-panel-section-header");
      headerElement.innerHTML = "Mined";
      this.body = Page.createElement("div", container, null, "mine-damage-panel-section-body");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const damageMultiplier = this.damage.minedDamageMultiplier;
      if (!this.bonusString || !damageMultiplier.equals(this.displayedDamageMultiplier)) {
        this.displayedDamageMultiplier.copy(damageMultiplier);
        this.bonusString = NumberFormatter.formatBigNum(damageMultiplier);
        this.body.innerHTML = this.bonusString;
      }
      super.updateViewContents();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/bottom/damage/BlocksDamageView.js
  var BlocksDamageView = class extends View {
    /**
     * @param {string} parentId
     * @param {Damage} damage
     */
    constructor(parentId, damage) {
      super(parentId, parentId + "_blocks");
      this.damage = damage;
      this.displayedDamageMultiplier = new BigNum(-1);
      this.damageBonusString = null;
      this.body = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const container = Page.createElement("div", parentElement, this.getElementId(), "mine-damage-panel-main-section");
      const header = Page.createElement("div", container, null, "mine-damage-panel-section-header");
      header.innerHTML = "Blocks";
      this.body = Page.createElement("div", container, null, "mine-damage-panel-section-body");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const damageMultiplier = this.damage.blockDamageMultiplier;
      if (!this.damageBonusString || !damageMultiplier.equals(this.displayedDamageMultiplier)) {
        this.displayedDamageMultiplier.copy(damageMultiplier);
        this.damageBonusString = NumberFormatter.formatBigNum(damageMultiplier);
        this.body.innerHTML = this.damageBonusString;
      }
      super.updateViewContents();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/bottom/damage/MineDamageView.js
  var MineDamageView = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {Damage} damage
     * @param {Values} values
     * @param {PartyTarget} partyTarget
     */
    constructor(parentId, damage, values, partyTarget) {
      super(parentId, PageIds.MINE_DAMAGE_VIEW);
      this.one = new BigNum(1);
      this.damage = damage;
      this.minedDamageVisible = false;
      this.prestigeDamageVisible = false;
      this.goldDamageVisible = false;
      this.depthDamageVisible = false;
      this.rubyDamageVisible = false;
      this.blocksDamageVisible = false;
      this.addView(new MineDamageLabelView(this.elementId));
      this.addView(new BaseDamageOreView(this.elementId, damage, values));
      this.addView(new OperatorView(this.elementId, this.elementId + "3", " x "));
      this.addView(new MultiplierOreView(this.elementId, values));
      this.minedDamageOperator = new OperatorView(this.elementId, this.elementId + "6", " x ");
      this.minedDamageView = new MinedDamageView(this.elementId, damage);
      this.addView(this.minedDamageOperator);
      this.addView(this.minedDamageView);
      this.minedDamageOperator.setInitialVisibility(false);
      this.minedDamageView.setInitialVisibility(false);
      this.prestigeOperator = new OperatorView(this.elementId, this.elementId + "7", " x ");
      this.prestigeDamageView = new PrestigeDamageView(this.elementId, damage);
      this.addView(this.prestigeOperator);
      this.addView(this.prestigeDamageView);
      this.prestigeOperator.setInitialVisibility(false);
      this.prestigeDamageView.setInitialVisibility(false);
      this.goldOperator = new OperatorView(this.elementId, this.elementId + "8", " x ");
      this.goldDamageView = new GoldDamageView(this.elementId, damage);
      this.addView(this.goldOperator);
      this.addView(this.goldDamageView);
      this.goldOperator.setInitialVisibility(false);
      this.goldDamageView.setInitialVisibility(false);
      this.depthOperator = new OperatorView(this.elementId, this.elementId + "9", " x ");
      this.depthDamageView = new DepthDamageView(this.elementId, damage);
      this.addView(this.depthOperator);
      this.addView(this.depthDamageView);
      this.depthOperator.setInitialVisibility(false);
      this.depthDamageView.setInitialVisibility(false);
      this.rubyOperator = new OperatorView(this.elementId, this.elementId + "10", " x ");
      this.rubyDamageView = new RubyDamageView(this.elementId, damage);
      this.addView(this.rubyOperator);
      this.addView(this.rubyDamageView);
      this.rubyOperator.setInitialVisibility(false);
      this.rubyDamageView.setInitialVisibility(false);
      this.blocksOperator = new OperatorView(this.elementId, this.elementId + "11", " x ");
      this.blocksDamageView = new BlocksDamageView(this.elementId, damage);
      this.addView(this.blocksOperator);
      this.addView(this.blocksDamageView);
      this.blocksOperator.setInitialVisibility(false);
      this.blocksDamageView.setInitialVisibility(false);
      this.addView(new OperatorView(this.elementId, this.elementId + "12", " = "));
      this.addView(new TotalDamageView(this.elementId, damage));
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "mine-damage-panel");
      super.initializeView();
    }
    /**
     * @override
     */
    updateView() {
      const minedDamageVisible = this.damage.minedDamageMultiplier.greaterThan(this.one);
      const prestigeDamageVisible = this.damage.prestigeDamageMultiplier.greaterThan(this.one);
      const goldDamageVisible = this.damage.goldDamageMultiplier.greaterThan(this.one);
      const depthDamageVisible = this.damage.depthDamageMultiplier.greaterThan(this.one);
      const rubyDamageVisible = this.damage.rubyDamageMultiplier.greaterThan(this.one);
      const blocksDamageVisible = this.damage.blockDamageMultiplier.greaterThan(this.one);
      if (this.minedDamageVisible !== minedDamageVisible) {
        this.minedDamageVisible = minedDamageVisible;
        this.minedDamageOperator.setViewVisible(minedDamageVisible);
        this.minedDamageView.setViewVisible(minedDamageVisible);
      }
      if (this.prestigeDamageVisible !== prestigeDamageVisible) {
        this.prestigeDamageVisible = prestigeDamageVisible;
        this.prestigeOperator.setViewVisible(prestigeDamageVisible);
        this.prestigeDamageView.setViewVisible(prestigeDamageVisible);
      }
      if (this.goldDamageVisible !== goldDamageVisible) {
        this.goldDamageVisible = goldDamageVisible;
        this.goldOperator.setViewVisible(goldDamageVisible);
        this.goldDamageView.setViewVisible(goldDamageVisible);
      }
      if (this.depthDamageVisible !== depthDamageVisible) {
        this.depthDamageVisible = depthDamageVisible;
        this.depthOperator.setViewVisible(depthDamageVisible);
        this.depthDamageView.setViewVisible(depthDamageVisible);
      }
      if (this.rubyDamageVisible !== rubyDamageVisible) {
        this.rubyDamageVisible = rubyDamageVisible;
        this.rubyOperator.setViewVisible(rubyDamageVisible);
        this.rubyDamageView.setViewVisible(rubyDamageVisible);
      }
      if (this.blocksDamageVisible !== blocksDamageVisible) {
        this.blocksDamageVisible = blocksDamageVisible;
        this.blocksOperator.setViewVisible(blocksDamageVisible);
        this.blocksDamageView.setViewVisible(blocksDamageVisible);
      }
      super.updateView();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/bottom/RowContainerDamage.js
  var RowContainerDamage = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {Damage} damage
     * @param {Values} values
     * @param {PartyTarget} partyTarget
     */
    constructor(parentId, elementId, damage, values, partyTarget) {
      super(parentId, elementId);
      this.addView(new MineDamageView(elementId, damage, values, partyTarget));
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "bottom-row-damage");
      super.initializeView();
    }
  };

  // src/view/main/bottom/control/TargetDepthView.js
  var TargetDepthView = class extends View {
    /**
     * @param {string} parentId
     * @param {PartyTarget} partyTarget
     */
    constructor(parentId, partyTarget) {
      super(parentId, parentId + "_target");
      this.partyTarget = partyTarget;
      this.displayedTargetRow = -10;
      this.baseBody = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const container = Page.createElement("div", parentElement, null, "mine-damage-panel-main-section");
      const header = Page.createElement("div", container, null, "mine-damage-panel-section-header");
      header.innerHTML = "Target Depth";
      this.baseBody = Page.createElement("div", container, null, "mine-damage-panel-section-body");
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const targetRow = this.partyTarget.targetRow;
      if (this.displayedTargetRow != targetRow) {
        this.displayedTargetRow = targetRow;
        this.baseBody.innerHTML = NumberFormatter.formatNumber(targetRow);
      }
    }
  };

  // src/view/main/bottom/control/MineModeOption.js
  var MineModeOption = class extends View {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {MineControl} mineControl
     * @param {MineMode} mineMode
     * @param {string} topRowText
     * @param {string} bottomRowText
     */
    constructor(parentId, elementId, mineControl, mineMode, topRowText, bottomRowText) {
      super(parentId, elementId);
      this.mineControl = mineControl;
      this.mineMode = mineMode;
      this.topRowText = topRowText;
      this.bottomRowText = bottomRowText;
      this.mainElement = null;
      this.displayedActive = false;
    }
    /**
     * @override
     */
    initializeView() {
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("MineModeOption.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      this.displayedActive = this.mineControl.activeMode === this.mineMode;
      this.mainElement = Page.createElement("div", parent, id, this.displayedActive ? "mine-mode-button-outer-active" : "mine-mode-button-outer-not-active");
      const bodyElement = Page.createElement("div", this.mainElement, null, "mine-mode-button-row");
      const iconElement = Page.createElement("div", bodyElement, null, "icon-container");
      const imgElement = Page.createElement("img", iconElement, null, "icon-container");
      imgElement.src = Images.pick;
      const titleDescriptionContainer = Page.createElement("div", bodyElement, null, "pick-upgrade-title-description-container");
      const topRowElement = Page.createElement("div", titleDescriptionContainer, null, null);
      topRowElement.innerHTML = this.topRowText;
      const bottomRowElement = Page.createElement("div", titleDescriptionContainer, null, "mined-upgrade-button-description");
      bottomRowElement.innerHTML = this.bottomRowText;
      const thisRef = this;
      this.mainElement.onclick = function() {
        console.log("MineModeOption click mode=" + thisRef.mineMode.id);
        thisRef.mineControl.setModeActive(thisRef.mineMode);
      };
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const activeMode = this.mineControl.activeMode === this.mineMode;
      if (this.displayedActive !== activeMode) {
        this.displayedActive = activeMode;
        if (activeMode) {
          this.mainElement.className = "mine-mode-button-outer-active";
        } else {
          this.mainElement.className = "mine-mode-button-outer-not-active";
        }
      }
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/bottom/control/MineControlView.js
  var MineControlView = class extends ParentView {
    /**
     * 
     * @param {string} parentId 
     * @param {MineControl} mineControl 
     * @param {PartyTarget} partyTarget
     */
    constructor(parentId, mineControl, partyTarget) {
      super(parentId, "mineControl");
      this.addView(new MineModeOption(this.elementId, this.elementId + "_up", mineControl, MineModes.MINE_SHALLOWER, "Mine", "Shallower"));
      this.addView(new MineModeOption(this.elementId, this.elementId + "_down", mineControl, MineModes.MINE_DEEPER, "Mine", "Deeper"));
      this.addView(new MineModeOption(this.elementId, this.elementId + "_current", mineControl, MineModes.MINE_CURRENT, "Mine", "Current"));
      this.addView(new MineModeOption(this.elementId, this.elementId + "_auto", mineControl, MineModes.MINE_AUTO, "Mine", "Auto"));
      this.addView(new TargetDepthView(this.elementId, partyTarget));
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "mine-control-panel");
      super.initializeView();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/bottom/RowContainerMineControl.js
  var RowContainerMineControl = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {MineControl} mineControl
     * @param {PartyTarget} partyTarget
     */
    constructor(parentId, elementId, mineControl, partyTarget) {
      super(parentId, elementId);
      this.addView(new MineControlView(elementId, mineControl, partyTarget));
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "bottom-row-mine-control");
      super.initializeView();
    }
  };

  // src/view/main/bottom/BottomRowContainer.js
  var BottomRowContainer = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {Damage} damage
     * @param {Values} values
     * @param {PartyTarget} partyTarget
     * @param {MineControl} mineControl
     * @param {Crew} crew
     * @param {Projection} projection
     * @param {PanAnimation} panAnimation
     * @param {Statistics} statistics
     */
    constructor(parentId, elementId, damage, values, partyTarget, mineControl, crew, projection, panAnimation, statistics) {
      super(parentId, elementId);
      this.addView(new RowContainerMineControl(elementId, "bottomRowMineControl", mineControl, partyTarget));
      this.addView(new RowContainerDamage(elementId, "bottomRowDamage", damage, values, partyTarget));
      this.addView(new BottomRowButtonContainer(elementId, "bottomRowButtonContainer", projection, panAnimation));
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "bottom-row");
      super.initializeView();
    }
  };

  // src/view/main/top/TitleView.js
  var TitleView = class extends View {
    /**
     * @param {string} parentId 
     */
    constructor(parentId) {
      super(parentId, parentId + "_title");
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const gameTitleContainer = Page.createElement("div", parentElement, null, "game-title-container");
      const gameTitleBody = Page.createElement("div", gameTitleContainer, null, "game-title-body");
      const gameTitle1 = Page.createElement("div", gameTitleBody, null, "game-title-display");
      gameTitle1.innerHTML = "Mining";
      const gameTitle2 = Page.createElement("div", gameTitleBody, null, "game-title-display");
      gameTitle2.innerHTML = "Crew";
      super.initializeView();
    }
  };

  // src/view/main/top/CurrencyContainerSectionView.js
  var CurrencyContainerSectionView = class extends View {
    /**
     * @param {string} parentId 
     * @param {string} elementId
     * @param {string} title
     * @param {string} iconFileName
     * @param {Totals} totals 
     */
    constructor(parentId, elementId, title, iconFileName, totals) {
      super(parentId, elementId);
      this.title = title;
      this.iconFileName = iconFileName;
      this.totals = totals;
      this.displayedDescription = null;
      this.valueElement = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("CurrencyContainerSectionView.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      const mainElement = Page.createElement("div", parent, id, "currency-container-section");
      const bodyElement = Page.createElement("div", mainElement, null, "currency-container-body");
      const iconElement = Page.createElement("div", bodyElement, null, "icon-container");
      const imgElement = Page.createElement("img", iconElement, null, "icon-container");
      imgElement.src = this.iconFileName;
      const titleDescriptionContainer = Page.createElement("div", bodyElement, this.elementId + "_text", "mined-upgrade-title-description-container");
      const titleElement = Page.createElement("div", titleDescriptionContainer, null, null);
      titleElement.innerHTML = this.title;
      this.valueElement = Page.createElement("div", titleDescriptionContainer, null, "mined-upgrade-button-description");
      this.valueElement.innerHTML = "";
      this.setInitialVisibility(true);
      super.initializeView();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/top/GoldSectionView.js
  var GoldSectionView = class extends CurrencyContainerSectionView {
    /**
     * @param {string} parentId 
     * @param {Totals} totals 
     */
    constructor(parentId, totals) {
      super(parentId, parentId + "gold_section", "Gold", Images.currency.gold, totals);
      this.displayedValue = new BigNum(0);
      this.formattedValue = null;
    }
    /**
     * @override
     */
    updateViewContents() {
      const currency = this.totals.gold;
      if (!this.formattedValue || !currency.equals(this.displayedValue)) {
        this.displayedValue.copy(currency);
        this.formattedValue = NumberFormatter.formatBigNum(currency);
        this.valueElement.innerHTML = this.formattedValue;
      }
    }
  };

  // src/view/main/top/RubySectionView.js
  var RubySectionView = class extends CurrencyContainerSectionView {
    /**
     * @param {string} parentId 
     * @param {Totals} totals 
     */
    constructor(parentId, totals) {
      super(parentId, parentId + "ruby_section", "Ruby", Images.currency.ruby, totals);
      this.displayedValue = new BigNum(0);
      this.formattedValue = null;
    }
    /**
     * @override
     */
    updateViewContents() {
      const currency = this.totals.ruby;
      if (!this.formattedValue || !currency.equals(this.displayedValue)) {
        this.displayedValue.copy(currency);
        this.formattedValue = NumberFormatter.formatBigNum(currency);
        this.valueElement.innerHTML = this.formattedValue;
      }
    }
  };

  // src/view/main/top/OreSectionView.js
  var OreSectionView = class extends CurrencyContainerSectionView {
    /**
     * @param {string} parentId 
     * @param {Totals} totals 
     */
    constructor(parentId, totals) {
      super(parentId, parentId + "ore_section", "Mined Ore", Images.currency.ore, totals);
      this.displayedValue = new BigNum(0);
      this.formattedValue = null;
    }
    /**
     * @override
     */
    updateViewContents() {
      const currency = this.totals.ore;
      if (!this.formattedValue || !currency.equals(this.displayedValue)) {
        this.displayedValue.copy(currency);
        this.formattedValue = NumberFormatter.formatBigNum(currency);
        this.valueElement.innerHTML = this.formattedValue;
      }
    }
  };

  // src/view/main/top/PrestigeSectionView.js
  var PrestigeSectionView = class extends CurrencyContainerSectionView {
    /**
     * @param {string} parentId 
     * @param {Totals} totals 
     */
    constructor(parentId, totals) {
      super(parentId, parentId + "prestige_section", "Prestige", Images.currency.prestige, totals);
      this.displayedPrestige = new BigNum(0);
      this.displayedUnclaimedPrestige = new BigNum(0);
      this.formattedPrestigeValue = null;
    }
    /**
     * @override
     */
    updateViewContents() {
      const prestige = this.totals.prestige;
      const unclaimedPrestige = this.totals.unclaimedPrestige;
      if (!this.formattedValue || !prestige.equals(this.displayedPrestige) || !unclaimedPrestige.equals(this.displayedUnclaimedPrestige)) {
        this.displayedPrestige.copy(prestige);
        this.displayedUnclaimedPrestige.copy(unclaimedPrestige);
        if (unclaimedPrestige.equalsZero()) {
          this.formattedValue = NumberFormatter.formatBigNum(prestige);
        } else {
          this.formattedValue = NumberFormatter.formatBigNum(prestige) + " (" + NumberFormatter.formatBigNum(unclaimedPrestige) + ")";
        }
        this.valueElement.innerHTML = this.formattedValue;
      }
    }
  };

  // src/view/main/top/CurrencyContainerView.js
  var CurrencyContainerView = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {Totals} totals 
     */
    constructor(parentId, totals) {
      super(parentId, PageIds.CURRENCY_VIEW);
      this.addView(new OreSectionView(this.elementId, totals));
      this.addView(new GoldSectionView(this.elementId, totals));
      this.addView(new PrestigeSectionView(this.elementId, totals));
      this.addView(new RubySectionView(this.elementId, totals));
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "currency-container-view");
      super.initializeView();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
  };

  // src/view/main/top/RowContainerTitle.js
  var RowContainerTitle = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {Totals} totals
     */
    constructor(parentId, totals) {
      super(parentId, parentId + "_one");
      this.addView(new CurrencyContainerView(this.elementId, totals));
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "top-row-one");
      super.initializeView();
    }
  };

  // src/view/main/top/TerrainLayerProgress.js
  var TerrainLayerProgress = class extends View {
    /**
     * @param {string} parentId 
     * @param {string} elementId 
     * @param {PartyTarget} partyTarget
     * @param {Statistics} statistics 
     */
    constructor(parentId, elementId, partyTarget, statistics) {
      super(parentId, elementId);
      this.partyTarget = partyTarget;
      this.statistics = statistics;
      this.displayedLayerDescription = null;
      this.mainElement = null;
      this.imgElement = null;
      this.titleElement = null;
      this.progressElement = null;
      this.displayedTitle = null;
      this.displayedDescription = null;
      this.descriptionElement = null;
      this.displayedIconFileName = null;
      this.displayPercent = -1;
      this.displayMaxDepth = -1;
    }
    /**
     * @override
     */
    initializeView() {
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("UnlockTerrainLayerView.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      this.mainElement = Page.createElement("div", parent, id, "terrain-layer-progress-outer");
      const bodyElement = Page.createElement("div", this.mainElement, null, "mined-upgrade-button-body");
      const iconElement = Page.createElement("div", bodyElement, null, "icon-container");
      const titleDescriptionContainer = Page.createElement("div", bodyElement, this.elementId + "_text", "mined-upgrade-title-description-container");
      this.imgElement = Page.createElement("img", iconElement, null, "icon-container");
      this.imgElement.src = Images.pick;
      this.titleElement = Page.createElement("div", titleDescriptionContainer, null, null);
      this.titleElement.innerHTML = "";
      this.descriptionElement = Page.createElement("div", titleDescriptionContainer, null, "mined-upgrade-button-description");
      this.descriptionElement.innerHTML = "";
      this.progressElement = Page.createElement("div", this.mainElement, null, "terrain-layer-progress-slider");
      this.setInitialVisibility(true);
      super.initializeView();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
    /**
     * @private
     * @returns {string}
     */
    generateDescription() {
      return "Depth: " + NumberFormatter.formatNumber(this.statistics.maxDepth) + " / " + NumberFormatter.formatNumber(this.displayedLayerDescription.maxDepth);
    }
    /**
     * @override
     */
    updateViewContents() {
      const layerDescription = this.partyTarget.layerDescription;
      const nextLayerDescription = this.partyTarget.nextLayerDescription;
      const maxDepth = this.statistics.maxDepth;
      if (!nextLayerDescription) {
        return;
      }
      if (this.displayedLayerDescription !== layerDescription || this.displayMaxDepth != maxDepth) {
        this.displayedLayerDescription = layerDescription;
        this.displayMaxDepth = maxDepth;
        const nominalIndex = layerDescription.nominalIndex;
        if (nominalIndex > 0) {
          this.titleElement.innerHTML = layerDescription.name + " (" + nominalIndex + "/" + (LayerDescriptionArray.length - 2) + ")";
        } else {
          this.titleElement.innerHTML = layerDescription.name;
        }
        this.descriptionElement.innerHTML = this.generateDescription();
      }
      if (!this.displayedLayerDescription) {
        return;
      }
      const iconFileName = this.displayedLayerDescription.iconFileName;
      if (this.displayedIconFileName !== iconFileName) {
        this.displayedIconFileName = iconFileName;
        this.imgElement.src = "images/layers/" + iconFileName;
      }
      const percent = layerDescription.getDepthPercent(maxDepth);
      if (percent != this.displayPercent) {
        this.displayPercent = percent;
        if (percent >= 100) {
          this.progressElement.style.width = "0px";
        } else {
          this.progressElement.style.width = percent + "%";
        }
      }
    }
  };

  // src/view/main/top/RowContainerLayerProgress.js
  var RowContainerLayerProgress = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {PartyTarget} partyTarget
     * @param {Statistics} statistics
     */
    constructor(parentId, partyTarget, statistics) {
      super(parentId, parentId + "_layer");
      this.addView(new TerrainLayerProgress(this.elementId, this.elementId + "_progress", partyTarget, statistics));
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "top-row-two");
      super.initializeView();
    }
  };

  // src/view/main/top/RowContainerPanel.js
  var RowContainerPanel = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {Totals} totals
     * @param {PartyTarget} partyTarget
     * @param {Statistics} statistics
     */
    constructor(parentId, totals, partyTarget, statistics) {
      super(parentId, parentId + "_panel");
      this.addView(new RowContainerTitle(this.elementId, totals));
      this.addView(new RowContainerLayerProgress(this.elementId, partyTarget, statistics));
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "top-row-panel");
      super.initializeView();
    }
  };

  // src/view/main/top/TopRowContainer.js
  var TopRowContainer = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {Totals} totals
     * @param {PartyTarget} partyTarget
     * @param {Statistics} statistics
     */
    constructor(parentId, elementId, totals, partyTarget, statistics) {
      super(parentId, elementId);
      this.addView(new TitleView(elementId));
      this.addView(new RowContainerPanel(elementId, totals, partyTarget, statistics));
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "top-row");
      super.initializeView();
    }
  };

  // src/view/menu/PopupViewController.js
  var PopupViewController = class {
    /**
     */
    constructor() {
      this.popupViews = [];
      this.popupById = {};
    }
    /**
     * @param {View} popupView 
     */
    addPopupView(popupView) {
      this.popupViews.push(popupView);
      this.popupById[popupView.getElementId()] = popupView;
    }
    /**
     * 
     * @param {string} viewId 
     * @returns {boolean}
     */
    isPopupVisible(viewId) {
      const popup = this.popupById[viewId];
      if (!popup) {
        console.log("PopupViewController.isPopupVisible() UNKNOWN VIEW. viewId=" + viewId);
        return false;
      }
      return popup.isViewVisible();
    }
    /**
     * @param {string} viewId 
     */
    setPopupVisible(viewId) {
      for (let i = 0; i < this.popupViews.length; i++) {
        const popupView = this.popupViews[i];
        popupView.setViewVisible(popupView.getElementId() === viewId);
      }
    }
    /**
     * @param {string} viewId 
     * @param {string} secondaryViewId
     */
    setDoublePopupVisible(viewId, secondaryViewId) {
      for (let i = 0; i < this.popupViews.length; i++) {
        const popupView = this.popupViews[i];
        popupView.setViewVisible(popupView.getElementId() === viewId || popupView.getElementId() === secondaryViewId);
      }
    }
    hideAllPopups() {
      for (let i = 0; i < this.popupViews.length; i++) {
        this.popupViews[i].setViewVisible(false);
      }
    }
    /**
     * @param {string} viewId 
     */
    setPopupHidden(viewId) {
      const popup = this.popupById[viewId];
      if (!popup) {
        console.log("PopupViewController.setPopupHidden() UNKNOWN VIEW. viewId=" + viewId);
        return;
      }
      popup.setViewVisible(false);
    }
  };

  // src/view/menu/PopupViewToggle.js
  var PopupViewToggle = class extends View {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {PopupViewController} popupViewController 
     * @param {string} popupViewId
     * @param {string} title
     */
    constructor(parentId, elementId, popupViewController, popupViewId, title) {
      super(parentId, elementId);
      this.popupViewController = popupViewController;
      this.popupViewId = popupViewId;
      this.secondaryPopupViewId = null;
      this.title = title;
      this.mainElement = null;
      this.displayedVisible = false;
    }
    /**
     * @override
     */
    initializeView() {
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("PopupViewToggle.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      this.mainElement = Page.createElement("div", parent, id, "upgrade-button-outer");
      const row1 = Page.createElement("div", this.mainElement, null, "button-row-icon-text");
      const imgElement = Page.createElement("img", row1, null, "pick-upgrade-icon");
      imgElement.src = Images.pick;
      const titleDescriptionContainer = Page.createElement("div", row1, null, "pick-upgrade-title-description-container");
      const titleElement = Page.createElement("div", titleDescriptionContainer, null, "pick-upgrade-button-title-single-row");
      titleElement.innerHTML = this.title;
      const thisRef = this;
      this.mainElement.onclick = function() {
        const popupVisible = thisRef.popupViewController.isPopupVisible(thisRef.popupViewId);
        if (!popupVisible) {
          if (!thisRef.secondaryPopupViewId) {
            thisRef.popupViewController.setPopupVisible(thisRef.popupViewId);
          } else {
            thisRef.popupViewController.setDoublePopupVisible(thisRef.popupViewId, thisRef.secondaryPopupViewId);
          }
        } else {
          thisRef.popupViewController.hideAllPopups();
        }
      };
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const popupVisible = this.popupViewController.isPopupVisible(this.popupViewId);
      if (this.displayedVisible === popupVisible) {
        return;
      }
      this.displayedVisible = popupVisible;
      if (popupVisible) {
        this.mainElement.className = "popup-toggle-button-outer-open";
      } else {
        this.mainElement.className = "upgrade-button-outer";
      }
    }
  };

  // src/view/popup/CloseSkillTreePopupView.js
  var CloseSkillTreePopupView = class extends ParentView {
    /**
     * 
     * @param {string} parentId 
     * @param {PopupViewController} popupViewController 
     */
    constructor(parentId, popupViewController) {
      super(parentId, PageIds.CLOSE_SKILL_TREE_POPUP);
      this.addView(new PopupViewToggle(this.elementId, this.elementId + "_skill", popupViewController, PageIds.SKILL_TREE_GRAPH, "Close Skill Tree"));
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      Page.createElement("div", parent, this.getElementId(), "popup-window-close-skill-tree");
      this.setInitialVisibility(false);
      super.initializeView();
    }
  };

  // src/view/popup/options/GameOptionsToggle.js
  var GameOptionsToggle = class extends View {
    /**
     * @abstract
     * @param {string} parentId
     * @param {string} elementId 
     * @param {string} title
     * @param {GameOptions} gameOptions
     */
    constructor(parentId, elementId, title, gameOptions) {
      super(parentId, elementId);
      this.title = title;
      this.gameOptions = gameOptions;
      this.mainElement = null;
      this.displayedEnabled = false;
    }
    /**
     * @override
     */
    initializeView() {
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("GameOptionsToggle.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      this.mainElement = Page.createElement("div", parent, id, "upgrade-button-outer");
      const row1 = Page.createElement("div", this.mainElement, null, "button-row-icon-text");
      const imgElement = Page.createElement("img", row1, null, "pick-upgrade-icon");
      imgElement.src = Images.pick;
      const titleDescriptionContainer = Page.createElement("div", row1, null, "pick-upgrade-title-description-container");
      const titleElement = Page.createElement("div", titleDescriptionContainer, null, "pick-upgrade-button-title-single-row");
      titleElement.innerHTML = this.title;
      const thisRef = this;
      this.mainElement.onclick = function() {
        thisRef.toggleEnabled();
      };
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const enabled = this.isEnabled();
      if (this.displayedEnabled === enabled) {
        return;
      }
      this.displayedEnabled = enabled;
      if (enabled) {
        this.mainElement.className = "popup-toggle-button-outer-open";
      } else {
        this.mainElement.className = "upgrade-button-outer";
      }
    }
    /**
     * @abstract
     * @param {boolean} enabled 
     */
    setEnabled(enabled) {
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isEnabled() {
      return false;
    }
    /**
     * @abstract
     */
    toggleEnabled() {
    }
  };

  // src/view/popup/options/CrewBrainGameOptionsToggle.js
  var CrewBrainGameOptionsToggle = class extends GameOptionsToggle {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {string} title
     * @param {GameOptions} gameOptions
     */
    constructor(parentId, elementId, title, gameOptions) {
      super(parentId, elementId, title, gameOptions);
    }
    /**
     * @abstract
     * @param {boolean} enabled 
     */
    setEnabled(enabled) {
      this.gameOptions.crewBrainDebugEnabled = enabled;
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isEnabled() {
      return this.gameOptions.crewBrainDebugEnabled;
    }
    /**
     * @override
     */
    toggleEnabled() {
      this.gameOptions.crewBrainDebugEnabled = !this.gameOptions.crewBrainDebugEnabled;
    }
  };

  // src/view/popup/options/DepthColumnGameOptionsToggle.js
  var DepthColumnGameOptionsToggle = class extends GameOptionsToggle {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {string} title
     * @param {GameOptions} gameOptions
     */
    constructor(parentId, elementId, title, gameOptions) {
      super(parentId, elementId, title, gameOptions);
    }
    /**
     * @abstract
     * @param {boolean} enabled 
     */
    setEnabled(enabled) {
      this.gameOptions.depthColumnRendered = enabled;
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isEnabled() {
      return this.gameOptions.depthColumnRendered;
    }
    /**
     * @override
     */
    toggleEnabled() {
      this.gameOptions.depthColumnRendered = !this.gameOptions.depthColumnRendered;
    }
  };

  // src/view/popup/options/DisplayFpsGameOptionsToggle.js
  var DisplayFpsGameOptionsToggle = class extends GameOptionsToggle {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {string} title
     * @param {GameOptions} gameOptions
     */
    constructor(parentId, elementId, title, gameOptions) {
      super(parentId, elementId, title, gameOptions);
    }
    /**
     * @abstract
     * @param {boolean} enabled 
     */
    setEnabled(enabled) {
      this.gameOptions.displayFps = enabled;
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isEnabled() {
      return this.gameOptions.displayFps;
    }
    /**
     * @override
     */
    toggleEnabled() {
      this.gameOptions.displayFps = !this.gameOptions.displayFps;
    }
  };

  // src/view/popup/options/EffectRenderingGameOptionsToggle.js
  var EffectRenderingGameOptionsToggle = class extends GameOptionsToggle {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {string} title
     * @param {GameOptions} gameOptions
     */
    constructor(parentId, elementId, title, gameOptions) {
      super(parentId, elementId, title, gameOptions);
    }
    /**
     * @abstract
     * @param {boolean} enabled 
     */
    setEnabled(enabled) {
      this.gameOptions.effectsRenderingEnabled = enabled;
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isEnabled() {
      return this.gameOptions.effectsRenderingEnabled;
    }
    /**
     * @override
     */
    toggleEnabled() {
      this.gameOptions.effectsRenderingEnabled = !this.gameOptions.effectsRenderingEnabled;
    }
  };

  // src/view/popup/options/FpsThrottleSettingView.js
  var FpsThrottleSettingView = class extends View {
    /**
     * @abstract
     * @param {string} parentId
     * @param {string} elementId 
     * @param {GameOptions} gameOptions
     */
    constructor(parentId, elementId, gameOptions) {
      super(parentId, elementId);
      this.gameOptions = gameOptions;
      this.mainElement = null;
      this.option15 = null;
      this.option30 = null;
      this.option60 = null;
      this.option120 = null;
      this.optionNone = null;
      this.displayedMaxFps = -1e3;
    }
    /**
     * @override
     */
    initializeView() {
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("FpsThrottleSettingView.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      this.mainElement = Page.createElement("div", parent, id, "settings-row-outer");
      const heading = Page.createElement("div", this.mainElement, null, null);
      heading.innerHTML = "FPS Throttle";
      const row1 = Page.createElement("div", this.mainElement, null, "settings-row-fps-throttle");
      this.option15 = Page.createElement("div", row1, "option15", "settings-row-toggle-button");
      this.option15.innerHTML = "15";
      this.option30 = Page.createElement("div", row1, "option30", "settings-row-toggle-button");
      this.option30.innerHTML = "30";
      this.option60 = Page.createElement("div", row1, "option60", "settings-row-toggle-button");
      this.option60.innerHTML = "60";
      this.option120 = Page.createElement("div", row1, "option120", "settings-row-toggle-button");
      this.option120.innerHTML = "120";
      this.optionNone = Page.createElement("div", row1, "optionNone", "settings-row-toggle-button");
      this.optionNone.innerHTML = "None";
      const thisRef = this;
      this.option15.onclick = function() {
        thisRef.gameOptions.maxFps = 16;
      };
      this.option30.onclick = function() {
        thisRef.gameOptions.maxFps = 32;
      };
      this.option60.onclick = function() {
        thisRef.gameOptions.maxFps = 64;
      };
      this.option120.onclick = function() {
        thisRef.gameOptions.maxFps = 130;
      };
      this.optionNone.onclick = function() {
        thisRef.gameOptions.maxFps = -1;
      };
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const maxFps = this.gameOptions.maxFps;
      if (this.displayedMaxFps !== maxFps) {
        this.displayedMaxFps = maxFps;
        this.option15.className = maxFps === 16 ? "settings-row-toggle-button-selected" : "settings-row-toggle-button";
        this.option30.className = maxFps === 32 ? "settings-row-toggle-button-selected" : "settings-row-toggle-button";
        this.option60.className = maxFps === 64 ? "settings-row-toggle-button-selected" : "settings-row-toggle-button";
        this.option120.className = maxFps === 130 ? "settings-row-toggle-button-selected" : "settings-row-toggle-button";
        this.optionNone.className = maxFps === -1 ? "settings-row-toggle-button-selected" : "settings-row-toggle-button";
      }
      super.updateViewContents();
    }
  };

  // src/view/popup/options/WireFrameGameOptionsToggle.js
  var WireFrameGameOptionsToggle = class extends GameOptionsToggle {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {string} title
     * @param {GameOptions} gameOptions
     */
    constructor(parentId, elementId, title, gameOptions) {
      super(parentId, elementId, title, gameOptions);
    }
    /**
     * @abstract
     * @param {boolean} enabled 
     */
    setEnabled(enabled) {
      this.gameOptions.wireframeModeEnabled = enabled;
    }
    /**
     * @abstract
     * @returns {boolean}
     */
    isEnabled() {
      return this.gameOptions.wireframeModeEnabled;
    }
    /**
     * @override
     */
    toggleEnabled() {
      this.gameOptions.wireframeModeEnabled = !this.gameOptions.wireframeModeEnabled;
    }
  };

  // src/view/popup/options/GameOptionsPopupView.js
  var GameOptionsPopupView = class extends ParentView {
    /**
     * @param {string} parentId 
     * @param {GameOptions} gameOptions
     */
    constructor(parentId, gameOptions) {
      super(parentId, PageIds.GAME_OPTIONS_POPUP);
      this.gameOptions = gameOptions;
      this.container = null;
      this.containerId = "gameOptionsContainer";
      this.addView(new CrewBrainGameOptionsToggle(this.containerId, this.containerId + "_brain", "Crew Brain Debug", gameOptions));
      this.addView(new DisplayFpsGameOptionsToggle(this.containerId, this.containerId + "_fps", "Display FPS", gameOptions));
      this.addView(new EffectRenderingGameOptionsToggle(this.containerId, this.containerId + "_fx", "Effect/Skill Rendering", gameOptions));
      this.addView(new DepthColumnGameOptionsToggle(this.containerId, this.containerId + "_depth", "Depth Column Rendered", gameOptions));
      this.addView(new WireFrameGameOptionsToggle(this.containerId, this.containerId + "_wire", "Wireframe Tiles", gameOptions));
      this.addView(new FpsThrottleSettingView(this.containerId, this.containerId + "_throttle", gameOptions));
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const popupElement = Page.createElement("div", parentElement, this.getElementId(), "popup-window-prestige");
      const container = Page.createElement("div", popupElement, null, null);
      const header = Page.createElement("div", container, null, "popup-window-header");
      header.innerHTML = "Settings";
      const thisRef = this;
      header.onclick = function() {
        thisRef.setViewVisible(false);
        return false;
      };
      const sectionBody = Page.createElement("div", container, null, "menu-section-body");
      this.container = Page.createElement("div", sectionBody, this.containerId, null);
      this.setInitialVisibility(false);
      super.initializeView();
    }
    // /**
    //  * @override
    //  */
    // updateViewContents() {
    //     super.updateViewContents();
    // }
  };

  // src/view/popup/OfflinePopupView.js
  var OfflinePopupView = class extends View {
    /**
     * @param {string} parentId 
     * @param {Totals} totals 
     */
    constructor(parentId, totals) {
      super(parentId, PageIds.OFFLINE_POPUP);
      this.totals = totals;
      this.container = null;
      this.offlineTimeInfo = null;
      this.prestigeEarnedInfo = null;
      this.goldEarnedInfo = null;
      this.oreEarnedInfo = null;
      this.rubyEarnedInfo = null;
      this.displayedPrestige = new BigNum(-10);
      this.displayedGold = new BigNum(-10);
      this.displayedOre = new BigNum(-10);
      this.displayedRuby = new BigNum(-10);
      this.displayedOfflineSeconds = 0;
      this.working = new BigNum(0);
      this.one = new BigNum(1);
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const popupElement = Page.createElement("div", parentElement, this.getElementId(), "popup-window-prestige");
      const container = Page.createElement("div", popupElement, null, null);
      const header = Page.createElement("div", container, null, "popup-window-header");
      header.innerHTML = "Offline Progress";
      const thisRef = this;
      header.onclick = function() {
        thisRef.totals.claimOfflineEarnings();
        thisRef.setViewVisible(false);
        return false;
      };
      const sectionBody = Page.createElement("div", container, null, "menu-section-body");
      this.container = Page.createElement("div", sectionBody, null, null);
      const prestigeInfo1 = Page.createElement("div", this.container, null, "offline-info");
      prestigeInfo1.innerHTML = "You have offline earnings!";
      this.offlineTimeInfo = Page.createElement("div", this.container, null, "offline-info");
      this.offlineTimeInfo.innerHTML = "";
      this.prestigeEarnedInfo = Page.createElement("div", this.container, null, "offline-info");
      this.prestigeEarnedInfo.innerHTML = "";
      this.goldEarnedInfo = Page.createElement("div", this.container, null, "offline-info");
      this.goldEarnedInfo.innerHTML = "";
      this.oreEarnedInfo = Page.createElement("div", this.container, null, "offline-info");
      this.oreEarnedInfo.innerHTML = "";
      this.rubyEarnedInfo = Page.createElement("div", this.container, null, "offline-info");
      this.rubyEarnedInfo.innerHTML = "";
      const buttonRow = Page.createElement("div", this.container, null, "save-popup-button-row");
      const claimButton = Page.createElement("div", buttonRow, "prestigeButton", "game-button prestige-button");
      claimButton.style.marginTop = "10px";
      claimButton.innerHTML = "Claim Earnings";
      claimButton.onclick = function() {
        thisRef.totals.claimOfflineEarnings();
        thisRef.setViewVisible(false);
        return false;
      };
      this.setInitialVisibility(false);
      super.initializeView();
    }
    /**
     * @private
     * @returns {string}
     */
    getPrestigeRate() {
      return this.getRate(this.totals.prestigePerTurn);
    }
    /**
     * @private
     * @returns {string}
     */
    getGoldRate() {
      return this.getRate(this.totals.goldPerTurn);
    }
    /**
     * @private
     * @returns {string}
     */
    getOreRate() {
      return this.getRate(this.totals.orePerTurn);
    }
    /**
     * @private
     * @returns {string}
     */
    getRubyRate() {
      return this.getRate(this.totals.rubyPerTurn);
    }
    /**
     * @private
     * @param {BigNum} amountPerTurn 
     * @returns {string}
     */
    getRate(amountPerTurn) {
      this.working.copy(amountPerTurn);
      this.working.mulNumber(Settings.time.turnsPerSecond);
      if (this.working.lessThan(this.one)) {
        const value2 = this.working.toNumber();
        return value2.toFixed(4) + " / second";
      } else {
        return NumberFormatter.formatBigNum(this.working) + " / second";
      }
    }
    /**
     * @override
     */
    updateViewContents() {
      const prestige = this.totals.offlinePrestige;
      const gold = this.totals.offlineGold;
      const ore = this.totals.offlineOre;
      const ruby = this.totals.offlineRuby;
      const offlineSeconds = this.totals.countedOfflineSeconds;
      if (this.displayedOfflineSeconds !== offlineSeconds) {
        this.displayedOfflineSeconds = offlineSeconds;
        this.offlineTimeInfo.innerHTML = "Offline time: " + TimeFormatter.formatElapsedTime(offlineSeconds * 1e3);
      }
      if (!this.displayedPrestige.equals(prestige)) {
        this.displayedPrestige.copy(prestige);
        this.prestigeEarnedInfo.innerHTML = "Prestige earned: " + NumberFormatter.formatBigNum(prestige) + " (" + this.getPrestigeRate() + ")";
      }
      if (!this.displayedGold.equals(gold)) {
        this.displayedGold.copy(gold);
        this.goldEarnedInfo.innerHTML = "Gold earned: " + NumberFormatter.formatBigNum(gold) + " (" + this.getGoldRate() + ")";
      }
      if (!this.displayedOre.equals(ore)) {
        this.displayedOre.copy(ore);
        this.oreEarnedInfo.innerHTML = "Ore earned: " + NumberFormatter.formatBigNum(ore) + " (" + this.getOreRate() + ")";
      }
      if (!this.displayedRuby.equals(ruby)) {
        this.displayedRuby.copy(ruby);
        this.rubyEarnedInfo.innerHTML = "Ruby earned: " + NumberFormatter.formatBigNum(ruby) + " (" + this.getRubyRate() + ")";
      }
    }
  };

  // src/view/popup/PerformanceMetricsRow.js
  var PerformanceMetricsRow = class extends View {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {PerformanceTrack} performanceTrack
     */
    constructor(parentId, elementId, performanceTrack) {
      super(parentId, elementId);
      this.performanceTrack = performanceTrack;
      this.countSpan = null;
      this.averageSpan = null;
      this.totalSpan = null;
      this.displayedCount = -1;
      this.displayedAverage = -1;
      this.displayedTotal = -1;
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const container = Page.createElement("div", parentElement, null, "performance-row");
      const labelSpan = Page.createElement("span", container, null, null);
      labelSpan.innerHTML = this.performanceTrack.subject;
      this.countSpan = Page.createElement("span", container, null, "performance-value");
      this.countSpan.innerHTML = "";
      this.averageSpan = Page.createElement("span", container, null, "performance-value");
      this.averageSpan.innerHTML = "";
      this.totalSpan = Page.createElement("span", container, null, "performance-value");
      this.totalSpan.innerHTML = "";
      this.setInitialVisibility(true);
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const count = this.performanceTrack.count;
      const elapsed = this.performanceTrack.elapsed;
      const average = count > 0 ? elapsed / count : 0;
      if (this.displayedCount != count) {
        this.displayedCount = count;
        this.countSpan.innerHTML = NumberFormatter.formatNumber(count);
      }
      if (this.displayedAverage != average) {
        this.displayedAverage = average;
        this.averageSpan.innerHTML = NumberFormatter.formatNumber(average);
      }
      if (this.displayedTotal != elapsed) {
        this.displayedTotal != elapsed;
        this.totalSpan.innerHTML = NumberFormatter.formatNumber(elapsed);
      }
      super.updateViewContents();
    }
  };

  // src/view/popup/PerformanceMetricsPopupView.js
  var PerformanceMetricsPopupView = class extends ParentView {
    /**
     * @param {string} parentId 
     */
    constructor(parentId) {
      super(parentId, PageIds.PERFORMANCE_POPUP);
      this.container = null;
      this.contentElement = null;
      this.displayedContent = null;
      this.prevTimestamp = Date.now() - 1e3;
      this.currentKeys = {};
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const popupElement = Page.createElement("div", parentElement, this.getElementId(), "popup-window-prestige");
      const container = Page.createElement("div", popupElement, null, null);
      const header = Page.createElement("div", container, null, "popup-window-header");
      header.innerHTML = "Performance Info";
      const thisRef = this;
      header.onclick = function() {
        thisRef.setViewVisible(false);
        return false;
      };
      const sectionBody = Page.createElement("div", container, null, "menu-section-body");
      this.container = Page.createElement("div", sectionBody, null, null);
      this.contentElement = Page.createElement("div", this.container, "performanceContent", "offline-info");
      const headerRow = Page.createElement("div", this.contentElement, null, "performance-row");
      const labelSpan = Page.createElement("span", headerRow, null, null);
      labelSpan.innerHTML = "Activity";
      const countSpan = Page.createElement("span", headerRow, null, "performance-value");
      countSpan.innerHTML = "Count";
      const averageSpan = Page.createElement("span", headerRow, null, "performance-value");
      averageSpan.innerHTML = "Ave Millis";
      const totalSpan = Page.createElement("span", headerRow, null, "performance-value");
      totalSpan.innerHTML = "Tot Millis";
      const buttonRow = Page.createElement("div", this.container, null, "save-popup-button-row");
      const resetButton = Page.createElement("div", buttonRow, "resetButton", "game-button prestige-button");
      resetButton.style.marginTop = "10px";
      resetButton.innerHTML = "Reset";
      resetButton.onclick = function() {
        PerformanceMetrics.reset();
        this.displayedContent = null;
        return false;
      };
      this.setInitialVisibility(false);
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const timestamp = Date.now();
      const elapsed = timestamp - this.prevTimestamp;
      if (elapsed > 1e3) {
        this.prevTimestamp = timestamp;
        const keys = PerformanceMetrics.getKeys();
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (!this.currentKeys[key]) {
            this.currentKeys[key] = true;
            const performanceTrack = PerformanceMetrics.getPerformanceTrack(key);
            if (performanceTrack) {
              const metricsRowView = new PerformanceMetricsRow("performanceContent", "performanceContent_" + i, performanceTrack);
              this.addView(metricsRowView);
              metricsRowView.initializeView();
            } else {
              console.log("PerformanceMetricsPopupView.updateViewContents() failed to find: " + key);
            }
          }
        }
      }
      super.updateViewContents();
    }
  };

  // src/view/popup/PrestigePopupView.js
  var PrestigePopupView = class extends View {
    /**
     * 
     * @param {string} parentId 
     * @param {Totals} totals 
     * @param {GameStateControl} gameStateControl
     */
    constructor(parentId, totals, gameStateControl) {
      super(parentId, PageIds.PRESTIGE_POPUP);
      this.totals = totals;
      this.gameStateControl = gameStateControl;
      this.prestigeContainer = null;
      this.confirmContainer = null;
      this.prestigeEarnedInfo = null;
      this.prestigeEarnedInfo2 = null;
      this.displayedPrestige = new BigNum(0);
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const prestigePopup = Page.createElement("div", parentElement, this.getElementId(), "popup-window-prestige");
      const container = Page.createElement("div", prestigePopup, null, null);
      const header = Page.createElement("div", container, null, "popup-window-header");
      header.innerHTML = "Prestige";
      const thisRef = this;
      header.onclick = function() {
        thisRef.setViewVisible(false);
        return false;
      };
      const sectionBody = Page.createElement("div", container, null, "menu-section-body");
      this.prestigeContainer = Page.createElement("div", sectionBody, null, null);
      this.confirmContainer = Page.createElement("div", sectionBody, null, null);
      this.confirmContainer.style.display = "none";
      const prestigeInfo1 = Page.createElement("div", this.prestigeContainer, null, "prestige-info");
      prestigeInfo1.innerHTML = "Prestige the game and start over at the surface.";
      this.prestigeEarnedInfo = Page.createElement("div", this.prestigeContainer, null, "prestige-info");
      this.prestigeEarnedInfo.innerHTML = this.getEarnedPrestigeText();
      this.displayedPrestige.copy(this.totals.unclaimedPrestige);
      const prestigeInfo2 = Page.createElement("div", this.prestigeContainer, null, "prestige-info");
      prestigeInfo2.innerHTML = "You earn 1 prestige point per terrain layer cleared.";
      const prestigeInfo3 = Page.createElement("div", this.prestigeContainer, null, "prestige-info");
      prestigeInfo3.innerHTML = "Spend your points on skills in the skill tree.";
      const prestigeButtonRow = Page.createElement("div", this.prestigeContainer, null, "save-popup-button-row");
      const prestigeButton1 = Page.createElement("div", prestigeButtonRow, "prestigeButton", "game-button prestige-button");
      prestigeButton1.style.marginTop = "10px";
      prestigeButton1.innerHTML = "Prestige Game";
      prestigeButton1.onclick = function() {
        thisRef.displayConfirmation();
        return false;
      };
      const confirmInfo1 = Page.createElement("div", this.confirmContainer, null, "prestige-info");
      confirmInfo1.innerHTML = "Prestige Confirmation";
      const confirmInfo2 = Page.createElement("div", this.confirmContainer, null, "prestige-info");
      confirmInfo2.innerHTML = "If you prestige you will be placed back on the surface.";
      const confirmInfo3 = Page.createElement("div", this.confirmContainer, null, "prestige-info");
      confirmInfo3.innerHTML = "Your ore and mine power will be reset.";
      const confirmInfo4 = Page.createElement("div", this.confirmContainer, null, "prestige-info");
      confirmInfo4.innerHTML = "Your can spend points to expand your crew and learn skills.";
      this.prestigeEarnedInfo2 = Page.createElement("div", this.confirmContainer, null, "prestige-info");
      this.prestigeEarnedInfo2.innerHTML = this.getEarnedPrestigeText();
      const confirmButtonRow = Page.createElement("div", this.confirmContainer, null, "save-popup-button-row");
      const cancelButton = Page.createElement("div", confirmButtonRow, "cancelButton", "game-button prestige-button");
      cancelButton.style.marginTop = "10px";
      cancelButton.innerHTML = "Cancel";
      cancelButton.onclick = function() {
        thisRef.onPrestigeCancel();
        return false;
      };
      const prestigeButton2 = Page.createElement("div", confirmButtonRow, "realPrestigeButton", "game-button prestige-button");
      prestigeButton2.style.marginTop = "10px";
      prestigeButton2.innerHTML = "Prestige Game";
      prestigeButton2.onclick = function() {
        thisRef.gameStateControl.prestigeGame();
        return false;
      };
      this.setInitialVisibility(false);
      super.initializeView();
    }
    /**
     * @private
     * @returns {string}
     */
    getEarnedPrestigeText() {
      return "Prestige points earned: " + NumberFormatter.formatBigNum(this.totals.unclaimedPrestige);
    }
    /**
     */
    displayConfirmation() {
      Page.hideElement(this.prestigeContainer);
      Page.showElement(this.confirmContainer);
    }
    onPrestigeCancel() {
      Page.hideElement(this.confirmContainer);
      Page.showElement(this.prestigeContainer);
    }
    /**
     * @override
     */
    updateViewContents() {
      const prestige = this.totals.unclaimedPrestige;
      if (!this.displayedPrestige.equals(prestige)) {
        this.displayedPrestige.copy(prestige);
        const earnedPrestigeText = this.getEarnedPrestigeText();
        this.prestigeEarnedInfo.innerHTML = earnedPrestigeText;
        this.prestigeEarnedInfo2.innerHTML = earnedPrestigeText;
      }
    }
  };

  // src/view/popup/SavePopupView.js
  var SavePopupView = class extends View {
    /**
     * @param {string} parentId
     * @param {GameStateControl} gameStateControl
     */
    constructor(parentId, gameStateControl) {
      super(parentId, PageIds.SAVE_POPUP);
      this.gameStateControl = gameStateControl;
      this.setCurrentlyVisible(true);
      this.setViewVisible(false);
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const savePopupElement = Page.createElement("div", parentElement, this.elementId, "popup-window-save");
      const saveContentsElement = Page.createElement("div", savePopupElement, null, null);
      const saveControlsHeader = Page.createElement("div", saveContentsElement, null, "popup-window-header");
      saveControlsHeader.innerHTML = "Save Controls";
      saveControlsHeader.onclick = function() {
        thisRef.setViewVisible(false);
        return false;
      };
      const menuSectionBody = Page.createElement("div", saveContentsElement, null, "menu-section-body");
      const saveButtonsContainer = Page.createElement("div", menuSectionBody, "saveButtonsContainer", "save-popup-buttons-container");
      const exportSaveButton = Page.createElement("div", saveButtonsContainer, "exportSaveButton", "game-button");
      exportSaveButton.innerHTML = "Export Save";
      const importSaveButton = Page.createElement("div", saveButtonsContainer, "importSaveButton", "game-button");
      importSaveButton.innerHTML = "Import Save";
      const resetGameButton = Page.createElement("div", saveButtonsContainer, "resetGameButton", "game-button");
      resetGameButton.innerHTML = "Reset Game";
      const deleteGameButton = Page.createElement("div", saveButtonsContainer, "deleteSaveButton", "game-button");
      deleteGameButton.innerHTML = "Delete Save";
      const importContainer = Page.createElement("div", menuSectionBody, "importContainer", "save-popup-content-container");
      importContainer.style.display = "none";
      const importTextAreaContainer = Page.createElement("div", importContainer, null, null);
      const importTextArea = Page.createElement("textarea", importTextAreaContainer, "importTextArea", "import-export-textarea");
      importTextArea.title = "Paste exported save here and click import.";
      const importButtonRow = Page.createElement("div", importTextAreaContainer, null, "save-popup-button-row");
      const importButtonActual = Page.createElement("div", importButtonRow, "importButtonActual", "game-button save-button");
      importButtonActual.innerHTML = "Import";
      const closeImportButton = Page.createElement("div", importButtonRow, "closeImportButton", "game-button save-button");
      closeImportButton.innerHTML = "Close";
      const exportContainer = Page.createElement("div", menuSectionBody, "exportContainer", "save-popup-content-container");
      exportContainer.style.display = "none";
      const exportTextAreaContainer = Page.createElement("div", exportContainer, null, null);
      const exportTextArea = Page.createElement("textarea", exportTextAreaContainer, "exportTextArea", "import-export-textarea");
      const exportButtonRow = Page.createElement("div", exportContainer, null, "save-popup-button-row");
      const copyToClipboardButton = Page.createElement("div", exportButtonRow, "copyToClipboardButton", "game-button save-button");
      copyToClipboardButton.style.width = "130px";
      copyToClipboardButton.innerHTML = "Copy to Clipboard";
      const closeExportButton = Page.createElement("div", exportButtonRow, "closeExportButton", "game-button save-button");
      closeExportButton.innerHTML = "Close";
      const resetConfirmationContainer = Page.createElement("div", menuSectionBody, "resetConfirmationContainer", "save-popup-content-container");
      resetConfirmationContainer.style.display = "none";
      const resetConfirmationText = Page.createElement("div", resetConfirmationContainer, null, null);
      resetConfirmationText.style.padding = "10px";
      resetConfirmationText.innerHTML = "Are you sure you want to reset? You will not lose your victory count.";
      const resetButtonRow = Page.createElement("div", resetConfirmationContainer, null, "save-popup-button-row");
      const resetButtonActual = Page.createElement("div", resetButtonRow, "resetButtonActual", "game-button save-button");
      resetButtonActual.innerHTML = "Reset";
      const closeResetButton = Page.createElement("div", resetButtonRow, "closeResetButton", "game-button save-button");
      closeResetButton.innerHTML = "Close";
      const deleteConfirmationContainer = Page.createElement("div", menuSectionBody, "deleteConfirmationContainer", "save-popup-content-container");
      deleteConfirmationContainer.style.display = "none";
      const deleteConfirmationText = Page.createElement("div", deleteConfirmationContainer, null, null);
      deleteConfirmationText.style.padding = "10px";
      deleteConfirmationText.innerHTML = "Are you sure you want to delete? You will lose everything and start over.";
      const deleteButtonRow = Page.createElement("div", deleteConfirmationContainer, null, "save-popup-button-row");
      const deleteButtonActual = Page.createElement("div", deleteButtonRow, "deleteButtonActual", "game-button save-button");
      deleteButtonActual.innerHTML = "Delete";
      const closeDeleteButton = Page.createElement("div", deleteButtonRow, "closeDeleteButton", "game-button save-button");
      closeDeleteButton.innerHTML = "Close";
      this.setInitialVisibility(false);
      super.initializeView();
      const thisRef = this;
      this.saveTimeDiv = Page.getElement("lastSaveTime");
      this.displayedSaveTime = -1;
      exportSaveButton.onclick = function() {
        thisRef.displayExportSave();
        return false;
      };
      importSaveButton.onclick = function() {
        thisRef.displayImportSave();
        return false;
      };
      closeImportButton.onclick = function() {
        thisRef.closeImportContainer();
        return false;
      };
      importButtonActual.onclick = function() {
        thisRef.handleImportSave();
        return false;
      };
      closeExportButton.onclick = function() {
        thisRef.closeExportContainer();
        return false;
      };
      copyToClipboardButton.onclick = function() {
        exportTextArea.select();
        navigator.clipboard.writeText(exportTextArea.value).then(
          () => {
            console.log("clipboard successfully set");
          },
          () => {
            console.error("clipboard write failed");
          }
        );
      };
      resetGameButton.onclick = function() {
        thisRef.displayResetConfirmation();
        return false;
      };
      deleteGameButton.onclick = function() {
        thisRef.displayDeleteConfirmation();
        return false;
      };
      resetButtonActual.onclick = function() {
        thisRef.handleGameReset();
        return false;
      };
      deleteButtonActual.onclick = function() {
        thisRef.handleGameDelete();
        return false;
      };
      closeResetButton.onclick = function() {
        thisRef.closeResetConfirmation();
        return false;
      };
      closeDeleteButton.onclick = function() {
        thisRef.closeDeleteConfirmation();
        return false;
      };
    }
    /**
     */
    displayExportSave() {
      Page.hideElementId("saveButtonsContainer");
      Page.showElementId("exportContainer");
      var exportTextArea = Page.getElement("exportTextArea");
      const state = this.gameStateControl.getState();
      exportTextArea.value = state.saveManager.getSaveStateForExport(state);
    }
    /**
     */
    displayImportSave() {
      Page.hideElementId("saveButtonsContainer");
      Page.showElementId("importContainer");
      Page.showElementId("importButtonActual");
    }
    /**
     */
    closeImportContainer() {
      var importTextArea = Page.getElement("importTextArea");
      importTextArea.value = "";
      Page.hideElementId("importContainer");
      Page.showElementIdWithValue("saveButtonsContainer", "grid");
    }
    /**
     */
    closeExportContainer() {
      var exportTextArea = Page.getElement("exportTextArea");
      exportTextArea.value = "";
      Page.hideElementId("exportContainer");
      Page.showElementIdWithValue("saveButtonsContainer", "grid");
    }
    /**
     */
    handleImportSave() {
      console.log("SavePopupView.handleImportSave()");
      const saveStateText = Page.getElement("importTextArea").value;
      this.gameStateControl.importSave(saveStateText);
    }
    /**
     */
    handleGameReset() {
      this.gameStateControl.resetGame();
    }
    /**
     */
    handleGameDelete() {
      this.gameStateControl.deleteGame();
    }
    /**
     */
    displayResetConfirmation() {
      Page.hideElementId("saveButtonsContainer");
      Page.showElementId("resetConfirmationContainer");
    }
    /**
     */
    displayDeleteConfirmation() {
      Page.hideElementId("saveButtonsContainer");
      Page.showElementId("deleteConfirmationContainer");
    }
    /**
     */
    closeResetConfirmation() {
      Page.hideElementId("resetConfirmationContainer");
      Page.showElementIdWithValue("saveButtonsContainer", "grid");
    }
    /**
     */
    closeDeleteConfirmation() {
      Page.hideElementId("deleteConfirmationContainer");
      Page.showElementIdWithValue("saveButtonsContainer", "grid");
    }
  };

  // src/view/popup/stats/StatisticsView.js
  var StatisticsView = class extends View {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {Statistics} statistics
     * @param {string} headerText
     */
    constructor(parentId, elementId, statistics, headerText) {
      super(parentId, elementId);
      this.statistics = statistics;
      this.headerText = headerText;
      this.displayedSeconds = -1;
      this.displayedTotalOre = new BigNum(-1);
      this.displayedTotalGold = new BigNum(-1);
      this.displayedTotalRuby = new BigNum(-1);
      this.displayedTotalPrestigePoints = new BigNum(-1);
      this.displayedUpgradeOre = new BigNum(-1);
      this.displayedMaxDepth = -1;
      this.displayedTilesMined = new BigNum(-1);
      this.displayedTilesMinedCommon = new BigNum(-1);
      this.displayedTilesMinedOre = new BigNum(-1);
      this.displayedTilesMinedGold = new BigNum(-1);
      this.displayedTilesMinedRuby = new BigNum(-1);
      this.displayedTilesMinedUpgrade = new BigNum(-1);
      this.displayedTilesMinedLaser = new BigNum(-1);
      this.displayedTilesMinedDrill = new BigNum(-1);
      this.displayedTilesMinedOrbit = new BigNum(-1);
      this.displayedTilesMinedMissile = new BigNum(-1);
      this.totalTurnsElement = null;
      this.totalOreElement = null;
      this.totalGoldElement = null;
      this.totalRubyElement = null;
      this.totalPrestigePointsElement = null;
      this.upgradeOreElement = null;
      this.maxDepthElement = null;
      this.tilesMinedElement = null;
      this.tilesMinedCommonElement = null;
      this.tilesMinedOreElement = null;
      this.tilesMinedGoldElement = null;
      this.tilesMinedRubyElement = null;
      this.tilesMinedUpgradeElement = null;
      this.tilesMinedLaserElement = null;
      this.tilesMinedDrillElement = null;
      this.tilesMinedOrbitElement = null;
      this.tilesMinedMissileElement = null;
      this.setViewVisible(false);
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const statsContainer = Page.createElement("div", parentElement, null, "stats-view");
      const statsHeader = Page.createElement("div", statsContainer, null, "stats-header");
      statsHeader.innerHTML = this.headerText;
      const sectionBody = Page.createElement("div", statsContainer, null, "menu-section-body");
      this.totalTurnsElement = this.createStatsSection(sectionBody, "Time", "Time", false);
      this.totalOreElement = this.createStatsSection(sectionBody, "Total Ore", "Ore", false);
      this.totalGoldElement = this.createStatsSection(sectionBody, "Total Gold", "Gold", false);
      this.totalRubyElement = this.createStatsSection(sectionBody, "Total Ruby", "Ruby", false);
      this.totalPrestigePointsElement = this.createStatsSection(sectionBody, "Total Prestige", "Points", false);
      this.maxDepthElement = this.createStatsSection(sectionBody, "Max Depth", "Blocks", false);
      this.upgradeOreElement = this.createStatsSection(sectionBody, "Upgrade Ore", "Ore", false);
      this.tilesMinedElement = this.createStatsSection(sectionBody, "Type: Any", "Blocks", true);
      this.tilesMinedCommonElement = this.createStatsSection(sectionBody, "Type: Common", "Blocks", false);
      this.tilesMinedOreElement = this.createStatsSection(sectionBody, "Type: Ore", "Blocks", false);
      this.tilesMinedGoldElement = this.createStatsSection(sectionBody, "Type: Gold", "Blocks", false);
      this.tilesMinedRubyElement = this.createStatsSection(sectionBody, "Type: Ruby", "Blocks", false);
      this.tilesMinedUpgradeElement = this.createStatsSection(sectionBody, "Type: Upgrade", "Blocks", false);
      this.tilesMinedLaserElement = this.createStatsSection(sectionBody, "Skill: Laser", "Blocks", true);
      this.tilesMinedDrillElement = this.createStatsSection(sectionBody, "Skill: Drill", "Blocks", false);
      this.tilesMinedOrbitElement = this.createStatsSection(sectionBody, "Skill: Orbit", "Blocks", false);
      this.tilesMinedMissileElement = this.createStatsSection(sectionBody, "Skill: Missile", "Blocks", false);
      this.setInitialVisibility(true);
      super.initializeView();
    }
    /**
     * @private
     * @param {HTMLElement} parent 
     * @param {string} label
     * @param {string} unit
     * @param {boolean} newSection
     * @returns {HTMLElement}
     */
    createStatsSection(parent, label, unit, newSection) {
      const statsSection = Page.createElement("div", parent, null, "numbers-section-row");
      if (newSection) {
        statsSection.style.marginTop = "10px";
      }
      const labelElement = Page.createElement("div", statsSection, null, "numbers-section-label");
      labelElement.innerHTML = label;
      const unitElement = Page.createElement("div", statsSection, null, "numbers-section-unit");
      unitElement.innerHTML = unit;
      return Page.createElement("div", statsSection, null, "numbers-section-value");
    }
    /**
     * @override
     */
    updateViewContents() {
      const seconds = this.statistics.totalTurns * Settings.time.secondsPerTurn | 0;
      if (this.displayedSeconds !== seconds) {
        this.displayedSeconds = seconds;
        this.totalTurnsElement.innerHTML = TimeFormatter.formatElapsedTime(seconds * 1e3);
      }
      const totalOre = this.statistics.totalOre;
      if (!this.displayedTotalOre.equals(totalOre)) {
        this.displayedTotalOre.copy(totalOre);
        this.totalOreElement.innerHTML = NumberFormatter.formatBigNum(totalOre);
      }
      const totalGold = this.statistics.totalGold;
      if (!this.displayedTotalGold.equals(totalGold)) {
        this.displayedTotalGold.copy(totalGold);
        this.totalGoldElement.innerHTML = NumberFormatter.formatBigNum(totalGold);
      }
      const totalRuby = this.statistics.totalRuby;
      if (!this.displayedTotalRuby.equals(totalRuby)) {
        this.displayedTotalRuby.copy(totalRuby);
        this.totalRubyElement.innerHTML = NumberFormatter.formatBigNum(totalRuby);
      }
      const totalPrestigePoints = this.statistics.totalPrestigePoints;
      if (!this.displayedTotalPrestigePoints.equals(totalPrestigePoints)) {
        this.displayedTotalPrestigePoints.compare(totalPrestigePoints);
        this.totalPrestigePointsElement.innerHTML = NumberFormatter.formatBigNum(totalPrestigePoints);
      }
      const upgradeOre = this.statistics.upgradeOre;
      if (!this.displayedUpgradeOre.equals(upgradeOre)) {
        this.displayedUpgradeOre.copy(upgradeOre);
        this.upgradeOreElement.innerHTML = NumberFormatter.formatBigNum(upgradeOre);
      }
      const maxDepth = this.statistics.maxDepth;
      if (this.displayedMaxDepth !== maxDepth) {
        this.displayedMaxDepth = maxDepth;
        this.maxDepthElement.innerHTML = NumberFormatter.formatNumber(maxDepth);
      }
      const tilesMined = this.statistics.tilesMined;
      if (!this.displayedTilesMined.equals(tilesMined)) {
        this.displayedTilesMined.copy(tilesMined);
        this.tilesMinedElement.innerHTML = NumberFormatter.formatBigNum(tilesMined);
      }
      const tilesMinedCommon = this.statistics.tilesMinedCommon;
      if (!this.displayedTilesMinedCommon.equals(tilesMinedCommon)) {
        this.displayedTilesMinedCommon.copy(tilesMinedCommon);
        this.tilesMinedCommonElement.innerHTML = NumberFormatter.formatBigNum(tilesMinedCommon);
      }
      const tilesMinedOre = this.statistics.tilesMinedOre;
      if (!this.displayedTilesMinedOre.equals(tilesMinedOre)) {
        this.displayedTilesMinedOre.copy(tilesMinedOre);
        this.tilesMinedOreElement.innerHTML = NumberFormatter.formatBigNum(tilesMinedOre);
      }
      const tilesMinedGold = this.statistics.tilesMinedGold;
      if (!this.displayedTilesMinedGold.equals(tilesMinedGold)) {
        this.displayedTilesMinedGold.copy(tilesMinedGold);
        this.tilesMinedGoldElement.innerHTML = NumberFormatter.formatBigNum(tilesMinedGold);
      }
      const tilesMinedRuby = this.statistics.tilesMinedRuby;
      if (!this.displayedTilesMinedRuby.equals(tilesMinedRuby)) {
        this.displayedTilesMinedRuby.copy(tilesMinedRuby);
        this.tilesMinedRubyElement.innerHTML = NumberFormatter.formatBigNum(tilesMinedRuby);
      }
      const tilesMinedUpgrade = this.statistics.tilesMinedUpgrade;
      if (!this.displayedTilesMinedUpgrade.equals(tilesMinedUpgrade)) {
        this.displayedTilesMinedUpgrade.copy(tilesMinedUpgrade);
        this.tilesMinedUpgradeElement.innerHTML = NumberFormatter.formatBigNum(tilesMinedUpgrade);
      }
      const tilesMinedLaser = this.statistics.tilesMinedLaser;
      if (!this.displayedTilesMinedLaser.equals(tilesMinedLaser)) {
        this.displayedTilesMinedLaser.copy(tilesMinedLaser);
        this.tilesMinedLaserElement.innerHTML = NumberFormatter.formatBigNum(tilesMinedLaser);
      }
      const tilesMinedDrill = this.statistics.tilesMinedDrill;
      if (!this.displayedTilesMinedDrill.equals(tilesMinedDrill)) {
        this.displayedTilesMinedDrill.copy(tilesMinedDrill);
        this.tilesMinedDrillElement.innerHTML = NumberFormatter.formatBigNum(tilesMinedDrill);
      }
      const tilesMinedOrbit = this.statistics.tilesMinedOrbit;
      if (!this.displayedTilesMinedOrbit.equals(tilesMinedOrbit)) {
        this.displayedTilesMinedOrbit.copy(tilesMinedOrbit);
        this.tilesMinedOrbitElement.innerHTML = NumberFormatter.formatBigNum(tilesMinedOrbit);
      }
      const tilesMinedMissile = this.statistics.tilesMinedMissile;
      if (!this.displayedTilesMinedMissile.equals(tilesMinedMissile)) {
        this.displayedTilesMinedMissile.copy(tilesMinedMissile);
        this.tilesMinedMissileElement.innerHTML = NumberFormatter.formatBigNum(tilesMinedMissile);
      }
    }
  };

  // src/view/popup/stats/StatisticsContainerView.js
  var StatisticsContainerView = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {Statistics} runStatistics
     * @param {Statistics} globalStatistics
     */
    constructor(parentId, runStatistics, globalStatistics) {
      super(parentId, parentId + "_container");
      const id = this.getElementId();
      this.addView(new StatisticsView(id, id + "_run", runStatistics, "Current Run Statistics"));
      this.addView(new StatisticsView(id, id + "_global", globalStatistics, "Cumulative Statistics"));
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "stats-container");
      this.setInitialVisibility(true);
      super.initializeView();
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "grid";
    }
  };

  // src/view/popup/stats/StatisticsPopupView.js
  var StatisticsPopupView = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {Statistics} runStatistics
     * @param {Statistics} globalStatistics
     */
    constructor(parentId, runStatistics, globalStatistics) {
      super(parentId, PageIds.STATISTICS_POPUP);
      this.addView(new StatisticsContainerView(this.getElementId(), runStatistics, globalStatistics));
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const statisticsPopup = Page.createElement("div", parentElement, this.getElementId(), "popup-window-statistics");
      const statsHeader = Page.createElement("div", statisticsPopup, null, "popup-window-header");
      statsHeader.innerHTML = "Statistics";
      const thisRef = this;
      statsHeader.onclick = function() {
        thisRef.setViewVisible(false);
        return false;
      };
      this.setInitialVisibility(false);
      super.initializeView();
    }
  };

  // src/view/popup/PopupContainer.js
  var PopupContainer = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {Statistics} runStatistics
     * @param {Statistics} globalStatistics
     * @param {Totals} totals
     * @param {GameOptions} gameOptions
     * @param {GameStateControl} gameStateControl
     * @param {PopupViewController} popupViewController
     */
    constructor(parentId, elementId, runStatistics, globalStatistics, totals, gameOptions, gameStateControl, popupViewController) {
      super(parentId, elementId);
      this.totals = totals;
      this.popupViewController = popupViewController;
      const statisticsPopupView = new StatisticsPopupView(elementId, runStatistics, globalStatistics);
      const savePopupView = new SavePopupView(elementId, gameStateControl);
      const prestigePopupView = new PrestigePopupView(elementId, totals, gameStateControl);
      const closeSkillTreeView = new CloseSkillTreePopupView(elementId, popupViewController);
      const offlinePopupView = new OfflinePopupView(elementId, totals);
      const gameOptionsView = new GameOptionsPopupView(elementId, gameOptions);
      const performanceView = new PerformanceMetricsPopupView(elementId);
      popupViewController.addPopupView(statisticsPopupView);
      popupViewController.addPopupView(savePopupView);
      popupViewController.addPopupView(prestigePopupView);
      popupViewController.addPopupView(closeSkillTreeView);
      popupViewController.addPopupView(offlinePopupView);
      popupViewController.addPopupView(gameOptionsView);
      popupViewController.addPopupView(performanceView);
      this.addView(statisticsPopupView);
      this.addView(savePopupView);
      this.addView(prestigePopupView);
      this.addView(closeSkillTreeView);
      this.addView(offlinePopupView);
      this.addView(gameOptionsView);
      this.addView(performanceView);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "popup-container");
      super.initializeView();
    }
    /**
     * @override
     */
    updateView() {
      if (this.totals.countedOfflineSeconds > 0 && !this.popupViewController.isPopupVisible(PageIds.OFFLINE_POPUP)) {
        this.popupViewController.setPopupVisible(PageIds.OFFLINE_POPUP);
      }
      super.updateView();
    }
  };

  // src/view/common/HeaderView.js
  var HeaderView = class extends View {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {string} headerText 
     */
    constructor(parentId, elementId, headerText) {
      super(parentId, elementId);
      this.headerText = headerText;
      this.headerElement = null;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("HeaderView.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      this.headerElement = Page.createElement("div", parent, this.elementId, "header-panel");
      this.headerElement.innerHTML = this.headerText;
      super.initializeView();
    }
    // /**
    //  * @override
    //  */
    // updateViewContents() {
    // }
  };

  // src/view/common/AutomationView.js
  var AutomationView = class extends View {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {string} headerText 
     * @param {BaseAutomation} automation
     */
    constructor(parentId, elementId, headerText, automation) {
      super(parentId, elementId);
      this.headerText = headerText;
      this.automation = automation;
      this.mainElement = null;
      this.activeProgressElement = null;
      this.titleElement = null;
      this.descriptionElement = null;
      this.displayedActive = automation.active;
      this.displayedPercent = -1;
      this.setInitialVisibility(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("AutomationView.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      const mainStyleClass = this.automation.active ? "automation-button-outer-active" : "automation-button-outer-not-active";
      this.mainElement = Page.createElement("div", parent, this.elementId, mainStyleClass);
      this.activeProgressElement = Page.createElement("div", this.mainElement, null, this.getProgressElementClassName());
      const bodyElement = Page.createElement("div", this.mainElement, null, "active-skill-button-body");
      const iconElement = Page.createElement("div", bodyElement, null, "icon-container");
      const titleDescriptionContainer = Page.createElement("div", bodyElement, null, null);
      const imgElement = Page.createElement("img", iconElement, null, null);
      imgElement.src = Images.pick;
      this.titleElement = Page.createElement("div", titleDescriptionContainer, null, null);
      this.titleElement.innerHTML = this.headerText;
      this.descriptionElement = Page.createElement("div", titleDescriptionContainer, null, "skill-panel-row2-description");
      this.descriptionElement.innerHTML = this.getDescription();
      this.setInitialVisibility(false);
      const thisRef = this;
      this.mainElement.onclick = function() {
        thisRef.automation.toggleActiveFlag();
      };
      super.initializeView();
    }
    /**
     * This exists so that prestige automation can inject their own class name.
     * @returns {string}
     */
    getProgressElementClassName() {
      return "automation-progress-panel";
    }
    /**
     * @override
     */
    updateView() {
      const visible = this.automation.isUnlocked();
      if (visible !== this.isViewVisible()) {
        this.setViewVisible(visible);
      }
      super.updateView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const active = this.automation.active;
      if (this.displayedActive !== active) {
        this.displayedActive = active;
        const mainStyleClass = active ? "automation-button-outer-active" : "automation-button-outer-not-active";
        this.mainElement.className = mainStyleClass;
        this.descriptionElement.innerHTML = this.getDescription();
      }
      const percent = this.automation.getActivationPercent();
      if (this.displayedPercent !== percent) {
        this.displayedPercent = percent;
        this.activeProgressElement.style.width = percent + "%";
      }
    }
    /**
     * @returns {string}
     */
    getDescription() {
      return this.automation.active ? "Active" : "Not Active";
    }
  };

  // src/view/common/PrestigeAutomationView.js
  var PrestigeAutomationView = class extends AutomationView {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {string} headerText 
     * @param {PrestigeAutomation} automation
     */
    constructor(parentId, elementId, headerText, automation) {
      super(parentId, elementId, headerText, automation);
      this.prestigeAutomation = automation;
      this.displayedElapsedSeconds = -1;
    }
    /**
     * This exists so that prestige automation can inject their own class name.
     * @override
     * @returns {string}
     */
    getProgressElementClassName() {
      return "automation-progress-panel";
    }
    /**
     * @override
     */
    updateViewContents() {
      const active = this.automation.active;
      if (this.displayedActive !== active) {
        this.displayedActive = active;
        const mainStyleClass = active ? "automation-button-outer-active" : "automation-button-outer-not-active";
        this.mainElement.className = mainStyleClass;
        this.descriptionElement.innerHTML = this.getDescription();
      }
      if (active) {
        const percent = this.automation.getActivationPercent();
        if (this.displayedPercent !== percent) {
          this.displayedPercent = percent;
          this.activeProgressElement.style.width = percent + "%";
        }
      }
    }
    /**
     * @override
     * @returns {string}
     */
    getDescription() {
      if (!this.automation.active) {
        return "Not Active";
      }
      return "Active";
    }
  };

  // src/view/menu/MenuPanel.js
  var MenuPanel = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {PopupViewController} popupViewController 
     * @param {PrestigeAutomation} prestigeAutomation
     */
    constructor(parentId, popupViewController, prestigeAutomation) {
      super(parentId, PageIds.MENU_PANEL);
      this.addView(new HeaderView(this.elementId, this.elementId + "_header", "Menu"));
      this.addView(new PopupViewToggle(this.elementId, this.elementId + "_prestige", popupViewController, PageIds.PRESTIGE_POPUP, "Prestige"));
      const skillTreeToggle = new PopupViewToggle(this.elementId, this.elementId + "_skill", popupViewController, PageIds.SKILL_TREE_GRAPH, "Skill Tree");
      skillTreeToggle.secondaryPopupViewId = PageIds.CLOSE_SKILL_TREE_POPUP;
      this.addView(skillTreeToggle);
      this.addView(new PopupViewToggle(this.elementId, this.elementId + "_stats", popupViewController, PageIds.STATISTICS_POPUP, "Statistics View"));
      this.addView(new PopupViewToggle(this.elementId, this.elementId + "_save", popupViewController, PageIds.SAVE_POPUP, "Save View"));
      this.addView(new PopupViewToggle(this.elementId, this.elementId + "_options", popupViewController, PageIds.GAME_OPTIONS_POPUP, "Settings"));
      this.addView(new PopupViewToggle(this.elementId, this.elementId + "_performance", popupViewController, PageIds.PERFORMANCE_POPUP, "Performance View (Dev tool)"));
      this.addView(new PrestigeAutomationView(this.elementId, this.elementId + "_auto_prestige", "Auto Prestige", prestigeAutomation));
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      const mainElement = Page.createElement("div", parent, this.elementId, null);
      mainElement.style.display = "none";
      this.setViewVisible(false);
      this.setCurrentlyVisible(true);
      super.initializeView();
    }
  };

  // src/view/upgrades/UpgradeTabItemView.js
  var UpgradeTabItemView = class extends View {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {View} tabContentsView
     * @param {PrimaryUpgradeTabBar} tabContainerView 
     * @param {string} tabIconPath
     */
    constructor(parentId, elementId, tabContentsView, tabContainerView, tabIconPath) {
      super(parentId, elementId);
      this.tabContentsView = tabContentsView;
      this.tabContainerView = tabContainerView;
      this.tabIconPath = tabIconPath;
      this.tabItem = null;
    }
    /**
     * Returns the value that the display property should be set to in order to make
     * the element visible. 
     * 
     * By default this is 'block', but you should overwrite this if the element is 'display:flex', or 'display:inline-block' 
     * or something other than 'display:block'.
     * 
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "inline-block";
    }
    /**
     * @override
     * @inheritdoc
     */
    initializeView() {
      const thisRef = this;
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      this.tabItem = Page.createElement("button", parent, id, "upgrade-tab-menu-item");
      const tabImage = Page.createElement("img", this.tabItem, null, "icon-container");
      tabImage.src = this.tabIconPath;
      this.tabItem.onclick = function() {
        thisRef.tabContainerView.onTabItemViewClicked(thisRef);
      };
      super.initializeView();
    }
    /**
     * @param {boolean} tabSelected 
     */
    setTabSelected(tabSelected) {
      if (tabSelected) {
        this.tabItem.className = "upgrade-tab-menu-item-selected";
      } else {
        this.tabItem.className = "upgrade-tab-menu-item";
      }
    }
  };

  // src/view/upgrades/PrimaryUpgradeTabBar.js
  var PrimaryUpgradeTabBar = class extends ParentView {
    /**
     * @param {string} parentId
     */
    constructor(parentId) {
      super(parentId, PageIds.PRIMARY_UPGRADE_PANEL_TAB_BAR);
      this.tabItemViews = [];
      this.setViewVisible(true);
      this.setCurrentlyVisible(false);
    }
    /**
     * @param {View} tabContentsView 
     * @param {string} tabIconPath
     */
    addPanelView(tabContentsView, tabIconPath) {
      const tabId = tabContentsView.elementId + "_tab";
      const tabItemView = new UpgradeTabItemView(this.elementId, tabId, tabContentsView, this, tabIconPath);
      this.tabItemViews.push(tabItemView);
      this.addView(tabItemView);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      const primaryUpgradeTabBar = Page.createElement("div", parentElement, this.getElementId(), "upgrade-tab-menu-bar");
      super.initializeView();
      Page.createElement("div", primaryUpgradeTabBar, null, "upgrade-tab-menu-bar-fill-remaining");
      if (this.tabItemViews.length > 0) {
        this.onTabItemViewClicked(this.tabItemViews[0]);
      }
    }
    /**
     * Invoked by the TabItemView when it is clicked.
     * @param {UpgradeTabItemView} tabItemView The tab item that was clicked
     */
    onTabItemViewClicked(tabItemView) {
      for (let i = 0; i < this.tabItemViews.length; i++) {
        const currentTabItemView = this.tabItemViews[i];
        const tabSelected = currentTabItemView === tabItemView;
        currentTabItemView.setTabSelected(tabSelected);
        currentTabItemView.tabContentsView.setViewVisible(tabSelected);
      }
    }
    /**
     * Returns the value that the display property should be set to in order to make
     * the element visible. 
     * 
     * By default this is 'block', but you should overwrite this if the element is 'display:flex', or 'display:inline-block' 
     * or something other than 'display:block'.
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "flex";
    }
  };

  // src/view/upgrades/classic/CountToPurchaseView.js
  var CountToPurchaseView = class extends View {
    /**
     * @param {string} parentId
     * @param {ClassicUpgradeCollection} upgradeCollection
     */
    constructor(parentId, elementId, upgradeCollection) {
      super(parentId, elementId);
      this.upgradeCollection = upgradeCollection;
      this.purchaseOneButton = null;
      this.purchaseFiveButton = null;
      this.purchaseTenButton = null;
      this.purchaseMaxButton = null;
      this.displayedPurchaseCount = CountToPurchase.purchaseOne;
      this.setCurrentlyVisible(false);
      this.setViewVisible(true);
    }
    /**
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "grid";
    }
    /**
     * @override
     */
    initializeView() {
      super.initializeView();
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("CountToPurchaseView.initializeView() No element found! id=" + id);
        return;
      }
      const containerElement = Page.createElement("div", parent, id, "purchase-count-button-container");
      this.purchaseOneButton = Page.createElement("div", containerElement, id + "_one", "purchase-count-button-selected");
      this.purchaseFiveButton = Page.createElement("div", containerElement, id + "_five", "purchase-count-button");
      this.purchaseTenButton = Page.createElement("div", containerElement, id + "_ten", "purchase-count-button");
      this.purchaseMaxButton = Page.createElement("div", containerElement, id + "_max", "purchase-count-button");
      this.purchaseOneButton.innerHTML = "1";
      this.purchaseFiveButton.innerHTML = "5";
      this.purchaseTenButton.innerHTML = "10";
      this.purchaseMaxButton.innerHTML = "Max";
      const thisRef = this;
      this.purchaseOneButton.onclick = function() {
        thisRef.upgradeCollection.setCountToPurchase(CountToPurchase.purchaseOne);
      };
      this.purchaseFiveButton.onclick = function() {
        thisRef.upgradeCollection.setCountToPurchase(CountToPurchase.purchaseFive);
      };
      this.purchaseTenButton.onclick = function() {
        thisRef.upgradeCollection.setCountToPurchase(CountToPurchase.purchaseTen);
      };
      this.purchaseMaxButton.onclick = function() {
        thisRef.upgradeCollection.setCountToPurchase(CountToPurchase.purchaseMax);
      };
    }
    /**
     * @override
     */
    updateViewContents() {
      const countToPurchase = this.upgradeCollection.countToPurchase;
      if (this.displayedPurchaseCount === countToPurchase) {
        return;
      }
      if (this.displayedPurchaseCount === CountToPurchase.purchaseOne) {
        this.purchaseOneButton.className = "purchase-count-button";
      } else if (this.displayedPurchaseCount === CountToPurchase.purchaseFive) {
        this.purchaseFiveButton.className = "purchase-count-button";
      } else if (this.displayedPurchaseCount === CountToPurchase.purchaseTen) {
        this.purchaseTenButton.className = "purchase-count-button";
      } else if (this.displayedPurchaseCount === CountToPurchase.purchaseMax) {
        this.purchaseMaxButton.className = "purchase-count-button";
      }
      if (countToPurchase === CountToPurchase.purchaseOne) {
        this.purchaseOneButton.className = "purchase-count-button-selected";
      } else if (countToPurchase === CountToPurchase.purchaseFive) {
        this.purchaseFiveButton.className = "purchase-count-button-selected";
      } else if (countToPurchase === CountToPurchase.purchaseTen) {
        this.purchaseTenButton.className = "purchase-count-button-selected";
      } else if (countToPurchase === CountToPurchase.purchaseMax) {
        this.purchaseMaxButton.className = "purchase-count-button-selected";
      }
      this.displayedPurchaseCount = countToPurchase;
    }
  };

  // src/view/upgrades/classic/ClassicUpgradeView.js
  var ClassicUpgradeView = class extends View {
    /**
     * @param {string} parentId 
     * @param {string} elementId 
     * @param {ClassicUpgrade} upgrade
     * @param {boolean} displayDescriptionRow
     */
    constructor(parentId, elementId, upgrade, displayDescriptionRow) {
      super(parentId, elementId);
      this.upgrade = upgrade;
      this.displayDescriptionRow = displayDescriptionRow;
      this.mainElement = null;
      this.titleElement = null;
      this.descriptionElement = null;
      this.costElement = null;
      this.displayedCost = new BigNum(-10);
      this.countElement = null;
      this.displayedCount = -10;
      this.displayedNextActualPurchaseCount = -10;
      this.displayedTitle = null;
      this.displayedDescription = null;
      this.displayedPurchasable = !this.upgrade.isPurchasable();
    }
    /**
     * @param {ClassicUpgrade} upgrade 
     */
    setClassicUpgrade(upgrade) {
      this.upgrade = upgrade;
    }
    /**
     * @override
     */
    initializeView() {
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("PickUpgradeView.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      this.displayedPurchasable = this.upgrade.isPurchasable();
      const mainElementClass = this.displayedPurchasable ? "upgrade-button-outer" : "upgrade-button-outer-not-purchasable";
      this.mainElement = Page.createElement("div", parent, id, mainElementClass);
      const row1 = Page.createElement("div", this.mainElement, null, "pick-upgrade-button-row1");
      const imgElement = Page.createElement("img", row1, null, "pick-upgrade-icon");
      imgElement.src = Images.pick;
      const titleDescriptionContainer = Page.createElement("div", row1, null, "pick-upgrade-title-description-container");
      if (this.displayDescriptionRow) {
        this.titleElement = Page.createElement("div", titleDescriptionContainer, null, "pick-upgrade-button-title-double-row");
        this.descriptionElement = Page.createElement("div", titleDescriptionContainer, null, "pick-upgrade-button-description");
        this.descriptionElement.innerHTML = "";
      } else {
        this.titleElement = Page.createElement("div", titleDescriptionContainer, null, "pick-upgrade-button-title-single-row");
      }
      this.titleElement.innerHTML = "";
      const rightElement = Page.createElement("div", row1, null, null);
      this.countElement = Page.createElement("div", rightElement, null, "pick-upgrade-count");
      this.costElement = Page.createElement("div", rightElement, null, "pick-upgrade-cost");
      this.setInitialVisibility(this.upgrade.isVisible());
      const thisRef = this;
      this.mainElement.onclick = function() {
        if (!thisRef.upgrade.isPurchasable()) {
          return;
        }
        thisRef.upgrade.purchase();
      };
      super.initializeView();
    }
    /**
     * Updates the user interface to reflect the data in the model.
     * @override
     */
    updateView() {
      this.setViewVisible(this.upgrade && this.upgrade.isVisible());
      super.updateView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const cost = this.upgrade.getCost();
      const count = this.upgrade.purchasedCount;
      const purchasable = this.upgrade.isPurchasable();
      const countToPurchase = this.upgrade.getCountToPurchaseSetting();
      const nextActualPurchaseCount = this.upgrade.nextActualPurchaseCount;
      if (!cost.equals(this.displayedCost)) {
        this.displayedCost.copy(cost);
        this.costElement.innerHTML = NumberFormatter.formatBigNum(cost) + " " + this.upgrade.getCostUnit();
      }
      if (count !== this.displayedCount || nextActualPurchaseCount !== this.displayedNextActualPurchaseCount) {
        this.displayedCount = count;
        this.displayedNextActualPurchaseCount = nextActualPurchaseCount;
        if (countToPurchase === CountToPurchase.purchaseOne) {
          this.countElement.innerHTML = "" + count;
        } else {
          this.countElement.innerHTML = "" + count + "+" + nextActualPurchaseCount;
        }
      }
      const title = this.upgrade.title;
      if (title !== this.displayedTitle) {
        this.displayedTitle = title;
        this.titleElement.innerHTML = title;
      }
      if (this.displayDescriptionRow) {
        const description = this.upgrade.getDescription();
        if (description && description !== this.displayedDescription) {
          this.displayedDescription = description;
          this.descriptionElement.innerHTML = description;
        }
      }
      if (purchasable !== this.displayedPurchasable) {
        this.displayedPurchasable = purchasable;
        if (purchasable) {
          this.mainElement.className = "upgrade-button-outer";
        } else {
          this.mainElement.className = "upgrade-button-outer-not-purchasable";
        }
      }
    }
  };

  // src/view/upgrades/classic/ClassicUpgradeCollectionView.js
  var ClassicUpgradeCollectionView = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {ClassicUpgradeCollection} upgradeCollection
     */
    constructor(parentId, elementId, upgradeCollection) {
      super(parentId, elementId);
      this.upgradeCollection = upgradeCollection;
      this.upgradeViews = [];
      this.idSequence = 0;
      const upgrades = this.upgradeCollection.upgrades;
      for (let i = 0; i < upgrades.length; i++) {
        const upgrade = upgrades[i];
        if (!upgrade || !upgrade.isVisible()) {
          continue;
        }
        const upgradeView = this.createUpgradeView(upgrades[i]);
        this.upgradeViews.push(upgradeView);
        this.addView(upgradeView);
      }
    }
    /**
     * @returns {number}
     */
    getNextId() {
      return ++this.idSequence;
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      Page.createElement("div", parent, this.elementId, null);
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      const upgrades = this.upgradeCollection.upgrades;
      let i = 0;
      let j = 0;
      for (; i < upgrades.length && j < this.upgradeViews.length; i++) {
        const upgrade = upgrades[i];
        if (!upgrade || !upgrade.isVisible()) {
          continue;
        }
        this.upgradeViews[j].setClassicUpgrade(upgrade);
        j++;
      }
      if (i < upgrades.length) {
        for (; i < upgrades.length; i++) {
          const upgrade = upgrades[i];
          if (!upgrade || !upgrade.isVisible()) {
            continue;
          }
          const upgradeView = this.createUpgradeView(upgrades[i]);
          this.upgradeViews.push(upgradeView);
          this.addView(upgradeView);
          upgradeView.initializeView();
        }
      } else if (j < this.upgradeViews.length) {
        for (; j < this.upgradeViews.length; j++) {
          this.upgradeViews[j].setClassicUpgrade(null);
        }
      }
      super.updateViewContents();
    }
    /**
     * 
     * @param {ClassicUpgrade} upgrade 
     * @returns {ClassicUpgradeView}
     */
    createUpgradeView(upgrade) {
      return new ClassicUpgradeView(this.elementId, this.elementId + "_" + this.getNextId(), upgrade, false);
    }
  };

  // src/view/upgrades/PickUpgradePanel.js
  var PickUpgradePanel = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {PickUpgradeCollection} pickUpgradeCollection
     * @param {PickUpgradeAutomation} pickUpgradeAutomation
     */
    constructor(parentId, elementId, pickUpgradeCollection, pickUpgradeAutomation) {
      super(parentId, elementId);
      this.addView(new HeaderView(this.elementId, this.elementId + "_header", "Ore Upgrades"));
      this.addView(new ClassicUpgradeCollectionView(this.elementId, this.elementId + "_upgrades", pickUpgradeCollection));
      this.addView(new HeaderView(this.elementId, this.elementId + "_settings_header", "Purchase Settings"));
      this.addView(new CountToPurchaseView(this.elementId, this.elementId + "_ctp", pickUpgradeCollection));
      this.addView(new AutomationView(this.elementId, this.elementId + "_auto", "Auto Purchase", pickUpgradeAutomation));
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      const mainElement = Page.createElement("div", parent, this.elementId, "primary-upgrade-panel-body");
      mainElement.style.display = "none";
      this.setViewVisible(false);
      this.setCurrentlyVisible(true);
      super.initializeView();
    }
  };

  // src/view/upgrades/classic/GoldUpgradeCollectionView.js
  var GoldUpgradeCollectionView = class extends ClassicUpgradeCollectionView {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {ClassicUpgradeCollection} upgradeCollection
     */
    constructor(parentId, elementId, upgradeCollection) {
      super(parentId, elementId, upgradeCollection);
    }
    /**
     * @override
     * @param {ClassicUpgrade} upgrade 
     * @returns {ClassicUpgradeView}
     */
    createUpgradeView(upgrade) {
      return new ClassicUpgradeView(this.elementId, this.elementId + "_" + this.getNextId(), upgrade, true);
    }
  };

  // src/view/upgrades/GoldUpgradePanel.js
  var GoldUpgradePanel = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId
     * @param {GoldUpgradeCollection} goldUpgradeCollection
     */
    constructor(parentId, elementId, goldUpgradeCollection) {
      super(parentId, elementId);
      this.addView(new HeaderView(this.elementId, this.elementId + "_header", "Gold Upgrades"));
      this.addView(new GoldUpgradeCollectionView(this.elementId, this.elementId + "_gold_upgrades", goldUpgradeCollection));
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      const mainElement = Page.createElement("div", parent, this.elementId, "primary-upgrade-panel-body");
      mainElement.style.display = "none";
      this.setInitialVisibility(false);
      super.initializeView();
    }
  };

  // src/view/upgrades/free/MinedUpgradeView.js
  var MinedUpgradeView = class extends View {
    /**
     * @param {string} parentId 
     * @param {string} elementId 
     * @param {MinedUpgradeCollection} minedUpgradeCollection
     */
    constructor(parentId, elementId, minedUpgradeCollection) {
      super(parentId, elementId);
      this.titleDescriptionContainerId = elementId + "_text";
      this.minedUpgradeCollection = minedUpgradeCollection;
      this.upgrade = null;
      this.mainElement = null;
      this.titleDescriptionContainer = null;
      this.imgElement = null;
      this.titleElement = null;
      this.displayedTitle = null;
      this.displayedDescription = null;
      this.descriptionElement = null;
      this.displayedIconFileName = null;
      this.displayedPurchasable = true;
    }
    /**
     * @param {FreeUpgrade} upgrade 
     */
    setUpgrade(upgrade) {
      if (this.upgrade === upgrade) {
        return;
      }
      this.upgrade = upgrade;
      if (upgrade) {
        const description = this.upgrade.getDescription();
        this.displayedDescription = null;
        if (!description) {
          if (this.descriptionElement) {
            Page.removeElement(this.titleDescriptionContainerId, this.descriptionElement);
            this.descriptionElement = null;
          }
          this.titleElement.className = "mined-upgrade-button-title-single-row";
        } else if (!this.descriptionElement) {
          this.descriptionElement = Page.createElement("div", this.titleDescriptionContainer, null, "mined-upgrade-button-description");
          this.descriptionElement.innerHTML = "";
          this.titleElement.className = "mined-upgrade-button-title-double-row";
        }
        this.displayedPurchasable = !this.upgrade.isPurchasable();
        this.setViewVisible(true);
      } else {
        this.setViewVisible(false);
      }
    }
    /**
     * @override
     */
    initializeView() {
      const id = this.getElementId();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("UpgradeView.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      this.mainElement = Page.createElement("div", parent, id, "upgrade-button-outer");
      const bodyElement = Page.createElement("div", this.mainElement, null, "mined-upgrade-button-body");
      const iconElement = Page.createElement("div", bodyElement, null, "icon-container");
      this.titleDescriptionContainer = Page.createElement("div", bodyElement, this.titleDescriptionContainerId, "mined-upgrade-title-description-container");
      this.imgElement = Page.createElement("img", iconElement, null, null);
      this.imgElement.src = Images.pick;
      this.titleElement = Page.createElement("div", this.titleDescriptionContainer, null, "mined-upgrade-button-title-single-row");
      this.titleElement.innerHTML = "";
      Page.hideElement(this.mainElement);
      this.setViewVisible(false);
      const thisRef = this;
      this.mainElement.onclick = function() {
        if (!thisRef.upgrade || !thisRef.upgrade.isPurchasable()) {
          return;
        }
        if (thisRef.upgrade.purchase()) {
          thisRef.minedUpgradeCollection.remove(thisRef.upgrade);
          thisRef.upgrade = null;
          thisRef.setViewVisible(false);
        }
      };
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      if (!this.upgrade) {
        return;
      }
      const title = this.upgrade.title;
      if (title !== this.displayedTitle) {
        this.displayedTitle = title;
        this.titleElement.innerHTML = title;
      }
      const description = this.upgrade.getDescription();
      if (description && description !== this.displayedDescription) {
        this.displayedDescription = description;
        if (this.descriptionElement) {
          this.descriptionElement.innerHTML = description;
        } else {
          console.log("MinedUpgradeView.updateViewContents() null description element");
        }
      }
      const iconFileName = this.upgrade.iconFileName;
      if (this.displayedIconFileName !== iconFileName) {
        this.displayedIconFileName = iconFileName;
        this.imgElement.src = iconFileName;
      }
      const purchasable = this.upgrade.isPurchasable();
      if (this.displayedPurchasable !== purchasable) {
        this.displayedPurchasable = purchasable;
        if (purchasable) {
          this.mainElement.className = "upgrade-button-outer";
        } else {
          this.mainElement.className = "upgrade-button-outer-not-purchasable";
        }
      }
    }
  };

  // src/view/upgrades/free/MinedUpgradeCollectionView.js
  var MinedUpgradeCollectionView = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {string} elementId 
     * @param {MinedUpgradeCollection} minedUpgradeCollection
     */
    constructor(parentId, elementId, minedUpgradeCollection) {
      super(parentId, elementId);
      this.minedUpgradeCollection = minedUpgradeCollection;
      this.displayedChangeCount = -1;
      this.maxDisplayCount = 15;
      this.upgradeViews = [];
      this.addView(new HeaderView(this.elementId, this.elementId + "_header", "Mined Upgrades"));
      for (let i = 0; i < this.maxDisplayCount; i++) {
        const upgradeView = new MinedUpgradeView(elementId, elementId + "_" + i, minedUpgradeCollection);
        this.upgradeViews.push(upgradeView);
        this.addView(upgradeView);
      }
      this.setCurrentlyVisible(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      Page.createElement("div", parent, this.elementId, null);
      super.initializeView();
    }
    updateView() {
      super.updateView();
    }
    /**
     * @override
     */
    updateViewContents() {
      if (this.displayedChangeCount !== this.minedUpgradeCollection.changeCount) {
        this.displayedChangeCount = this.minedUpgradeCollection.changeCount;
        this.updateUpgrades();
      }
      super.updateViewContents();
    }
    /**
     * @private
     */
    updateUpgrades() {
      const upgrades = this.minedUpgradeCollection.upgrades;
      const size = Math.min(upgrades.length, this.maxDisplayCount);
      let i = 0;
      for (; i < size; i++) {
        if (i < this.upgradeViews.length) {
          this.upgradeViews[i].setUpgrade(upgrades[i]);
        }
      }
      for (; i < this.upgradeViews.length; i++) {
        this.upgradeViews[i].setUpgrade(null);
      }
    }
  };

  // src/view/upgrades/free/FreeUpgradePanel.js
  var FreeUpgradePanel = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {MinedUpgradeCollectionView} minedUpgradeCollection
     * @param {MinedUpgradeAutomation} minedUpgradeAutomation
     */
    constructor(parentId, minedUpgradeCollection, minedUpgradeAutomation) {
      super(parentId, PageIds.FREE_UPGRADES_PANEL);
      this.addView(new MinedUpgradeCollectionView(this.elementId, PageIds.MINED_UPGRADES_PANEL, minedUpgradeCollection));
      this.addView(new AutomationView(this.elementId, this.elementId + "_auto", "Auto Claim", minedUpgradeAutomation));
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      Page.createElement("div", parent, this.elementId, "primary-upgrade-panel-body");
      super.initializeView();
    }
  };

  // src/view/upgrades/PrimaryUpgradePanel.js
  var PrimaryUpgradePanel = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {MinedUpgradeCollection} minedUpgradeCollection
     * @param {MinedUpgradeAutomation} minedUpgradeAutomation
     * @param {PickUpgradeCollection} pickUpgradeCollection
     * @param {PickUpgradeAutomation} pickUpgradeAutomation
     * @param {GoldUpgradeCollection} goldUpgradeCollection
     * @param {PrestigeAutomation} prestigeAutomation
     * @param {BonusCollection} bonusCollection
     * @param {PopupViewController} popupViewController
     */
    constructor(parentId, minedUpgradeCollection, minedUpgradeAutomation, pickUpgradeCollection, pickUpgradeAutomation, goldUpgradeCollection, prestigeAutomation, popupViewController) {
      super(parentId, PageIds.PRIMARY_UPGRADE_PANEL);
      const upgradeTabBar = new PrimaryUpgradeTabBar(this.elementId);
      this.addView(upgradeTabBar);
      const freeUpgradesPanel = new FreeUpgradePanel(this.elementId, minedUpgradeCollection, minedUpgradeAutomation);
      const pickUpgradePanel = new PickUpgradePanel(
        this.elementId,
        PageIds.PICK_UPGRADES_PANEL,
        pickUpgradeCollection,
        pickUpgradeAutomation
      );
      const goldUpgradePanel = new GoldUpgradePanel(this.elementId, PageIds.GOLD_UPGRADES_PANEL, goldUpgradeCollection);
      const menuPanel = new MenuPanel(this.elementId, popupViewController, prestigeAutomation);
      this.addView(freeUpgradesPanel);
      this.addView(pickUpgradePanel);
      this.addView(goldUpgradePanel);
      this.addView(menuPanel);
      upgradeTabBar.addPanelView(freeUpgradesPanel, Images.currency.upgrades);
      upgradeTabBar.addPanelView(pickUpgradePanel, Images.currency.ore);
      upgradeTabBar.addPanelView(goldUpgradePanel, Images.currency.gold);
      upgradeTabBar.addPanelView(menuPanel, Images.pick);
      this.setViewVisible(true);
      this.setCurrentlyVisible(true);
    }
    /**
     * @override
     */
    initializeView() {
      const parentElement = Page.getElement(this.parentId);
      Page.createElement("div", parentElement, this.getElementId(), "primary-upgrade-panel");
      super.initializeView();
    }
    /**
     * Returns the value that the display property should be set to in order to make
     * the element visible. 
     * 
     * By default this is 'block', but you should overwrite this if the element is 'display:flex' or something other than 'display:block'.
     * @override
     * @returns {string}
     */
    getVisibileDisplayValue() {
      return "flex";
    }
  };

  // src/view/GameViewOverlay.js
  var GameViewOverlay = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {State} state
     * @param {GameStateControl} gameStateControl 
     * @param {PopupViewController} popupViewController
     */
    constructor(parentId, state, gameStateControl, popupViewController) {
      super(parentId, PageIds.GAME_VIEW_OVERLAY_CONTAINER);
      const elementId = this.getElementId();
      this.addView(new TopRowContainer(elementId, "topRowContainer", state.totals, state.partyTarget, state.runStatistics));
      this.addView(new ActiveBonusesView(elementId, state.bonusCollection));
      this.addView(new PopupContainer(
        elementId,
        "popupContainer",
        state.runStatistics,
        state.globalStatistics,
        state.totals,
        state.gameOptions,
        gameStateControl,
        popupViewController
      ));
      this.addView(new PrimaryUpgradePanel(
        elementId,
        state.minedUpgradeCollection,
        state.automationManager.minedUpgradeAutomation,
        state.pickUpgradeCollection,
        state.automationManager.pickUpgradeAutomation,
        state.goldUpgradeCollection,
        state.automationManager.prestigeAutomation,
        popupViewController
      ));
      this.addView(new BottomRowContainer(
        elementId,
        "bottomRowContainer",
        state.damage,
        state.values,
        state.partyTarget,
        state.mineControl,
        state.crew,
        state.projection,
        state.panAnimation,
        state.runStatistics
      ));
    }
    /**
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      Page.createElement("div", parent, this.elementId, "view-overlay-container");
      this.setInitialVisibility(true);
      super.initializeView();
    }
  };

  // src/view/skillTree/NodeConnectionView.js
  var NodeConnectionView = class extends View {
    /**
     * @param {string} parentId 
     * @param {SkillNode} parentNode
     * @param {SkillNode} childNode
     */
    constructor(parentId, parentNode, childNode) {
      super(parentId, parentId + "_" + parentNode.id + "_" + childNode.id + "_con");
      this.parentNode = parentNode;
      this.childNode = childNode;
      this.originNode = this.getTopLeftNode();
      this.mainElement = null;
      this.displayCoordinate = new Vector(0, 0);
    }
    /**
     * @override
     */
    initializeView() {
      super.initializeView();
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("NodeConnectionView.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      const vertical = this.isConnectionVertical();
      const className = this.isConnectionVertical() ? "connection-vertical" : "connection-horizontal";
      this.mainElement = Page.createElement("div", parent, this.elementId, className);
      if (vertical) {
        this.mainElement.style.height = Math.abs(this.parentNode.graphCoordinate.y - this.childNode.graphCoordinate.y) + "px";
      } else {
        this.mainElement.style.width = Math.abs(this.parentNode.graphCoordinate.x - this.childNode.graphCoordinate.x) + "px";
      }
      this.setInitialVisibility(true);
      this.updatePosition();
    }
    /**
     * @override
     */
    updateViewContents() {
      this.updatePosition();
    }
    /**
     * @private
     */
    updatePosition() {
      if (this.displayCoordinate.equals(this.originNode.viewCoordinate)) {
        return;
      }
      this.displayCoordinate.copy(this.originNode.viewCoordinate);
      const offsetX = Settings.skillGraph.connectorOffsetX;
      const offsetY = Settings.skillGraph.connectorOffsetY;
      this.mainElement.style.left = this.originNode.viewCoordinate.x + offsetX + "px";
      this.mainElement.style.top = this.originNode.viewCoordinate.y + offsetY + "px";
    }
    /**
     * @private
     * @returns {boolean}
     */
    isConnectionVertical() {
      const other = this.originNode === this.childNode ? this.parentNode : this.childNode;
      const originCoord = this.originNode.graphCoordinate;
      const otherCoord = other.graphCoordinate;
      return originCoord.x === otherCoord.x;
    }
    /**
     * Figure out which node we should use as the 'origin' of the connection.
     * @private
     * @returns {SkillNode}
     */
    getTopLeftNode() {
      const parentCoord = this.parentNode.graphCoordinate;
      const childCoord = this.childNode.graphCoordinate;
      if (parentCoord.x === childCoord.x) {
        if (parentCoord.y < childCoord.y) {
          return this.parentNode;
        } else {
          return this.childNode;
        }
      }
      if (parentCoord.y === childCoord.y) {
        if (parentCoord.x < childCoord.x) {
          return this.parentNode;
        } else {
          return this.childNode;
        }
      }
      if (parentCoord.x < childCoord.x) {
        return this.parentNode;
      }
      return this.childNode;
    }
  };

  // src/view/skillTree/SkillNodeView.js
  var SkillNodeView = class extends View {
    /**
     * 
     * @param {string} parentId 
     * @param {SkillNode} node 
     */
    constructor(parentId, node) {
      super(parentId, parentId + "_" + node.id);
      this.node = node;
      this.mainElement = null;
      this.titleElement = null;
      this.displayedTitle = null;
      this.descriptionElement = null;
      this.displayedDescription = null;
      this.costElement = null;
      this.displayedCost = new BigNum(-10);
      this.displayCoordinate = new Vector(0, 0);
      this.displayedPurchaseState = 0;
    }
    /**
     * @param {boolean} purchasable 
     * @param {boolean} purchased 
     * @returns {number}
     */
    getPurchaseStateValue(purchasable, purchased) {
      if (purchased) {
        return 2;
      }
      if (purchasable) {
        return 1;
      }
      return 0;
    }
    /**
     * @override
     */
    initializeView() {
      super.initializeView();
      const id = this.getElementId();
      const description = this.node.description;
      const parent = Page.getElement(this.parentId);
      if (!parent) {
        console.log("SkillNodeView.initializeView() No parent element found! parentId=" + this.parentId);
        return;
      }
      this.mainElement = Page.createElement("div", parent, id, "skill-tree-button-outer-not-purchasable");
      this.displayedPurchaseState = -1;
      const row1 = Page.createElement("div", this.mainElement, null, "skill-tree-button-row1");
      const imgElement = Page.createElement("img", row1, null, "icon-container");
      imgElement.src = this.node.iconFileName;
      const titleDescriptionContainer = Page.createElement("div", row1, null, "pick-upgrade-title-description-container");
      this.titleElement = Page.createElement("div", titleDescriptionContainer, null, null);
      this.titleElement.innerHTML = "";
      this.costElement = Page.createElement("div", titleDescriptionContainer, null, "pick-upgrade-button-title-double-row");
      this.descriptionElement = Page.createElement("div", this.mainElement, null, "skill-tree-button-description");
      this.descriptionElement.innerHTML = description;
      this.displayedDescription = description;
      const thisRef = this;
      this.mainElement.onclick = function() {
        if (!thisRef.node.isPurchasable()) {
          return;
        }
        thisRef.node.onPurchase();
      };
      this.setInitialVisibility(false);
      this.updatePosition();
    }
    /**
     * @override
     */
    updateView() {
      this.setViewVisible(this.node.nodeVisible);
      super.updateView();
    }
    /**
     * @override
     */
    updateViewContents() {
      this.updatePosition();
      const cost = this.node.getCost();
      const purchasable = this.node.isPurchasable();
      const purchased = this.node.purchased;
      const purchaseState = this.getPurchaseStateValue(purchasable, purchased);
      if (!cost.equals(this.displayedCost)) {
        this.displayedCost.copy(cost);
        this.costElement.innerHTML = NumberFormatter.formatBigNum(cost) + " Prestige";
      }
      const title = this.node.getTitle();
      if (title !== this.displayedTitle) {
        this.displayedTitle = title;
        this.titleElement.innerHTML = title;
      }
      const description = this.node.getDescription();
      if (description !== this.displayedDescription) {
        this.displayedDescription = description;
        this.descriptionElement.innerHTML = description;
      }
      if (this.displayedPurchaseState !== purchaseState) {
        this.displayedPurchaseState = purchaseState;
        if (purchaseState === 0) {
          this.mainElement.className = "skill-tree-button-outer-not-purchasable";
        } else if (purchaseState === 1) {
          this.mainElement.className = "skill-tree-button-outer";
        } else {
          this.mainElement.className = "skill-tree-button-outer-purchased";
        }
      }
    }
    /**
     * @private
     */
    updatePosition() {
      if (this.displayCoordinate.equals(this.node.viewCoordinate)) {
        return;
      }
      this.displayCoordinate.copy(this.node.viewCoordinate);
      this.mainElement.style.left = this.node.viewCoordinate.x + "px";
      this.mainElement.style.top = this.node.viewCoordinate.y + "px";
    }
    //  border: 2px on each side
    //  padding: 5px on each size
    //  width: 180px
    //  actual width: 2 + 2 + 5 + 5 + 180 = 194
  };

  // src/view/skillTree/SkillTreeView.js
  var SkillTreeView = class extends ParentView {
    /**
     * @param {string} parentId
     * @param {SkillTreeGraph} skillTreeGraph
     * @param {UserInput} userInput
     */
    constructor(parentId, skillTreeGraph, userInput) {
      super(parentId, PageIds.SKILL_TREE_GRAPH);
      this.skillTreeGraph = skillTreeGraph;
      this.userInput = userInput;
      this.mainElement = null;
      this.displayCenterOffset = new Vector(-50, -50);
      this.displayedZoom = 0;
      const skills = this.skillTreeGraph.skills;
      for (let i = 0; i < skills.length; i++) {
        this.addNodeConnectionViews(skills[i].rootNode);
      }
      for (let i = 0; i < skills.length; i++) {
        this.addNodeAndChildViews(skills[i].rootNode);
      }
    }
    /**
     * @private
     * @param {SkillNode} node 
     */
    addNodeAndChildViews(node) {
      const id = this.getElementId();
      this.addView(new SkillNodeView(id, node));
      const children = node.children;
      if (!children) {
        return;
      }
      const nodeById = {};
      const queue = [];
      queue.push(...children);
      while (queue.length > 0) {
        const child = queue.shift();
        if (nodeById[child.id]) {
          continue;
        }
        nodeById[child.id] = true;
        this.addView(new SkillNodeView(id, child));
        if (child.children) {
          for (let i = 0; i < child.children.length; i++) {
            const node2 = child.children[i];
            if (nodeById[node2.id]) {
              continue;
            }
            queue.push(node2);
          }
        }
      }
    }
    /**
     * @private
     * @param {SkillNode} rootNode 
     */
    addNodeConnectionViews(rootNode) {
      const id = this.getElementId();
      const queue = [];
      queue.push(rootNode);
      const nodeById = {};
      while (queue.length > 0) {
        const current = queue.shift();
        if (nodeById[current.id]) {
          continue;
        }
        nodeById[current.id] = true;
        const children = current.children;
        if (!children) {
          continue;
        }
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          this.addView(new NodeConnectionView(id, current, child));
          if (nodeById[child.id] || !child.children) {
            continue;
          }
          queue.push(child);
        }
      }
    }
    /**
     * Invoked at startup or after a save has been loaded.
     * @override
     */
    initializeView() {
      const parent = Page.getElement(this.parentId);
      this.mainElement = Page.createElement("div", parent, this.elementId, "skill-tree-graph");
      this.setInitialVisibility(false);
      this.userInput.attachListeners(document, this.mainElement);
      super.initializeView();
    }
    /**
     * @override
     */
    updateViewContents() {
      let updateNodes = false;
      const zoom = this.skillTreeGraph.zoom;
      if (this.displayedZoom !== zoom) {
        this.mainElement.style.zoom = zoom + "%";
        this.displayedZoom = zoom;
        updateNodes = true;
      }
      const centerOffset = this.skillTreeGraph.centerOffset;
      if (!this.displayCenterOffset.equals(centerOffset)) {
        this.displayCenterOffset.copy(centerOffset);
        updateNodes = true;
      }
      if (updateNodes) {
        this.updateNodeCoordinates();
      }
      super.updateViewContents();
    }
    /**
     * @private
     */
    updateNodeCoordinates() {
      const width = this.mainElement.clientWidth;
      const height = this.mainElement.clientHeight;
      const canvasX = width / 2;
      const canvasY = height / 2;
      const centerOffset = this.skillTreeGraph.centerOffset;
      for (let i = 0; i < this.skillTreeGraph.skills.length; i++) {
        const skill = this.skillTreeGraph.skills[i];
        for (let j = 0; j < skill.nodes.length; j++) {
          const node = skill.nodes[j];
          const nodeX = canvasX + centerOffset.x + node.graphCoordinate.x;
          const nodeY = canvasY + centerOffset.y + node.graphCoordinate.y;
          node.viewCoordinate.set(nodeX, nodeY);
        }
      }
    }
  };

  // src/view/GameView.js
  var GameView = class extends ParentView {
    /**
     * @param {GameStateControl} gameStateControl 
     * @param {UserInput} mineCanvasUserInput
     * @param {UserInput} skillTreeUserInput
     */
    constructor(gameStateControl, mineCanvasUserInput, skillTreeUserInput) {
      super(null, PageIds.GAME_VIEW_CONTAINER);
      this.canvasView = null;
      this.skillTreeView = null;
      this.mineCanvasUserInput = mineCanvasUserInput;
      this.skillTreeUserInput = skillTreeUserInput;
      this.gameStateControl = gameStateControl;
    }
    /**
     * Called by GameLoop during initialization to create the UI.
     * @param {State} state
     */
    createChildren(state) {
      const elementId = this.getElementId();
      this.removeChildViewElements();
      Page.clearChildren(elementId);
      this.canvasView = new CanvasView(elementId, state, this.mineCanvasUserInput);
      this.addView(this.canvasView);
      this.skillTreeView = new SkillTreeView(elementId, state.skillTreeGraph, this.skillTreeUserInput);
      this.addView(this.skillTreeView);
      const popupViewController = new PopupViewController();
      popupViewController.addPopupView(this.skillTreeView);
      this.addView(new GameViewOverlay(elementId, state, this.gameStateControl, popupViewController));
      this.initializeView();
    }
    /**
     * @returns {HTMLCanvasElement}
     */
    getCanvas() {
      return this.canvasView.getCanvas();
    }
    resetGameView() {
      this.removeAll();
    }
  };

  // src/input/InputHandler.js
  var InputHandler = class {
    /**
     * @param {UserInput} userInput 
     * @param {Projection} projection
     * @param {WorldGrid} worldGrid
     * @param {Selection} selection
     * @param {PanAnimation}
     */
    constructor(userInput, projection, worldGrid, panAnimation) {
      this.userInput = userInput;
      this.projection = projection;
      this.worldGrid = worldGrid;
      this.panAnimation = panAnimation;
      this.mapPanned = false;
      this.mapPannedTime = 0;
      this.delta = new Vector(0, 0);
      this.screenCoordinate = new Vector(0, 0);
      this.clickWorldCoordinate = new Vector(0, 0);
      this.hoverWorldCoordinate = new Vector(0, 0);
    }
    /**
     */
    handleInput() {
      if (this.userInput.leftMouseClick) {
        this.handleMouseClick();
      } else {
        this.handlePanning();
        this.handleZoomInput();
      }
    }
    resetInputHandler() {
      this.userInput.resetInputState();
    }
    /**
     * @private
     */
    handleMouseClick() {
      this.screenCoordinate.set(this.userInput.clickX, this.userInput.clickY);
      this.projection.screenToWorld(this.screenCoordinate, this.clickWorldCoordinate);
    }
    /**
     * @private
     */
    handlePanning() {
      if (this.userInput.leftMouseDown) {
        this.delta.x = this.userInput.mouseDeltaX;
        this.delta.y = this.userInput.mouseDeltaY;
      } else {
        this.delta.x *= Settings.input.panning.decayFactor;
        this.delta.y *= Settings.input.panning.decayFactor;
        if (Math.abs(this.delta.x) < 1) {
          this.delta.x = 0;
        }
        if (Math.abs(this.delta.y) < 1) {
          this.delta.y = 0;
        }
      }
      if (this.delta.x !== 0 || this.delta.y !== 0) {
        this.mapPanned = true;
        this.mapPannedTime = Date.now();
        this.projection.updateSpaceCenter(
          this.projection.screenToWorldDistance(-this.delta.x),
          this.projection.screenToWorldDistance(-this.delta.y)
        );
        this.projection.stayCenteredOnCharacter = false;
        this.panAnimation.animating = false;
      } else {
        this.mapPanned = false;
      }
    }
    // /**
    //  * @private
    //  */
    // handleHover() {
    //     // this.screenCoordinate.set(this.userInput.mouseX, this.userInput.mouseY);
    //     // this.projection.screenToWorld(this.screenCoordinate, this.hoverWorldCoordinate);   
    //     // // // If the click is outside of the world grid, then ignore it.
    //     // // if (!this.worldGrid.contains(this.hoverWorldCoordinate)) {
    //     // //     this.selection.hoveredTile = null;
    //     // //     return;
    //     // // }
    //     // this.selection.hoveredTile = this.worldGrid.findGridTile(this.hoverWorldCoordinate);
    // }
    /**
     * @private
     */
    handleZoomInput() {
      var mouseWheelMotion = this.userInput.mouseWheelMotion;
      if (mouseWheelMotion < 0) {
        this.projection.zoomIn();
      } else if (mouseWheelMotion > 0) {
        this.projection.zoomOut();
      }
    }
  };

  // src/input/SkillTreeInputHandler.js
  var SkillTreeInputHandler = class {
    /**
     * 
     * @param {UserInput} userInput 
     * @param {SkillTreeGraph} skillTreeGraph 
     */
    constructor(userInput, skillTreeGraph) {
      this.userInput = userInput;
      this.skillTreeGraph = skillTreeGraph;
      this.mapPanned = false;
      this.mapPannedTime = 0;
      this.delta = new Vector(0, 0);
    }
    /**
     */
    handleInput() {
      if (this.userInput.leftMouseClick) {
        return;
      }
      this.handlePanning();
      this.handleZoomInput();
    }
    resetInputHandler() {
      this.userInput.resetInputState();
    }
    // /**
    //  * @private
    //  */
    // handleMouseClick() {
    //     this.screenCoordinate.set(this.userInput.clickX, this.userInput.clickY);
    //     this.projection.screenToWorld(this.screenCoordinate, this.clickWorldCoordinate);   
    // }
    /**
     * @private
     */
    handlePanning() {
      if (this.userInput.leftMouseDown) {
        this.delta.x = this.userInput.mouseDeltaX;
        this.delta.y = this.userInput.mouseDeltaY;
      } else {
        this.delta.x *= Settings.input.panning.decayFactor;
        this.delta.y *= Settings.input.panning.decayFactor;
        if (Math.abs(this.delta.x) < 1) {
          this.delta.x = 0;
        }
        if (Math.abs(this.delta.y) < 1) {
          this.delta.y = 0;
        }
      }
      if (this.delta.x !== 0 || this.delta.y !== 0) {
        this.mapPanned = true;
        this.mapPannedTime = Date.now();
        this.skillTreeGraph.updateCenter(this.delta.x, this.delta.y);
      } else {
        this.mapPanned = false;
      }
    }
    /**
     * @private
     */
    handleZoomInput() {
      var mouseWheelMotion = this.userInput.mouseWheelMotion;
      if (mouseWheelMotion < 0) {
        this.skillTreeGraph.zoomIn();
      } else if (mouseWheelMotion > 0) {
        this.skillTreeGraph.zoomOut();
      }
    }
  };

  // src/logic/FrameLogic.js
  var FrameLogic = class {
    /**
     * 
     * @param {InputHandler} inputHandler 
     * @param {SkillTreeInputHandler} skillTreeInputHandler
     */
    constructor(inputHandler, skillTreeInputHandler) {
      this.inputHandler = inputHandler;
      this.skillTreeInputHandler = skillTreeInputHandler;
      this.elapsedTurnFrames = 0;
      this.prevWorldGridShiftCount = -1;
      this.frameTimeRatio = 1;
      this.turnStart = false;
      this.lastSaveTime = Date.now();
      this.workingGridCenter = new Vector(0, 0);
      this.elapsedSaveThreshold = 1e3 * 60 * 2;
      const thisRef = this;
      this.performMonsterFrameActionsForGrid = /**
       * @param {Grid} grid 
       */
      function(grid) {
        const characters = grid.characters;
        for (let i = 0; i < characters.length; i++) {
          if (characters[i].isMonster()) {
            characters[i].performFrameActions(thisRef.frameTimeRatio, thisRef.turnStart);
          }
        }
      };
      this.processMonsterTurnsForGrid = /**
       * @param {Grid} grid 
       */
      function(grid) {
        const characters = grid.characters;
        for (let i = 0; i < characters.length; i++) {
          const character = characters[i];
          const tile = character.position.tile;
          if (character.isMonster() && tile && tile.lighting.everVisibleToCharacter) {
            character.chooseTurn();
          }
        }
      };
    }
    /**
     * @param {State} state 
     * @param {number} frameTimeRatio 
     */
    processFrameLogic(state, frameTimeRatio) {
      state.gameTime.frameNumber += frameTimeRatio;
      if (state.gameTime.frameNumber > 1e10) {
        state.gameTime.frameNumber = 0;
      }
      this.inputHandler.handleInput();
      this.skillTreeInputHandler.handleInput();
      let newTurn = false;
      this.elapsedTurnFrames += frameTimeRatio;
      if (this.elapsedTurnFrames >= Settings.time.turnFrames) {
        newTurn = true;
        this.elapsedTurnFrames -= Settings.time.turnFrames;
      }
      const worldGridShiftCount = state.worldGrid.shiftCount;
      if (this.prevWorldGridShiftCount !== worldGridShiftCount) {
        this.prevWorldGridShiftCount = worldGridShiftCount;
      }
      if (newTurn) {
        this.processTurnLogic(state);
      }
      this.performCharacterActions(state, frameTimeRatio, newTurn);
      if (state.partyTarget.nextLayerDescription && state.partyTarget.nextLayerDescription.minDepth <= state.runStatistics.maxDepth) {
        state.partyTarget.unlockNextLayer();
      }
      state.physicsManager.updatePhysicsForFrame(frameTimeRatio);
      state.effectManager.updateEffectsForFrame(frameTimeRatio);
      this.updateGridCenter(state, frameTimeRatio);
      state.projection.updateProjectionForFrame();
      state.gridLoadingManager.manageLoadedGridsForFrame();
      if (newTurn) {
        this.updateDynamicLighting(state.lightingCalculator, state.crew, state.gameOptions);
        state.skillTreeGraph.updateSkillsForTurn();
      }
      state.skillTreeGraph.updateSkillsForFrame(frameTimeRatio);
      state.sprites.spriteAnimationManager.updateForFrame(frameTimeRatio);
      state.infoTextProcessor.updateTextForFrame(frameTimeRatio);
      const currentTime = Date.now();
      if (currentTime - this.lastSaveTime > this.elapsedSaveThreshold) {
        state.saveManager.saveGame(state);
        this.lastSaveTime = currentTime;
      }
    }
    /**
     * @param {LightingCalculator} lightingCalculator
     * @param {Crew} crew
     * @param {GameOptions} gameOptions
     */
    updateDynamicLighting(lightingCalculator, crew, gameOptions) {
      PerformanceMetrics.startTime("LightingReset");
      lightingCalculator.resetForFrame();
      PerformanceMetrics.endTime("LightingReset");
      const miners = crew.miners;
      PerformanceMetrics.startTime("DynamicLighting");
      for (let i = 0; i < miners.length; i++) {
        const tile = miners[i].position.tile;
        if (!tile) {
          continue;
        }
        if (i === 0) {
          lightingCalculator.calculatePrimaryPositionalLighting(tile);
        } else {
          lightingCalculator.calculateSecondaryPositionalLighting(tile);
        }
      }
      PerformanceMetrics.endTime("DynamicLighting");
    }
    /**
     * @private
     * @param {State} state 
     * @param {number} frameTimeRatio 
     */
    updateGridCenter(state, frameTimeRatio) {
      if (!state.panAnimation.animating && !state.projection.stayCenteredOnCharacter && Date.now() - this.inputHandler.mapPannedTime > 1e3 * 10) {
        state.panAnimation.startAnimation();
      }
      if (state.panAnimation.animating) {
        state.panAnimation.updateForFrame(frameTimeRatio);
        return;
      }
      if (!state.projection.stayCenteredOnCharacter) {
        return;
      }
      state.crew.calculateCrewCenterCoordinate(this.workingGridCenter);
      state.projection.setGridCenter(this.workingGridCenter.x + Settings.tile.halfSize, this.workingGridCenter.y + Settings.tile.halfSize);
    }
    /**
     * @private
     * @param {State} state 
     * @param {number} frameTimeRatio 
     * @param {boolean} turnStart
     */
    performCharacterActions(state, frameTimeRatio, turnStart) {
      const miners = state.crew.miners;
      for (let i = 0; i < miners.length; i++) {
        const miner = miners[i];
        if (!miner.position.tile) {
          continue;
        }
        miner.performFrameActions(frameTimeRatio, turnStart);
      }
      this.frameTimeRatio = frameTimeRatio;
      this.turnStart = turnStart;
      GridInversionOfControl.allVisibleGrids(state.worldGrid, state.projection, this.performMonsterFrameActionsForGrid);
    }
    /**
     * @private
     * @param {WorldGrid} worldGrid
     * @param {Crew} crew
     * @returns {boolean} True if the character has a tile in the loaded world.
     */
    validateCrewTiles(worldGrid, crew) {
      const centerTile = crew.calculateCrewCenterTile();
      if (!centerTile) {
        return false;
      }
      const miners = crew.miners;
      for (let i = 0; i < miners.length; i++) {
        const miner = miners[i];
        const minerValid = this.validateCharacterTile(worldGrid, miner);
        if (!minerValid) {
          const nearbyTile = NearbyTileUtil.findAvailableNearbyTile(miner, crew, centerTile);
          if (nearbyTile) {
            console.log("FrameLogic.validateCrewTiles() moving miner to valid grid near crew center.");
            miner.position.setTileAndOriginPosition(nearbyTile, nearbyTile.origin.x, nearbyTile.origin.y);
          } else {
            console.log("FrameLogic.validateCrewTiles() failed to move miner near crew center");
          }
        }
      }
      return true;
    }
    /**
     * @private
     * @param {WorldGrid} worldGrid 
     * @param {Character} character
     * @returns {boolean} True if the character has a tile in the loaded world.
     */
    validateCharacterTile(worldGrid, character) {
      const characterTile = worldGrid.findGridTile(character.position.worldCoordinateOrigin);
      if (character.position.tile) {
        if (characterTile && characterTile !== character.position.tile) {
          character.onInvalidGrid();
          character.position.setTileAndOriginPosition(characterTile, characterTile.origin.x, characterTile.origin.y);
          return true;
        } else if (!characterTile) {
          character.onInvalidGrid();
          return false;
        }
        return true;
      } else {
        if (characterTile) {
          character.onInvalidGrid();
          character.position.setTileAndOriginPosition(characterTile, characterTile.origin.x, characterTile.origin.y);
          return true;
        }
        return false;
      }
    }
    /**
     * @private
     * @param {State} state 
     */
    processTurnLogic(state) {
      state.gameTime.turnNumber++;
      state.statisticsIncrementor.incrementTurns(1);
      if (!this.validateCrewTiles(state.worldGrid, state.crew)) {
        state.vectorField.reset();
        return;
      }
      state.automationManager.updateForTurn();
      state.mineControl.updateForTurn();
      state.crewBrain.updateForTurn();
      GridInversionOfControl.allVisibleGrids(state.worldGrid, state.projection, this.processMonsterTurnsForGrid);
    }
  };

  // src/GameLoop.js
  var GameLoop = class {
    /**
     * @type {State} state
     * @type {GameView} gameView
     * @type {InputHandler} inputHandler
     * @param {SkillTreeInputHandler} skillTreeInputHandler
     */
    constructor(state, gameView, inputHandler, skillTreeInputHandler) {
      this.state = state;
      this.gameView = gameView;
      this.inputHandler = inputHandler;
      this.skillTreeInputHandler = skillTreeInputHandler;
      this.prevTimeStamp = performance.now();
      this.frameLogic = new FrameLogic(inputHandler, skillTreeInputHandler);
      const selfReference = this;
      this.gameLoopReference = function() {
        selfReference.gameLoop();
      };
      this.fpsFrameCount = 0;
      this.fpsMillis = 0;
      this.offlineThresholdMillis = 1e3 * 60 * 30;
      this.gameStateControl = null;
      this.callbackCode = -1;
      this.prevFrameVisible = false;
    }
    /**
     * 
     * @param {GameStateControl} gameStateControl 
     * @param {number} callbackCode
     */
    requestGameStateCallback(gameStateControl, callbackCode) {
      this.gameStateControl = gameStateControl;
      this.callbackCode = callbackCode;
    }
    startGameLoop() {
      this.fpsFrameCount = 0;
      this.fpsMillis = 0;
      this.prevTimeStamp = performance.now();
      window.requestAnimationFrame(this.gameLoopReference);
    }
    /**
     * Starts the game loop.
     * @private
     */
    gameLoop() {
      window.requestAnimationFrame(this.gameLoopReference);
      const timeStamp = performance.now();
      const deltaMillis = timeStamp - this.prevTimeStamp;
      if (deltaMillis < this.state.gameOptions.getFpsMillis()) {
        return;
      }
      this.prevTimeStamp = timeStamp;
      const deltaTime = deltaMillis > 0 ? deltaMillis : this.state.currentFps > 0 ? 1e3 / this.state.currentFps : 1e3 / 60;
      if (!this.state.gameVisible || !this.prevFrameVisible) {
        const offlineSeconds = deltaMillis / 1e3 | 0;
        if (offlineSeconds > 0) {
          console.log("GameLoop.gameLoop() earned offline credit: " + TimeFormatter.formatElapsedTime(offlineSeconds * 1e3));
          this.state.totals.offlineSeconds += offlineSeconds;
        }
        if (this.state.gameVisible && !this.prevFrameVisible && this.state.totals.offlineSeconds > 0) {
          this.state.offlineLogic.calculateOfflineEarnings();
        }
      }
      this.prevFrameVisible = this.state.gameVisible;
      if (this.gameStateControl) {
        this.gameStateControl.modelLoadCallback(this.callbackCode);
        this.gameStateControl = null;
        this.callbackCode = 0;
      } else if (this.state.gameVisible && !this.state.gamePaused) {
        const frameTimeRatio = deltaTime / Settings.time.defaultMillisPerFrame;
        this.frameLogic.processFrameLogic(this.state, frameTimeRatio);
        this.gameView.updateView();
      }
      this.inputHandler.resetInputHandler();
      this.skillTreeInputHandler.resetInputHandler();
      this.fpsFrameCount++;
      this.fpsMillis += deltaMillis;
      if (this.fpsFrameCount >= 60) {
        this.state.currentFps = this.fpsFrameCount / (this.fpsMillis / 1e3) | 0;
        this.fpsFrameCount = 0;
        this.fpsMillis = 0;
      }
    }
  };

  // src/GameState.js
  var GameState = class extends GameStateControl {
    constructor() {
      super();
      this.state = new State(this);
      this.mineCanvasUserInput = new UserInput();
      this.skillTreeUserInput = new UserInput();
      this.gameView = new GameView(this, this.mineCanvasUserInput, this.skillTreeUserInput);
      this.inputHandler = new InputHandler(this.mineCanvasUserInput, this.state.projection, this.state.worldGrid, this.state.panAnimation);
      this.skillTreeInputHandler = new SkillTreeInputHandler(this.skillTreeUserInput, this.state.skillTreeGraph);
      this.gameLoop = new GameLoop(this.state, this.gameView, this.inputHandler, this.skillTreeInputHandler);
      this.started = false;
      this.gameInitialized = false;
      this.saveStateText = null;
    }
    /**
     * @param {boolean} gameVisible 
     */
    onVisibilityChange(gameVisible) {
      this.state.gameVisible = gameVisible;
    }
    /**
     * Invoked whenever the window is resized.
     * @param {number} width 
     * @param {number} height 
     */
    onWindowResize(width, height) {
      const canvas = this.gameView.getCanvas();
      if (canvas) {
        canvas.width = width;
        canvas.height = height;
      }
    }
    saveGame() {
      this.state.saveManager.saveGame(this.state);
    }
    /**
     * @override
     * @returns {State}
     */
    getState() {
      return this.state;
    }
    /**
     * @returns {boolean}
     */
    isStarted() {
      return this.started;
    }
    /**
     * @override
     */
    startGame() {
      if (this.started) {
        return;
      }
      if (!this.gameInitialized) {
        this.initialize();
      }
      this.gameLoop.startGameLoop();
      this.started = true;
    }
    /**
     * Perform one-time initialization.
     * The sprites must be loaded before this is invoked.
     * This must be invoked before gameLoop().
     * @private
     */
    initialize() {
      if (this.gameInitialized) {
        return;
      }
      if (!this.state.sprites.isInitialized()) {
        console.log("GameState.initialize() ERROR The sprites have not been initialed yet.");
      }
      const saveLoaded = this.state.saveManager.loadSave(this.state);
      this.state.initializeState(saveLoaded);
      this.gameView.createChildren(this.state);
      this.gameInitialized = true;
    }
    ////////////////////////////////////
    // GameModel
    ////////////////////////////////////
    /**
     * @override
     */
    prestigeGame() {
      this.gameLoop.requestGameStateCallback(this, this.CALLBACK_GAME_PRESTIGE);
    }
    /**
     * @override
     */
    resetGame() {
      this.gameLoop.requestGameStateCallback(this, this.CALLBACK_GAME_RESET);
    }
    /**
     * @override
     */
    deleteGame() {
      this.gameLoop.requestGameStateCallback(this, this.CALLBACK_GAME_DELETE);
    }
    /**
     * @override
     * @param {string} saveStateText 
     */
    importSave(saveStateText) {
      this.saveStateText = saveStateText;
      this.gameLoop.requestGameStateCallback(this, this.CALLBACK_GAME_IMPORT);
    }
    /**
     * @abstract
     * @param {number} callbackCode 
     */
    modelLoadCallback(callbackCode) {
      if (callbackCode === this.CALLBACK_GAME_RESET) {
        this.resetInternal();
      } else if (callbackCode === this.CALLBACK_GAME_DELETE) {
        this.deleteInternal();
      } else if (callbackCode === this.CALLBACK_GAME_IMPORT) {
        this.importInternal();
      } else if (callbackCode === this.CALLBACK_GAME_PRESTIGE) {
        this.prestigeInternal();
      } else {
        console.log("GameState.modelLoadCallback(callbackCode) Invalid callback code: " + callbackCode);
      }
    }
    /**
     * @private
     */
    resetInternal() {
      const saveManager = this.state.saveManager;
      saveManager.deleteSave();
      this.state.resetForPrestige();
      this.gameView.resetGameView();
      this.gameView.createChildren(this.state);
      saveManager.saveGame(this.state);
    }
    /**
     * @private
     */
    deleteInternal() {
      const saveManager = this.state.saveManager;
      saveManager.deleteSave();
      this.state.resetFull();
      this.gameView.resetGameView();
      this.gameView.createChildren(this.state);
      saveManager.saveGame(this.state);
    }
    /**
     * @private
     */
    prestigeInternal() {
      this.state.statisticsIncrementor.incrementPrestigePoints(this.state.totals.unclaimedPrestige);
      this.state.totals.onPrestige();
      this.resetInternal();
    }
    /**
     * @private
     */
    importInternal() {
      console.log("GameState.importInternal() START");
      const saveManager = this.state.saveManager;
      const oldSaveStateText = saveManager.getSaveStateForExport(this.state);
      this.state.beforeImportSave();
      if (!saveManager.importSave(this.state, this.saveStateText)) {
        console.log("GameState.importInternal() IMPORT FAILED. REVERTING TO PREV SAVE");
        this.state.beforeImportSave();
        saveManager.importSave(this.state, oldSaveStateText);
      }
      this.saveStateText = null;
      this.state.afterImportSave();
      this.gameView.resetGameView();
      this.gameView.createChildren(this.state);
      console.log("GameState.importInternal() DONE");
    }
  };

  // src/Game.js
  var Game = class {
    constructor() {
      this.gameState = new GameState();
      const selfReference = this;
      this.resourceLoadingLoop = function() {
        selfReference.waitForResourcesToLoad();
      };
    }
    /**
     * @param {Window} window 
     */
    onResize(window2) {
      this.gameState.onWindowResize(window2.innerWidth, window2.innerHeight);
    }
    /**
     * Invoked when the visible state of the document changes. If the page is minimized, put in a background tab,
     * or put back as the foreground tab.
     */
    onVisibilityChange() {
      if (typeof document.hidden !== "undefined") {
        console.log("Game.onVisibilityChange() hidden=" + document.hidden);
        this.gameState.onVisibilityChange(!document.hidden);
      }
    }
    /**
     * @param {Window} window
     * @param {Document} document
     */
    onLoad(window2, document2) {
      if (this.gameState.isStarted()) {
        return;
      }
      console.log("Game.onLoad() Loading game.");
      const thisRef = this;
      document2.addEventListener("visibilitychange", function(e) {
        thisRef.onVisibilityChange();
      }, false);
      this.waitForResourcesToLoad();
    }
    onUnload() {
      console.log("Game.onUnload()");
      this.gameState.saveGame();
    }
    /**
     * @private
     */
    waitForResourcesToLoad() {
      if (this.gameState.state.sprites.isInitialized()) {
        console.log("Game.waitForResourcesToLoad() Resources are loaded. Starting game.");
        this.gameState.startGame();
      } else {
        console.log("Game.waitForResourcesToLoad() Resources not yet loaded. Waiting...");
        window.requestAnimationFrame(this.resourceLoadingLoop);
      }
    }
  };

  // src/index.js
  (() => {
    const game = new Game();
    window.onresize = function() {
      game.onResize(window);
    };
    window.onload = function() {
      game.onLoad(window, document);
    };
    window.onbeforeunload = function() {
      game.onUnload();
    };
  })();
})();
